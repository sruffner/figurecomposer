function res = matfig2fyp(figHandle, dst, varargin)
%MATFIG2FYP Convert a Matlab figure to Figure Composer's FypML format (if possible) and optionally save it to file.
%
% MATFIG2FYP(H, F) converts an open Matlab figure into a FypML figure model. H is the handle of the figure to be
% converted, and F is a character string specifying the path to which the converted FypML figure should be saved. If the
% conversion is successful, it raises a Java dialog in which the converted figure is previewed. After examining the 
% results, the user may choose to save the figure to the file location specified, or cancel the operation.
%
% Figure Composer (FC) is a Java application for composing scientific figures suitable for journal publication. For more 
% information, go to the Figure Composer online guide at https://sites.google.com/a/srscicomp.com/figure-composer.
%
% The path specified in F must be reachable even if the file itself does not yet exist (any directory specified must 
% exist); also, the file name should end in ".fyp". If it does not, that extension will be appended to F. Finally, if
% a file already exists at F, that file will be overwritten!
%
% MATFIG2FYP(H, F, C) converts Matlab figure with handle H to a FypML figure saved at F, but it lets you control whether
% or not the confirmation dialog is raised. Here C is a logical scalar; if C==false and conversion is successful, the 
% converted figure is saved to file without confirmation. This form is useful when running a script that generates 
% multiple figures, since raising the modal confirmation dialog will interfere with that script.
%
% MATFIG2FYP(H, F, C, L) is the same as MATFIG2FYP(H, F, C), but it also lets you override the default axis label 
% offset (0.5 inch). This is helpful in situations where the axis labels for plots at the bottom of the figure get "cut
% off" in the conversion process. Here L is a double scalar specifying the desired axis label offset in [0.1 .. 1] inch;
% it is ignored if it is not within this range. Note that L will be used for the label offsets of ALL graph axes in the 
% figure.
%
% Given the many differences between the Matlab and FypML figure models, users should be aware of the limitations of
% MATFIG2FYP. FypML has only limited support for 3D graphs, while Matlab has extensive 3D capabilities. Furthermore, as 
% it traverses the hierarchy of Handle Graphics objects that make up a Matlab figure, it will skip over any object types
% that it does not support. Thus, the "universe" of Matlab figures that can be reasonably converted to FypML format is 
% severely limited. That said, MATFIG2FYP offers an extremely easy way to get basic Matlab figures (and, especially, the
% data embedded therein) into Figure Composer. Users are likely to find it a far more convenient approach than designing 
% the figure from scratch in FC, and populating that figure with data from a FC-compatible data set source file created 
% in Matlab with the PUTDATANAVSRC utility.
%
% Below are the "use cases" that MATFIG2FYP can currently handle:
%    -- Convert any number of 'axes' having 2D Cartesian coordinates to FypML 'graph' elements, including axes title, 
%       x- and y-axis labels (if set), current x- and y-axis ranges, and major tick marks. If 'PlotBoxAspectRatio' == 
%       'manual' or 'DataAspectRatioMode', adjust size and location of the graph to respect the 'PlotBoxAspectRatio' 
%       while keeping it confined to the region defined by the 'Position' property.
%    -- Import custom tick mark labels on the x- and y-axis of a Matlab 'axes' object. The custom labels are assigned to
%       the first tick set child of the relevant axis node in the parent FypML graph.
%    -- Cartesian, semilogx, semilogy, and loglog are all supported.
%    -- Convert 2D 'surface' or 'image' plot to a FypML contour node, configured to display as a "heat map". The color 
%       map assigned to the parent FypML graph's "color bar" is selected to match the Matlab figure's color map as best
%       as possible. [FypML lets you attach a different color map to each graph, but offers a limited choice of color
%       maps; Matlab defines a single color map for the entire figure, but that color map can be almost anything.] The 
%       conversion works only when the 'surface' or 'image' object's 'CData' is a 2D matrix and 'CDataMapping' == 
%       "scaled". True color specification of the surface or image ('CData' is 3D) is not available in FypML.
%    -- Convert a 'specgraph.contourgroup' plot object in a 2D graph -- generated by the contour() or contourf() 
%       function -- into a FypML contour node. The node's XYZIMG data set is extracted from the plot object's 'ZData'. 
%       The 'XData' and 'YData' fields are checked to verify that they define a regular grid of samples in (X,Y) space 
%       (irregular sampling not supported in FypML); the X,Y ranges of the XYZIMG data set are obtained from these 
%       fields. If 'Fill' = 'on', color-mapped filled contour regions are drawn with super-imposed contour level lines;
%       otherwise, only color-mapped level lines are drawn. NOTE that FypML does not currently support contour plots in
%       a 3D context.
%    -- Convert any 'graph2d.lineseries' plot object into a FypML trace node. The (X,Y) data stored in that plot object
%       is extracted and converted to a FC data set format and included in the FypML figure. Depending on the nature of
%       the plot object's 'XData', the data set will be a FypML "ptset" or "series".
%    -- If an axes contains multiple 'graph2d.lineseries' plots that all have the same 'XData' and the same appearance,
%       then these are combined into a single FypML trace node displaying a collection-type data set, "mset" or 
%       "mseries", in the "multitrace" display mode.
%    -- If an axes contains multiple 'graph2d.lineseries' plots that each contain a single (x,y) point ('XData' and 
%       'YData' are scalars) and have the same appearance, they are combined into a single FypML scatter plot node 
%       backed by a 2D "ptset" data source.
%    -- Convert any 'line' object into a FypML line node (if the line contains only two points and no marker symbols) or
%       trace node. However, a collection of 'line' objects having the same appearance and containing 3 or more points
%       are combined into a single FypML trace node in which the component lines are rendered as disjoint polylines (by
%       inserting a [NaN, NaN] point between the end of one line and the beginning of the next).
%    -- If the (X,Y) data for a 'graph2d.lineseries' object represents a raster plot as prepared by the DN_RASTERPLOT()
%       utility, that plot is converted to an FypML raster node instead of a trace node. See DN_RASTERPLOT for details
%       on the structure of the 'XData' and 'YData' vectors for this specialized plot type.
%    -- Convert any 'specgraph.errorbarseries' plot object into a FypML trace node with a FypML "ptset" or "series" data
%       set. Note that, in Matlab, the error bars are always stroked with a solid line style, using the same color and 
%       line width as the trace line; and the error bar endcaps in Matlab are always short lines (default length of 6pt)
%       perpendicular to the error bar. In the conversion, we try to preserve this appearance, using FypML "linethru" 
%       marker symbol for the endcap type. Horizontal error bars and a property setting the endcap size were added in
%       Matlab R2016b, and MATFIG2FYP was updated to support these changes in FC v5.1.1. V5.1.1 also improved the 
%       conversion to support individual one-sided error bars. Still Matlab allows for unsymmetrical error bars, which
%       FypML does not support; when an unsymmetrical error bar (yNeg, yPos) is encountered, the conversion sets 
%       yStd = max(yNeg, yPos) in the "series" or "ptset" data.
%    -- Convert any 'specgraph.stairseries' plot object (generated by the stairs() function) into a FypML trace node 
%       in the "staircase" display mode.
%    -- Convert any 'specgraph.scattergroup' plot object -- as would be generated by the scatter() function -- into a
%       FypML scatter plot node. The 'CData' and 'SizeData' properties are analyzed to determine whether the data 
%       represented are 2D ("ptset") or 3D ("xyzset"); in the 3D case, a form of "bubble" plot is generated, and the
%       Z-coordinate values are based on the values in the 'CData' or 'SizeData' vector. Exact replication of a Matlab 
%       bubble plot is unlikely, especially if both the size and colors of the markers vary.
%    -- A 'patch' plot object can have a wide range of uses in a Matlab figure, most of which have no FypML counterpart.
%       However, there are currently two very specific use cases that MATFIG2FYP can recognize and handle: (1) a 'patch'
%       representing a histogram plot as generated by the Matlab hist() function; (2) a 'patch' containing a single face
%       representing an error band fill. If the 'patch' vertex and face data do not conform to either of these, then it
%       is simply ignored. As of FC V5.0.2, MATFIG2FYP can import a translucent histogram or error band fill by checking
%       the 'patch' object's 'FaceAlpha' property. It only respects a scalar value [0..1] for the property; if its value
%       is 'flat' or 'interp', then the color will be opaque.
%    -- The Matlab histogram() function (R2014b or later) generates a histogram plot that is superior to using the
%       hist() function because it preserves the original sample data from which the histogram is generated. MATFIG2FYP
%       can convert the HG 'histogram' object into a FypML "raster" node, unless 'Visible' = 'off', 'DisplayStyle' = 
%       'stairs' or 'Orientation' = 'horizontal'. It does not support all of the different 'Normalization' modes; 
%       'cumcount' and 'countdensity' are treated as identical to 'cdf', while 'probability' maps to 'pdf'. Translucent
%       fill color is supported.
%    -- The Matlab bar() function generates a bar plot composed of 1 or more 'specgraph.barseries' objects sharing a
%       common 'specgraph.baseline' object representing the baseline of the bar plot. MATFIG2FYP will coalesce all such
%       linked 'barseries' into a single FypML bar plot node. Both vertical and horizontal orientations are supported,
%       as are the grouped and stacked layouts. Bar group fill colors and labels (if present) are preserved. All bar
%       groups are stroked in the same way, even if this is not the case in the Matlab figure -- since the FypML bar
%       plot node does not support defining distinct stroking properties for each bar group. The 'specgraph.baseline' 
%       object is rendered in FypML as a 'line' node.
%    -- The Matlab function area(Y,B) function generates a stacked area chart defined by the columns of the matrix Y 
%       and starting at baseline y=B. The area chart is composed of N 'specgraph.areaseries' objects, where N is the
%       number of columns in Y. MATFIG2FYP will coalesce all such linked 'areaseries' into a single FypML area chart
%       node. The fill color and label (if present) assigned to each "band" in the area chart are preserved. All bands
%       in the chart are stroked in the same way, even if this is not the case in the Matlab figure -- since the FypML 
%       area chart node does not support defining distinct stroking properties for each data group. Also note that
%       FypML supports a maximum number of N=20 bands in a single area chart.
%    -- The Matlab stem(Y) function generates a 2D stem plot, represented by the 'specgraph.stemseries' object. Multiple
%       stem plots in a single axes share a common baseline represented by a single 'specgraph.baseline' object. 
%       MATFIG2FYP will convert each 'stemseries' into a FypML trace node in the "histogram" display mode with zero bar
%       width to achieve the look of a stem plot. 
%    -- In Matlab a legend is a specialized 'axes' object that is attached to a normal 'axes'. When MATFIG2FYP 
%       encounters a 'scribe.legend' object, it turns on the automated legend feature of the FypML graph corresponding
%       to the 'axes' with which the 'scribe.legend' is associated. It tries to reproduce the location and styling of 
%       the Matlab legend in its FypML counterpart as best as possible, but expect some differences here. 
%    -- Similarly, when MATFIG2FYP encounters a 'scribe.colorbar' object, it turns on the color axis of the FypML graph
%       corresponding to the 'axes' attached to the Matlab colorbar.
%    -- Any single-line text labels in an 'axes' that are not the specially designated x- or y-axis label are added to
%       the companion FypML graph as label nodes.
%    -- MATFIG2FYP can convert TeX-encoded "special characters" (eg, Greek letters) in a 'text' object, so long as the
%       character has a counterpart in FypML. If not it is replaced by a '?'. TeX formatting commands are treated as
%       plain text.
%    -- Polar plots in Matlab are constructed very differently from how they're rendered in FypML. Nevertheless, a
%       Matlab 'axes' object generated by the polar(), rose() and compass() functions have a particular structure, and
%       as long as you don't make extensive changes that would obfuscate that structure, MATFIG2FYP can "detect" that
%       the 'axes' is configured as a polar plot and translate it into a reasonable FypML facsimile.
%    -- Similarly, an 'axes' object generated by Matlab's pie() function has a particular sequence of child nodes. If 
%       MATFIG2FYP detects this sequence, it will import the 'axes' as a polar graph in FypML, containing a pie chart
%       consistent with the sequence of child nodes. However, unlike Matlab, FypML does not support a pie chart with a
%       "missing slice". Also, the Matlab HG infrastructure does not preserve the original data passed into the pie()
%       function, so the underlying data for an imported pie chart will simply be the fractional size of each slice 
%       in the pie (eg, [0.3 0.5 0.1 0.05 0.05]).
%    -- Matlab R2016a/b introduced a new Handle Graphics object representing a true polar plot, 'matlab.graphics.axis.
%       PolarAxes', along with several new polar plotting functions that generate this object: polarplot() replaces the
%       deprecated polar(), polarhistogram() replaces the deprecated rose(), and polarscatter() offers a scatter plot in
%       polar coordinates. As of FC v5.0.3, MATFIG2FYP can import such polar plots. It can also still handle figures
%       generated by polar() and rose(), which remain available in Matlab R2016b.
%    -- Prior to FC 5.1.2, any Matlab polar plot (whether an 'axes' or the newer 'PolarAxes') were converted to a FypML 
%       'graph' element configured in polar coordinates. FC 5.1.2 introduced a new specialized 2D polar plot element,
%       'pgraph'. This element offers much of the same versatility (clockwise or counterclockwise theta, locate '0 deg'
%       in any direction, have a theta axis range less than 360 deg, etc) as Matlab's 'PolarAxes' object, and it handles
%       the rendering of the polar grid and grid labels automatically. As of FC 5.1.2, any Matlab polar plot --
%       whether 'axes' or 'PolarAxes', and including pie graphs -- is converted to a FypML 'pgraph' element.
%    -- As of FC 5.5.0, any Matlab bubblechart (introduced in R2020b) is converted to a FypML 'scatter' or 'scatter3d'
%       element. However, FypML computes individual bubbles sizes from the Z-coordinate data in a fundamentally
%       different way from Matlab (there's no notion of the bubble size limits defined in Matlab, other than a max
%       symbol size), so it cannot fully reproduce the bubblechart's appearance.
% As of FC 5.0, there is limited support for converting 3D Matlab graphs to FypML:
%    -- Unlike FypML, Matlab does not have a separate entity like 'axes3d' to present a 3D plot; instead,
%       the 'axes' object is configured for a 3D view whenever it is created by a 3D plotting function like scatter3(),
%       stem3(), and the like. When the 'CameraUpVector' = [0 1 0] and 'Projection' = 'orthographic', MATFIG2FYP assumes
%       the 'axes' is 2D and attempts to convert it to the FypML 'graph' node; else, it is 3D and is converted to the
%       FypML 'graph3d' node. 
%    -- MATFIG2FYP can convert 'text' objects in a 3D 'axes', but they will be correctly positioned ONLY if the 'text'
%       object's 'Units' property is 'normalized'. The Z-coordinate of the text object's position is ignored.
%    -- 3D scatter plots: Matlab's scatter3() plotting function creates the 'specgraph.scattergroup' plot object. Note 
%       that this plot object can also appear in a 2D graph context. The scatter plot object is mapped to a FypML 
%       'scatter' node in the 2D case (see above), and 'scatter3d' node in the 3D case. There is support for all of the 
%       different "bubble" display modes. However, there's an important difference here between FypML and Matlab: in 
%       FypML, marker size reflects the Z-coordinate of each datum; in Matlab, this need not be the case. The same is 
%       true for marker color in the "color bubble" modes.
%    -- 3D stem plots: Matlab's stem3() function creates the 'specgraph.stemseries' plot object. When this object is
%       a child of an 'axes' configured as a 3D plot, MATFIG2FYP will attempt to convert it to a 3D scatter plot with
%       stems drawn.
%    -- 3D line plots: Matlab's plot3() function creates a 'graph2d.lineseries' plot object as a child of an 'axes' 
%       configured as a 3D plot. MATFIG2FYP will convert this to an appropriately defined 3D scatter/line plot.
%    -- 3D surfaces: Matlab's surf() function creates a 3D surface plot -- a 'graph3d.surfaceplot' object. This object 
%       is converted to a FypML surface node containing an XYZIMG data set. Note that MATFIG2FYP only recognizes a few 
%       of the original surface object's properties when doing the conversion. The data is extracted from the 'ZData' 
%       property; 'XData' and 'YData' are examined only to get the data range in X and Y, [x0 x1 y0 y1] -- the FypML 
%       XYZIMG data format assumes a regular sampling of points over that range. The surface may be a single color or 
%       unfilled, or it may be filled IAW the 3D graph's color map, which is based on the MATLAB figure's color map. The
%       line width and color of the MATLAB surface's wire mesh is also respected, but the mesh is always stroked solid 
%       in FypML.
%    -- 3D bar plots: Matlab's bar3() function creates a 3D bar plot in which one or more sets of bars are rendered by
%       a primitive 'surface' object. As long as the bar plot is in the "detached" style, MATFIG2FYP will convert it
%       into a FypML 3D scatter plot configured in one of its bar plot display modes. Any 'surface' objects having the
%       same appearance (typically, bar3() generates multiple 'surface' objects) will be coalesced into a single plot
%       object. Note that the "FaceColor" property of each 'surface' must be an RGB color spec, "none", or "interp"; in
%       the latter case, the vertical bar faces are filled with an axial color gradient IAW the graph's color map.
%
% IMPORTANT USAGE NOTES
% 1) MATFIG2FYP() relies on Figure Composer-specific Java code available in the Matlab support package that comes with 
% the FC download distribution. The required JAR files are XPP3-1.1.3.4.D.JAR, ITEXTPDF-5.5.0.JAR, HHMI-MS-COMMON.JAR, 
% and HHMI-MS-DATANAV.JAR. To add them to Matlab's Java classpath, you can:
%    a) Use JAVACLASSPATH({P1, P2, P3}) on the Matlab command line, where P1, P2, and P3 are Matlab strings identifying 
% the absolute pathnames for each of these JARs on your system.
%    b) More conveniently, add the lines "javaaddpath P1", "javaaddpath P2", "javaaddpath P3" to your STARTUP.M file,
% where P1, P2, and P3 are again full file system pathnames locating each of these JARs.
%
% 2) MATFIG2FYP() was originally tested and developed on Matlab R2011b (7.13.0.564). Current development and testing
% uses R2017b, R2016b, and R2014b. Some of the code relies on undocumented properties of the various Matlab Handle 
% Graphics objects. I do not recommend using MATFIG2FYP on older versions of Matlab. If you're using a newer version and
% run into problems, send details to sruffner@srscicomp.com.
%
% 3) If MATFIG2FYP fails to convert a figure that you think it should be able to handle, email a copy of the original
% Matlab figure, along with a brief explanation of the problem (or the error message, if conversion failed altogether)
% to sruffner@srscicomp.com.
%
%       
% Scott Ruffner
% sruffner@srscicomp.com
%

% INTERNAL USE ONLY (not publicly documented): If method invocation includes only a single argument AX, then this should
% be a call from PUT2FYP() and the argument AX should be a valid handle to an HG 'axes' or 'PolarAxes' object. In this 
% scenario, the function prepares the FypML version of the 'figure' that contains the 'axes' or 'PolarAxes', and returns
% in RES the FypML graph, pgraph, or graph3d node that best replicates the Matlab plot. PUT2FYP() inserts this 2D or 3D
% graph into another FypML figure in place of an existing graph.
% RES = [] if operation fails or this use case does not apply.
res = [];
wantGraph = false;

% DEBUG ONLY (not publicly documented): If method invocation includes a fifth boolean argument D and D==true, the 
% converted Matlab figure tree will be dumped to 'dumpMatFig.txt' in the current working directory. Intended for 
% developer use only.
dbgDump = false;

nArgs = nargin;

if(nArgs == 1)
   % special INTERNAL USE ONLY case
   % NOTE: Starting with R2014b (8.4.0), graphics object handles are NOT numeric. We have to run the axes object through
   % handle2struct() to get a numeric handle out. Needed when containing figure is processed by matfig2fyp() to extract
   % the FypML graph object corresponding to that paricular axes.
   % NOTE2: As of FC 5.1.2, we support the Matlab 'polaraxes' object, introduced in R2016.
   wantGraph = true;
   axesH = figHandle;
   if(verLessThan('matlab', '8.4.0'))
      if(~(ishghandle(axesH) && strcmpi('axes', get(axesH, 'type'))))
         error('Bad axes handle');
      end
      figHandle = get(axesH, 'parent');
   else
      if(~(isgraphics(axesH, 'axes') || isgraphics(axesH, 'polaraxes')))
         error('Bad axes handle');
      end
      figHandle = get(axesH, 'parent');
      axStruct = handle2struct(axesH);
      axesH = axStruct.handle;
   end
elseif(nArgs < 2 || nArgs > 5)
   error('Invalid number of arguments');
end

if(~wantGraph)
   if(~ishandle(figHandle) || ~ischar(dst))
      error('Missing or bad argument');
   end
end

confirm = true;
if(nArgs >= 3)
   confirm = varargin{1};
   if(~(isscalar(confirm) && islogical(confirm)))
      error('Arg 3 invalid -- must be a logical scalar');
   end
end

labelOfs = 0;
if(nArgs >= 4)
   labelOfs = varargin{2};
   if(~(isscalar(labelOfs) && isnumeric(labelOfs)))
      error('Arg 4 invalid -- must be a numeric scalar');
   end
end

if(nArgs == 5 && islogical(varargin{3}))
   dbgDump = varargin{3};
end

fig = handle2struct(figHandle);
if(~strcmp(fig.type, 'figure'))
   error('Argument not a Matlab figure handle graphics object');
end

% make sure filename ends in '.fyp'. Tack it on otherwise. (Skip this step if we're just extracting a graph)
if(~wantGraph)

   jDst = java.lang.String(dst);
   if(jDst.length() < 4) 
      jDst = java.lang.String([dst '.fyp']);
   else
      jExt = jDst.substring(jDst.length()-4);
      if(~jExt.equalsIgnoreCase('.fyp'))
         jDst = java.lang.String([dst '.fyp']);
      end
   end

   jFile = java.io.File(jDst);
   if(~isjava(jFile.getParentFile()) || ~jFile.getParentFile().isDirectory())
      error('FypML file path not valid.');
   end
end

% construct tree of HGObjects representing the Matlab figure...
jFig = com.srscicomp.fc.matlab.HGObject(fig.type, fig.handle, []);
processProperties(fig, jFig);

% stack of HG structs still to process, and list of corresponding Java HGObjects
jHGObjects(1) = jFig;
hgStructs(1) = fig;

while(~isempty(hgStructs))
   jObj = jHGObjects(end);
   hgs = hgStructs(end);
   
   % if HGObject already has kids, then we're done populating its subtree and it's time to do post-processing on it.
   % Otherwise, add any relevant children to the HGObject. If it has none, do post-processing now.
   hgKids = []; jKids = [];
   if(jObj.getChildCount() > 0)
      jObj.afterChildrenAdded();
   else
      [hgKids, jKids] = addRelevantChildren(hgs, jObj);
      if(isempty(hgKids))
         jObj.afterChildrenAdded();
      end
   end
   
   % if we added some kids, push them onto the stack in front of the parent. Otherwise, pop the parent off the stack.
   if(isempty(hgKids))
      if(isscalar(hgStructs))
         hgStructs = []; jHGObjects = [];
      else
         hgStructs = hgStructs(1:end-1);
         jHGObjects = jHGObjects(1:end-1);
      end
   else
      for n=1:length(hgKids)
         hgStructs = cat(1, hgStructs, hgKids(n));
         jHGObjects = cat(1, jHGObjects, jKids(n));
      end
   end
end

% INTERNAL USE ONLY : We're just extracting a particular 2D or 3D graph from figure. Return that graph if conversion to
% FypML was successful. Else return null. Note that the extracted graph will not be in a figure model.
if(wantGraph)
   res = javaMethod('extractGraphFromMatFig', 'com.srscicomp.fc.matlab.MatlabUtilities', jFig, axesH);
   return;
end

% convert to FypML figure
jBuf = java.lang.StringBuffer;
jFGM = javaMethod('matFigToFyp', 'com.srscicomp.fc.matlab.MatlabUtilities', jFig, labelOfs, jBuf, dbgDump);

% DEBUG ONLY: Save tree dump (and possible error message) to file for debug purposes only
if(dbgDump)
   jWriter = java.io.FileWriter('dumpMatFig.txt', false);
   jWriter.write(jBuf.toString());
   jWriter.flush();
   jWriter.close();
end

if(~isjava(jFGM))
   error(['Unable to convert Matlab figure to valid FypML figure. ', char(jBuf.toString())]);
end

% raise confirmation dialog, unless user chose not to.
ok = true;
if(confirm)
   ok = javaMethodEDT('raiseConfirmSaveDialog', 'com.srscicomp.fc.matlab.DNFigureSaveDlg', jFGM, jFile);
end

% if confirmed, save the converted figure to file.
if(ok)
   emsg = javaMethod('toXML', 'com.srscicomp.fc.fig.FGModelSchemaConverter', jFGM, jFile);
   if(isjava(emsg))
      error(['Error saving FypML figure to file: ', char(emsg)]);
   end
end


   %=== processProperties(hgs, jObj) ==================================================================================
   % Nested function adds relevant properties of a Matlab Handle Graphics object to its Java HGObject counterpart. Only
   % properties that matter in the conversion of a Matlab to FypML figure are processed. 
   %
   function processProperties(hgs, jObj)
      
      props = {};
      % figure properties
      if(strcmp(hgs.type, 'figure'))
         props = {'Colormap', 'Name', 'PaperUnits', 'PaperPosition'};
      end
      
      % scribe.legend properties
      if(strcmp(hgs.type, 'scribe.legend'))
         props = {'TextColor', 'Position', 'Units', 'NumColumns', 'String', 'Color', 'Box', 'LineWidth'};
         props = cat(2, props, {'FontName', 'FontSize', 'FontUnits', 'FontWeight', 'FontAngle'});
      end
      
      % scribe.colorbar properties. Note: This object was modified substantially for Matlab 2014b (v8.4.0).
      if(strcmp(hgs.type, 'scribe.colorbar'))
         props = {'FontAngle', 'FontName', 'FontSize', 'FontWeight', 'LineWidth', 'Location', 'Position', 'Units'};
         if(verLessThan('matlab', '8.4.0'))
            props = cat(2, props, {'FontUnits','TickDir','TickLength','Visible','XColor','YColor','XTick','YTick'});
         else
            props = cat(2, props, {'TickDirection', 'TickLength', 'Ticks', 'Color', 'Visible', 'Limits'});
         end
      end

      % axes properties
      if(strcmp(hgs.type, 'axes'))
         props = {'CLim', 'FontAngle', 'FontName', 'FontSize', 'FontUnits', 'FontWeight', 'LabelFontSizeMultiplier'};
         props = cat(2, props, {'LineWidth', 'GridLineStyle', 'GridColor'});
         props = cat(2, props, {'PlotBoxAspectRatio', 'PlotBoxAspectRatioMode', 'DataAspectRatioMode', 'Position'});
         props = cat(2, props, {'TickDir', 'TickLength'});
         props = cat(2, props, {'Units', 'Visible', 'XAxisLocation', 'YAxisLocation', 'XColor', 'YColor', 'XDir'});
         props = cat(2, props, {'YDir', 'XGrid', 'YGrid', 'XLim', 'YLim', 'XScale', 'YScale', 'XTick', 'YTick'});
         props = cat(2, props, {'XMinorTick', 'YMinorTick', 'XTickLabelMode', 'XTickLabel'});
         props = cat(2, props, {'YTickLabelMode', 'YTickLabel'});
         
         % these properties added in support of 3D graph conversions
         props = cat(2, props, {'View', 'CameraUpVector', 'Projection'});
         props = cat(2, props, {'Color', 'Box', 'BoxStyle', 'ZLim', 'ZScale', 'ZGrid'});
         props = cat(2, props, {'ZTick', 'ZMinorTick', 'ZTickLabelMode', 'ZTickLabel'});
      end
      
       % polaraxes properties
      if(strcmp(hgs.type, 'matlab.graphics.axis.PolarAxes'))
         props = {'CLim', 'Color', 'FontAngle', 'FontName', 'FontSize', 'FontUnits', 'FontWeight'};
         props = cat(2, props, {'LineWidth', 'GridAlpha', 'GridColor', 'GridLineStyle', 'Position'});
         props = cat(2, props, {'RAxisLocation', 'RColor', 'RDir', 'RGrid', 'RLim', 'RTick', 'RTickLabel'});
         props = cat(2, props, {'RTickLabelMode', 'ThetaAxisUnits', 'ThetaColor', 'ThetaDir', 'ThetaGrid', 'ThetaLim'});
         props = cat(2, props, {'ThetaTick', 'ThetaTickLabel', 'ThetaTickLabelMode', 'ThetaZeroLocation'});
         props = cat(2, props, {'TitleFontWeight', 'TitleFontSizeMultiplier', 'Units', 'Visible'});
      end
      
      % graph2d.lineseries and specgraph.stairseries properties
      if(strcmp(hgs.type, 'graph2d.lineseries') || strcmp(hgs.type, 'specgraph.stairseries'))
         props = {'Color', 'DisplayName', 'LineStyle', 'LineWidth', 'Marker', 'MarkerEdgeColor'};
         props = cat(2, props, {'MarkerFaceColor', 'MarkerSize', 'XDataMode', 'XData', 'YData', 'ZData'});
      end
      
      % specgraph.errorbarseries properties
      if(strcmp(hgs.type, 'specgraph.errorbarseries'))
         props = {'CapSize', 'Color', 'DisplayName', 'LData', 'LineStyle', 'LineWidth', 'Marker', 'MarkerEdgeColor'};
         props = cat(2, props, {'MarkerFaceColor', 'MarkerSize', 'UData', 'XDataMode', 'XData', 'XNegativeDelta'});
        props = cat(2, props, {'XPositiveDelta', 'YData', 'YNegativeDelta', 'YPositiveDelta'});
      end
      
      % specgraph.scattergroup properties
      if(strcmp(hgs.type, 'specgraph.scattergroup'))
         props = {'CData', 'DisplayName', 'LineWidth', 'Marker', 'MarkerEdgeAlpha', 'MarkerEdgeColor'};
         props = cat(2, props, {'MarkerFaceAlpha', 'MarkerFaceColor', 'SizeData', 'XData', 'YData', 'ZData'});
      end
      
      % bubblechart properties
      if(strcmp(hgs.type, 'bubblechart'))
         props = {'CData', 'DisplayName', 'LineWidth', 'MarkerEdgeAlpha', 'MarkerEdgeColor'};
         props = cat(2, props, {'MarkerFaceAlpha', 'MarkerFaceColor', 'SizeData', 'XData', 'YData', 'ZData'});
      end

      % specgraph.stemseries properties
      if(strcmp(hgs.type, 'specgraph.stemseries'))
         props = {'BaseValue', 'Color', 'DisplayName', 'LineWidth', 'LineStyle', 'Marker', 'MarkerEdgeColor'};
         props = cat(2, props, {'MarkerFaceColor', 'MarkerSize', 'XData', 'YData', 'ZData'});
      end
      
      % specgraph.barseries properties
      if(strcmp(hgs.type, 'specgraph.barseries'))
         props = {'BarLayout', 'BarWidth', 'BaseValue', 'CDataMapping', 'DisplayName', 'EdgeAlpha', 'EdgeColor'};
         props = cat(2, props, {'FaceAlpha', 'FaceColor', 'Horizontal', 'LineWidth', 'LineStyle'});
         props = cat(2, props, {'XDataMode', 'XData', 'YData'});
      end
      
      % specgraph.baseline properties
      if(strcmp(hgs.type, 'specgraph.baseline'))
         props = {'BaseValue', 'Color', 'LineStyle', 'LineWidth', 'Visible'};
      end
      
      % specgraph.areaseries properties
      if(strcmp(hgs.type, 'specgraph.areaseries'))
         props = {'BaseValue', 'CDataMapping', 'DisplayName', 'EdgeAlpha', 'EdgeColor', 'FaceAlpha', 'FaceColor'};
         props = cat(2, props, {'LineWidth', 'LineStyle', 'XDataMode', 'XData', 'YData', 'YCoords'});
      end
      
      % patch properties
      if(strcmp(hgs.type, 'patch'))
         props = {'CDataMapping', 'DisplayName', 'EdgeColor', 'FaceColor', 'FaceAlpha', 'Faces', 'FaceVertexCData'};
         props = cat(2, props, {'LineStyle', 'LineWidth', 'UserData', 'Vertices'});
      end
      
      % histogram properties
      if(strcmp(hgs.type, 'histogram'))
         props = {'BinEdges', 'BinWidth', 'Data', 'DisplayName', 'DisplayStyle', 'EdgeColor', 'EdgeAlpha'};
         props = cat(2, props, {'FaceColor', 'FaceAlpha', 'LineWidth', 'LineStyle', 'Normalization', 'Orientation', 'Visible'});
      end
      
      % Imported properties of a Matlab "surface", "image" or "graph3d.surfaceplot" object. In a 2D graph container, the
      % first two objects will be converted to a FypML contour node in the heatmap display mode. In a 3D graph, the 
      % "graph3d.surfaceplot" is translated to a FypML 3D surface node, while a "surface" may be converted to a FypML
      % 3D scatter node in one of its bar plot display modes -- but only if that Matlab surface is configured to render 
      % 3D bars, as generated by the bar3() function. NOTE: Not all of these properties are applicable to the 
      % different use cases.
      if(strcmp(hgs.type, 'surface') || strcmp(hgs.type, 'image') || strcmp(hgs.type, 'graph3d.surfaceplot'))
         props = {'CData', 'CDataMapping', 'DisplayName', 'EdgeAlpha', 'EdgeColor', 'FaceAlpha', 'FaceColor'};
         props = cat(2, props, {'LineStyle', 'LineWidth', 'XData', 'YData', 'ZData'});
      end
      
      % specgraph.contourgroup properties
      if(strcmp(hgs.type, 'specgraph.contourgroup'))
         props = {'DisplayName', 'Fill', 'LevelList', 'LineColor', 'LineWidth', 'LineStyle', 'XData', 'YData', 'ZData'};
      end

      % line properties
      if(strcmp(hgs.type, 'line'))
         props = {'Color', 'DisplayName', 'LineStyle', 'LineWidth', 'Marker', 'MarkerEdgeColor'};
         props = cat(2, props, {'MarkerFaceColor', 'MarkerSize', 'XData', 'YData'});
      end
      
      % text properties
      if(strcmp(hgs.type, 'text'))
         props = {'Color', 'DisplayName', 'FontAngle', 'FontName', 'FontSize', 'FontUnits', 'FontWeight'};
         props = cat(2, props, {'HorizontalAlignment', 'Position', 'Rotation', 'String', 'Units', 'VerticalAlignment'});
      end
      
      
      for i=1:length(props)
         if(isfield(hgs.properties, props{i}))
            jObj.putProperty(props{i}, hgs.properties.(props{i}));
         elseif(ishandle(hgs.handle) && isprop(hgs.handle, props{i}))
            % try to get property value using get() function. As of Matlab2020a, most graphic properties that are
            % "on"/"off" are returned as the enumeration matlab.lang.OnOffSwitchState, which cannot be converted to
            % Java Object but is a logical value.
            propObj = get(hgs.handle, props{i});
            if(isjava(propObj))
               jObj.putProperty(props{i}, propObj);
            elseif(islogical(propObj))
               if(propObj == true)
                  jObj.putProperty(props{i}, 'on');
               else
                  jObj.putProperty(props{i}, 'off');
               end
            end
         end
      end
      
      % if a figure contains just one axes, 'Position' may not be specified. In this case, simply set this
      % property manually to [0.15 0.15 0.7 0.7] so that the axes fills up most of the figure
      if(strcmp(hgs.type, 'axes') && ~isfield(hgs.properties, 'Position'))
         jObj.putProperty('Position', [0.15 0.15 0.7 0.7]);
         jObj.putProperty('Units', 'normalized');
      end
      
      % special case: In Matlab 2014b and above, the 'Label' property of a 'scribe.colorbar' object is a Matlab
      % Text object T with the label string in T.String. Matlab objects CANNOT be converted to a Java counterpart, so
      % we add a fake property "Label_Str" to the HGObject representing the color bar. 
      if(strcmp(hgs.type, 'scribe.colorbar') && ~verLessThan('matlab', '8.4.0'))
         cbLabel = get(hgs.handle, 'Label');
         if(isobject(cbLabel))
            jObj.putProperty('Label_Str', cbLabel.String);
         end
      end
      
      % special case: In Matlab 2014b and above, the title and axis labels for an 'axes' object may be found in the
      % following properties of an 'axes': 'Title', 'XLabel', 'YLabel', and 'ZLabel'. Each of these is a Matlab Text 
      % object T with the label string in T.String. Matlab objects CANNOT be converted to a Java counterpart, so we add 
      % them as properties called 'XLabel_Str', and so on. 
      if(strcmp(hgs.type, 'axes') && ~verLessThan('matlab', '8.4.0'))
         mLabel = get(hgs.handle, 'XLabel');
         if(isobject(mLabel))
            jObj.putProperty('XLabel_Str', mLabel.String);
         end
         mLabel = get(hgs.handle, 'YLabel');
         if(isobject(mLabel))
            jObj.putProperty('YLabel_Str', mLabel.String);
         end
         mLabel = get(hgs.handle, 'ZLabel');
         if(isobject(mLabel))
            jObj.putProperty('ZLabel_Str', mLabel.String);
         end
         mLabel = get(hgs.handle, 'Title');
         if(isobject(mLabel))
            jObj.putProperty('Title_Str', mLabel.String);
         end
      end
      
      % special case: The 'polaraxes' object (first introduced in Matlab 2016a) uses a Matlab Text object for the 
      % plot's title. We extract the title string and color from this object and store them as fake properties.
      if(strcmp(hgs.type, 'matlab.graphics.axis.PolarAxes'))
         mLabel = get(hgs.handle, 'Title');
         if(isobject(mLabel))
            jObj.putProperty('Title_Str', mLabel.String);
            jObj.putProperty('Title_Color', mLabel.Color);
         end
      end
      
      % special case: For an 'axes', the handles of its associated 'scribe.legend' and 'scribe.colorbar' objects, if 
      % any, are buried in the property 'ApplicationData', in the fields 'LegendPeerHandle' and 'ColorbarPeerHandle',
      % respectively. If we find either field, we put it directly as a property of the HGObject representing the 'axes'.
      % This is what the Java function matFigToFyp() relies upon to find an axes object's legend and colorbar.
      % As of R2016a, these peer handles are stored in a double array 'ApplictionData.LayoutPeers', so we also check
      % for that field and store it directly as a property of the 'axes' object.
      if(strcmp(hgs.type, 'axes') && isfield(hgs.properties, 'ApplicationData'))
         if(isfield(hgs.properties.ApplicationData, 'LegendPeerHandle'))
            jObj.putProperty('LegendPeerHandle', hgs.properties.ApplicationData.LegendPeerHandle);
         end
         if(isfield(hgs.properties.ApplicationData, 'ColorbarPeerHandle'))
            jObj.putProperty('ColorbarPeerHandle', hgs.properties.ApplicationData.ColorbarPeerHandle);
         end
         if(isfield(hgs.properties.ApplicationData, 'LayoutPeers'))
            jObj.putProperty('LayoutPeers', hgs.properties.ApplicationData.LayoutPeers);
         end
      end
      
      % special case: For the 'polaraxes' object, the handles of any associated legend and colorbar objects are stored
      % instead in ApplicationData.LayoutPeers, a vector. If it's there, we store it directly as a property of the
      % HGObject representing the 'polaraxes'.
      if(strcmp(hgs.type, 'matlab.graphics.axis.PolarAxes') && isfield(hgs.properties, 'ApplicationData'))
         if(isfield(hgs.properties.ApplicationData, 'LayoutPeers'))
            jObj.putProperty('LayoutPeers', hgs.properties.ApplicationData.LayoutPeers);
         end
      end
      
      % special case: For selected plot objects, if the object is included in a 'scribe.legend' associated with the 
      % parent axes, then the plot object's 'ApplicationData' property will have a double-valued field called 
      % 'legend_texthandle' (undocumented feature). If we find this field, we put it directly as a property of the 
      % HGObject representing the plot object. The Java function matFigToFyp() may check this property when deciding
      % whether or not to include an entry for the object in the FypML graph's automated legend.
      isData = strcmp(hgs.type, 'graph2d.lineseries') || strcmp(hgs.type, 'specgraph.errorbarseries');
      isData = isData || strcmp(hgs.type, 'specgraph.scattergroup') || strcmp(hgs.type, 'patch');
      isData = isData || strcmp(hgs.type, 'specgraph.barseries') || strcmp(hgs.type, 'specgraph.areaseries');
      isData = isData || strcmp(hgs.type, 'specgraph.stairseries') || strcmp(hgs.type, 'specgraph.stemseries');
      isData = isData || strcmp(hgs.type, 'histogram');
      if(isfield(hgs.properties, 'ApplicationData') && isData)
         if(isfield(hgs.properties.ApplicationData, 'legend_texthandle'))
            jObj.putProperty('legend_texthandle', hgs.properties.ApplicationData.legend_texthandle);
         end
      end
   end
   %=== end of nested function processProperties(hgs, jObj) ===========================================================
   
   %=== [hgKids jKids] = addRelevantChildren(hgs, jObj) ===============================================================
   % Nested function adds relevant children of a Matlab Handle Graphics object to its Java HGObject counterpart. Only
   % those child objects that matter in the conversion of a Matlab to FypML figure are processed.
   %
   function [hgKids, jKids] = addRelevantChildren(hgs, jObj)
      
      if(strcmp(hgs.type, 'figure'))
         childTypes = {'axes', 'matlab.graphics.axis.PolarAxes', 'scribe.legend', 'scribe.colorbar'};
      elseif(strcmp(hgs.type, 'axes'))
         childTypes = {'graph2d.lineseries', 'specgraph.errorbarseries', 'specgraph.scattergroup', 'histogram'};
         childTypes = cat(2, childTypes, {'specgraph.barseries', 'specgraph.baseline', 'specgraph.areaseries'});
         childTypes = cat(2, childTypes, {'specgraph.stairseries', 'specgraph.stemseries', 'graph3d.surfaceplot'});
         childTypes = cat(2, childTypes, {'specgraph.contourgroup', 'patch', 'surface', 'image', 'line', 'text'});
         childTypes = cat(2, childTypes, {'bubblechart'});
      elseif(strcmp(hgs.type, 'matlab.graphics.axis.PolarAxes'))
         childTypes = {'graph2d.lineseries', 'histogram', 'specgraph.scattergroup', 'bubblechart', 'text'};
      elseif(strcmp(hgs.type, 'specgraph.barseries') || strcmp(hgs.type, 'specgraph.areaseries') || ...
               strcmp(hgs.type, 'specgraph.contourgroup'))
         childTypes = {'patch'};
      elseif(strcmp(hgs.type, 'scribe.colorbar'))
         childTypes = {'text'};
      else
         childTypes = {};
      end
      
      hgKids = [];
      jKids = [];
      if(isempty(childTypes))
         return;
      end
      
      for i=1:length(hgs.children)
         hgChild = hgs.children(i);
         
         relevant = false;
         for j=1:length(childTypes)
            if(strcmp(hgChild.type, childTypes{j}))
               relevant = true;
               break;
            end
         end
         if(~relevant)
            continue;
         end
         
         % create the Java object that will represent the Handle Graphics object
         % NOTE: For 'axes' (and 'scribe.colorbar', which is really a specialized 'axes'), the 'special' field holds the
         % Matlab indices of child text objects defining axes title and axis labels: [iTitle iXLabel iYLabel iZLabel]. 
         % We need these, but we cannot simply pass on the original indices to our Java representation of an 'axes' 
         % because we do not necessarily add all the children during this translation. Some objects are ignored, 
         % line-series objects may be coalesced into into a single multi-set, etc (see below). Therefore, we store the 
         % relevant child handles instead. If there is no label defined, the handle is set to 0.
         labelHandles = [0 0 0 0];
         if(strcmp(hgChild.type, 'axes') || strcmp(hgChild.type, 'scribe.colorbar'))
            if(isvector(hgChild.special) && isnumeric(hgChild.special) && (length(hgChild.special) == 4))
               for j=1:4
                  idx = hgChild.special(j);
                  if(idx > 0 && idx <= length(hgChild.children))
                     labelHandles(j) = hgChild.children(idx).handle;
                  end
               end
            end
         end
         jChild = com.srscicomp.fc.matlab.HGObject(hgChild.type, hgChild.handle, labelHandles);
         
         processProperties(hgChild, jChild);
         
         % special case: Put [bubblesize bubblelim] in 'UserData' field for every 'bubblechart' in an axes or polaraxes
         if(strcmp(hgChild.type, 'bubblechart') && (strcmp(hgs.type, 'axes') || ...
               strcmp(hgs.type, 'matlab.graphics.axis.PolarAxes')))
            set(fig.handle, 'currentaxes', hgs.handle);
            bubbleinfo = [bubblesize bubblelim];
            jChild.putProperty('UserData', bubbleinfo);
         end

         % add child object parent. Also add and its Matlab HG structure counterpart to the list of objects to be
         % added to the stack of objects to be processed (these could, in turn, have child objects)
         jObj.addChild(jChild);
         hgKids = cat(1, hgKids, hgChild);
         jKids = cat(1, jKids, jChild);
      end
      
   end
   %=== end of nested function addRelevantChildren(hgs, jObj) =========================================================
   
   
end
%=== end of primary function matfig2fyp(figHandle, dst) ===============================================================
