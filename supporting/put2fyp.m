function put2fyp(f, op, varargin)
%PUT2FYP Inject a data set, text content, or an entire graph into a Figure Composer FypML figure document.
% Figure Composer (FC) is a Java application for composing scientific figures suitable for journal publication. FypML is
% an informally specified XML dialect used to describe a figure in FC. For more information about FC and the FypML file 
% format, go to the Figure Composer online guide at:
%
%     https://sites.google.com/a/srscicomp.com/figure-composer
% 
% The primary motivation for PUT2FYP is to provide a convenient way to update an existing FypML figure with data, text,
% or an entire graph generated in Matlab script (or interactively in the Matlab command console) -- in a manner that
% eliminates -- or at least minimizes -- the amount of "tweaking" that must be done in Figure Composer itself to make
% the revised figure "look good". Since you will probably go through an analyze-examine-revise cycle many times as you 
% prepare figures for publication, PUT2FYP could be a helpful tool in your analysis workflow.
%
% PUT2FYP performs one of several disparate tasks depending on the value of the OP argument:
%
% PUT2FYP(F, 'data', ID, X, Y) replaces the data set object identified by the character-string ID in the FypML figure 
% document stored in the file F. The vector argument X contains the X-coordinates of the new data, while the vector or 
% matrix argument Y holds the Y coordinates. PUT2FYP handles the details of translating the (X,Y) data into one of 
% the FypML-supported data formats.
% 
% To the extent possible, PUT2FYP shields the Matlab user from the details of the FypML-specific data formats ("ptset", 
% "series", "mset", "mseries", "raster1d", "xyzimg", "xyzset"). Essentially, it examines the 2D data specified in the 
% arguments (X,Y) and converts that data to one of the FypML-supported formats. It checks the format of the data set
% being replaced (as identified by the ID argument) to guide this conversion process. Here are some examples to help
% explain how the conversion is handled:
%
% -- X and Y are both N-vectors, representing a data set with N (x,y) data points. In general, length(X) must equal the
%    the number of rows in Y, or the data cannot be converted. The one exception: X=[] -- see below.
% -- X is a Nx1 vector and Y is an NxM matrix with M > 1. In this case, it is assumed that each column in Y represents
%    a separate data set. Thus, Y holds a collection of M data sets, all sampled at the same x-coordinate values. This 
%    maps to the FypML "mset" data format.
% -- X=[], Y is an NxM matrix. Whenever X is an empty matrix, it is assumed that Y contains data sampled at regularly
%    spaced values of X, i.e., "series" data. If M=1,2 or 3, there's ambiguity about whether Y should be mapped to a
%    FypML "series" or "mseries" (a collection of "series"). In this case, the format of the data set being replaced
%    governs the choice made. Also the "x0" (first value of X) and "dx" (sample interval in X) parameters of the
%    replaced data series are preserved.
% -- When the data set being replaced in the figure backs a raster element ("raster1d" data format), then the supplied
%    data (X,Y) must be converted to that format. In this case, X is ignored, and all of the data is expected to be
%    contained in Y, in one of two forms:
%    (1) An NxM matrix. In this case, each column is interpreted as a separate raster over N time units. If R(n,m) is
%    nonzero, then an "event occurred" at time (n-1) in the m-th event train. 
%    (2) A 1XM or Mx1 cell array, where each cell R{m} contains a numeric vector V. In this case, each such vector is 
%    interpreted as a separate raster train, with the vector containing the "times" at which an event occurred in that
%    train.
% -- When the data set being replaced backs a heatmap element ("xyzimg" data format), then X is again ignored and Y is
%    expected to be an NxM matrix holding the heatmap values z(x,y) for x=[1..M] and y=[1..N]. The "xyzimg" parameters
%    X0,X1,Y0,Y1 -- defining the extent of the heatmap data along the X and Y axes -- are copied from the original set.
% -- When the data set being replaced is a 3D point set -- the "xyzset" format --, then X is again ignored and Y is
%    expected to be an Nx3 matrix where each of the N rows holds the (x,y,z) coordinates of a point in 3D space.
%
% PUT2FYP(F, 'note', S) changes the "note" property of the root FypML figure node. This property is for book-keeping
% purposes only; it is never rendered. It may be useful, for example, to distinguish among many very similar versions
% of the same figure that were generated by script. The argument S may be a character string or a cell array of strings.
% All line-feed (LF) characters in S are preserved. Tab characters are also preserved, so your note can contain
% tabulated information. If S is a cell array, the individual strings in the array are oncatenated into one long string 
% -- with intervening LF characters; thus, each cell in the array form of S represents a separate line of text in the 
% figure's description. If S is empty, the note is reset to an empty string.
%
% PUT2FYP(F, 'text' | 'title', ID, S) replaces the "title" property of any FypML graphic object that is identified by 
% the ID argument. Use this to change the text of a single-line label or multi-line text box, the title of a graph, or
% the title of a data presentation node (trace, raster, heatmap, bar plot, or scatter plot). In the case of a data
% presentation node, ID is the identifier of the node's source data set; otherwise, it is a unique object identifier 
% assigned to the label, textbox, or graph node. PUT2FYP only updates the identified object's title property, nothing
% else. The argument S may be a character string or a cell array of strings. If you need to specify a multi-line string
% (textbox nodes only), then S should be a cell array; each cell in the array represents a separate line of text. 
% Finally, if S is empty, the text content is reset to an empty string. (NOTE: It is possible for multiple data 
% presentation nodes to share the same data set. In this scenario, all such nodes will be updated with the same title.)
%
% PUT2FYP(F, 'legend', ID, POS, S) updates the legend label for the data group at index position POS in the bar plot,
% area chart, or pie chart identified by ID. Bar, area, and pie charts are all "grouped-data" presentation nodes, which
% have a legend entry for each individual data group/set in the chart. Here S is the replacement label. It must be a 
% character string. Any LF characters in S will be stripped out, since the legend label must be a single line. If S is 
% empty, the legend label is an empty string. (NOTE: It is important to remember that ID is NOT the data presentation
% node's ID, but rather the identifier of its source data set. In the unlikely case that the figure contains multiple 
% presentation nodes sharing the same data set, then all of them will be updated in the same manner.)
%
% PUT2FYP(F, 'graph', ID, H) replaces the FypML graph identified by ID with an 'axes' or 'polaraxes' object H within an 
% open Matlab figure (H is a handle referencing the 'axes' or 'polaraxes'; 'polaraxes' is a true Matlab polar plot,
% introduced in R2016). In many respects, this operation is similar to the utility MATFIG2FYP(), but instead of 
% converting an entire Matlab figure to FypML, it converts a single 'axes' within that figure to a FypML 2D graph, 2D
% polar graph, or 3D graph. The original and replacement graphs can be 2D or 3D, and they don't have to be the same
% type. In addition, in an attempt to preserve the overall appearance of the FypML figure in file F, the replacement
% graph inherits the location, dimensions, and styling of the original graph. Note that this does not work as well if
% the original graph is 2D and the replacement is 3D, or vice versa -- because 2D and 3D graphs are quite different in
% structure and how they are located and sized within the parent figure.
%
% PUT2FYP(F, 'figure', L) creates a new, empty FypML figure and saves it in the file F. L = [x y w h] is a vector of 
% length 4 indicating the location and size of the figure on the printed page, in inches. Note that (0,0) is at the 
% bottom-left corner of the printable rectangle on the page, inside the margins. File F must not exist initially.
%
% PUT2FYP(F, 'addgraph', H, L) converts an 'axes' or 'polaraxes' object in an open Matlab figure (identified by handle 
% H) to a FypML 2D or 3D graph, which is then ADDED to the FypML figure in file F. For a 2D graph or polar plot, the 
% vector L is a 4-element array [x y w h] indicating the location and size of the graph in inches; (x,y) are the 
% coordinates of the bottom-left corner of the graph's bounding box WRT the bottom-left corner of the figure. For a 3D 
% graph, L is a 5-element array [x, y, w, h, d]; here, (x,y) is the location of the origin of the 3D coordinate system 
% WRT the figure's viewport, and the remaining elements specify its width (along X axis), height (Y), and depth (Z) in 
% 3D space. In this case, the region occupied by the 3D graph in the figure will depend on its projection parameters. 
%
% The 'figure' and 'addgraph' operations were introduced to give you some control over the layout of multiple graphs in 
% a single figure. When using matfig2fyp() to directly import a Matlab figure containing many individual plots, the
% resulting FypML figure may look somewhat crowded. [The import engine relies on the Matlab figure's 'PaperPosition'
% and 'PaperUnits' properties to convert the normalized coordinates that are often used throughout the figure to specify
% the location and size of plots and other Handle Graphics objects. If you pack a lot of individual plots in one figure,
% they may look reasonably spaced in a large window on a large monitor, but they get squished together when scaled to 
% fit on an 8.5x11-in page.]
%
% Keep these considerations in mind when using 'addgraph': The location (x,y) and dimensions (w,h) of a FypML 2D graph 
% element define the bounding box of the graph's "data window" with respect to the parent figure. Normally, the graph's 
% axes are drawn outside this window. In the first-quadrant layout, you typically need to leave at least 0.5-in of space
% to the left and below the graph for the axes. You may need more or less depending on the specifics of the figure 
% you're constructing.
%
% In most of the use cases described above, if the FypML figure was successfully modified, PUT2FYP raises a Java dialog 
% in which the revised figure is previewed. After examining the results, you may choose to save the figure to file F, or
% cancel. Two optional arguments give you more control over this "confirm and save" phase (neither applies to the 
% 'figure' operation):
% 
% PUT2FYP(F, OP, ..., C) performs the specified operation, but the logical scalar C lets but lets you control whether
% or not the confirmation dialog is raised. If C==false and the figure modification succeeded, the updated figure is 
% saved to file without confirmation.
%
% PUT2FYP(F, OP, ..., C, F2), in addition to controlling the confirmation dialog, lets you specify an alternate
% destination file F2 for the updated figure -- so the original figure file F is unaffected.
%
%
% IMPORTANT NOTES AND USAGE INFO: 
% 1) PUT2FYP is an extension of an older Matlab utility, PUTDATA2FYP. In fact, PUT2FYP with OP='data' is the same as 
% calling PUTDATA2FYP. PUTDATA2FYP is maintained to avoid breaking Matlab scripts written before PUT2FYP was introduced.
% 2) To use PUT2FYP effectively, you must be aware of the character-string identifiers assigned to the data sets or
% graphic objects in your FypML figure. You can specify these in Figure Composer when you initially build that figure.
% 3) Understand the difference between a raw data set and a "data presentation node" in FC. There are several kinds of
% data presentation nodes in FC -- for example, XY data trace, raster, and contour node. Each is backed by a raw data 
% set, but it is the presentation node that determines how that data is rendered. PUT2FYP(F, 'data', ....) only changes
% the raw data set, not its presentation node "container".
% 4) On replacing a data set with an identical copy: When designing a script to inject one or more data sets into a
% figure or figures, it may be that you inject the same data set into a figure that was injected in a prior run. In this
% scenario, PUT2FYP() will not inject the copy since there is no change. If you specified an alternate destination file 
% F2, it will still save the "updated" figure to that file (effectively, a file copy from F to F2).
% 5) Object IDs for FypML label, textbox, and graph objects were introduced in FC v4.6.2, FypML schema version 18. In
% FC v4.7.0, the 'note' property was added to the figure node. Therefore, certain operations make no sense on older 
% FypML files with schema version 17 or less.
% 6) PUT2FYP relies on FC-specific JAVA code to do its work. The JAR files XPP3-1.1.3.4.D.JAR, ITEXTPDF-5.5.0.JAR,
% HHMI-MS-COMMON.JAR, and HHMI-MS-DATANAV.JAR must be on Matlab's Java classpath. You can call JAVACLASSPATH(P) on the 
% Matlab command line, where P is the full pathname to a required JAR. More conveniently, include JAVAADDPATH commands 
% for each JAR file in your STARTUP.M file. PUT2FYP will also invoke the M-function MATFIG2FYP for certain operations,
% so MATFIG2FYP must be on the Matlab command path.
% 7) If PUT2FYP fails for any reason, it exits with error(), which might wreak havoc if it occurs when the function
% is called from within another M-file.
% 8) On tabs, linefeeds, and other "special characters". For OP='note', 'text'|'title', and 'legend', the argument S
% is a string or cell array of strings. Matlab supports a subset of TeX characters, and PUT2FYP() can handle many of
% these -- providing a way to insert Greek letters and other symbols in your string. The characters are specified with
% a backslash followed by the character code name, e.g.: "\alpha to \omega". PUT2FYP translates such escaped sequences
% to the corresponding Unicode character (or a '?' if the TeX character is not supported in FypML). Furthermore, 
% PUT2FYP will translate '\t' to the Unicode tab character and '\n' to the linefeed character. However, ambiguity may
% arise, leading to unexpected results: '\nunder' == linefeed + "under" OR Greek nu character + "nder". Thus, it may be
% better to use sprintf(): [sprintf('\n') 'under'] instead of '\nunder'.
% 8a) The linefeed is allowed wherever a multi-line text string is permitted; the tab character is currently allowed 
% only in a figure note. These characters are silently removed whenever they are not allowed in a string argument.
%
% 
% Scott Ruffner
% sruffner@srscicomp.com
%

import com.srscicomp.fc.data.*;

% validate first 3 arguments: F, OP, ID. ID argument is not present for 'note', 'figure', and 'addgraph' ops. Note that 
% F should NOT exist for the 'figure' op.
nArgs = nargin;
if(nArgs < 3 || nArgs > 7) 
	error('Invalid number of arguments');
end;

ok = ischar(op) && (strcmpi(op, 'data') || strcmpi(op, 'text') || strcmpi(op,'title') || strcmpi(op, 'legend') || ...
      strcmpi(op, 'graph') || strcmpi(op, 'note') || strcmpi(op, 'figure') || strcmpi(op, 'addgraph'));
if(~ok)
   error('Invalid OP (arg 2)');
end;
isFigCreate = strcmpi(op, 'figure');

if(~ischar(f))
   error('F (arg 1) must be a string, the figure file pathname');
end;
jSrcFile = java.io.File(f);
if((~isFigCreate) && ~jSrcFile.isFile())
   error('Source FypML figure file does not exist.');
elseif(isFigCreate && jSrcFile.isFile())
   error('File F exists. The "figure" op does not overwrite an existing file.');
end;


id = '';
if(~(strcmpi(op, 'note') || strcmpi(op, 'addgraph') || isFigCreate))
   id = varargin{1};
   if(~ischar(id))
      error('ID (arg 3) must be a character string');
   end;
   if(nArgs < 4)
      error('Missing at least one argument');
   end;
end;

% validate additional arguments based on OP type
iVarArgC = 0;
iVarArgF2 = 0;
if(strcmpi(op, 'note'))
   strIn = varargin{1};
   ok = isempty(strIn) || ischar(strIn) || iscellstr(strIn);
   if(~ok)
      error('Figure note text (arg 3) must be a character string or a cell array of strings');
   end;
   
   if(nArgs > 3)
      iVarArgC = 2;
   end;
   if(nArgs > 4)
      iVarArgF2 = 3;
   end;
elseif(strcmpi(op, 'data'))
   if(nArgs < 5)
      error('Missing X and/or Y arguments defining data set');
   end;
   x = varargin{2};
   y = varargin{3};
   if(nArgs > 5)
      iVarArgC = 4;
   end;
   if(nArgs > 6)
      iVarArgF2 = 5;
   end;
   
   ok = isempty(x) || (isvector(x) && isnumeric(x));
   if(~ok)
      error('X (arg 4) must be a numeric vector, possibly empty');
   end;

   ok = isempty(y) || (iscell(y) && isvector(y)) || (ismatrix(y) && isnumeric(y));
   if(~ok)
      error('Y (arg 5) must be a numeric vector or matrix, or a cell vector');
   end;

   if((~isempty(x)) && ~iscell(y))
      if(length(x) ~= size(y,1))
         error('Length of vector X (arg 3) must match number rows in Y (arg 4)');
      end;
   end;
elseif(strcmpi(op, 'text') || strcmpi(op, 'title'))
   strIn = varargin{2};
   ok = isempty(strIn) || ischar(strIn) || iscellstr(strIn);
   if(~ok)
      error('S (arg 4) must be a character string or a cell array of strings');
   end;
   
   if(nArgs > 4)
      iVarArgC = 3;
   end;
   if(nArgs > 5)
      iVarArgF2 = 4;
   end;
elseif(strcmpi(op, 'legend'))
   if(nArgs < 5)
      error('Missing at least one argument.');
   end;
   grpPos = varargin{2};
   ok = isscalar(grpPos) && isnumeric(grpPos);
   if(~ok)
      error('POS (arg 4) must be a scalar. Should be the integer index position of target data group.');
   end;
   strIn = varargin{3};
   ok = isempty(strIn) || ischar(strIn);
   if(~ok)
      error('S (arg 5) must be a character string');
   end;
   
   if(nArgs > 5)
      iVarArgC = 4;
   end;
   if(nArgs > 6)
      iVarArgF2 = 5;
   end;
elseif(isFigCreate)
   loc = [0 0 8.5 11];
   if(nArgs >= 3)
      loc = varargin{1}; 
   end;
   ok = isvector(loc) && isnumeric(loc) && (length(loc) == 4);
   if(~ok)
      error('L (arg 3) must be a numeric vector of length 4: [x y w h]');
   end;
elseif(strcmpi(op, 'addgraph'))
   if(nArgs < 4)
      error('Missing at least one argument.');
   end;
   axesH = varargin{1};
   ok = ishandle(axesH);
   if(ok)
      ok = (strcmpi('axes', get(axesH, 'type')) || strcmpi('polaraxes', get(axesH, 'type')));
   end;
   if(~ok)
      error('H (arg 3) must be a handle to a valid Matlab axes or polaraxes object');
   end;
   loc = varargin{2};
   ok = isvector(loc) && isnumeric(loc) && (length(loc) == 4 || length(loc) == 5);
   if(~ok)
      error('L (arg 4) must be a numeric vector of length 4 for a 2D graph, or 5 for a 3D graph');
   end;
   
   if(nArgs > 4)
      iVarArgC = 3;
   end;
   if(nArgs > 5)
      iVarArgF2 = 4;
   end;
else
   axesH = varargin{2};
   ok = ishandle(axesH);
   if(ok)
      ok = (strcmpi('axes', get(axesH, 'type')) || strcmpi('polaraxes', get(axesH, 'type')));
   end;
   if(~ok)
      error('H (arg 4) must be a handle to a valid Matlab axes or polaraxes object');
   end;
   
   if(nArgs > 4)
      iVarArgC = 3;
   end;
   if(nArgs > 5)
      iVarArgF2 = 4;
   end;
end;

% check additional optional arguments common to all OP types (except 'figure'): C, F2
confirm = true;
if(iVarArgC > 0)
   confirm = varargin{iVarArgC};
   if(~(isscalar(confirm) && islogical(confirm)))
      error('Confirm arg C invalid -- must be a logical scalar');
   end;
end;

jDstFile = jSrcFile;
altDst = false;
if(iVarArgF2 > 0)
   dst = varargin{iVarArgF2};
   if(~ischar(dst))
      error('Alternate destination file pathname is not a character string');
   end;

   % make sure filename ends in '.fyp'. Tack it on otherwise.
   jDst = java.lang.String(dst);
   if(jDst.length() < 4) 
      jDst = java.lang.String([dst '.fyp']);
   else
      jExt = jDst.substring(jDst.length()-4);
      if(~jExt.equalsIgnoreCase('.fyp'))
         jDst = java.lang.String([dst '.fyp']);
      end;
   end;

   jDstFile = java.io.File(jDst);
   if(~isjava(jDstFile.getParentFile()) || ~jDstFile.getParentFile().isDirectory())
      error('Alternate destination FypML file path is not valid.');
   end;
   altDst = true;
end;

% handle the 'figure' op. Unlike other ops, it neither opens an existing FypML file nor displays a confirmation dialog.
if(isFigCreate)
   jFig = javaMethod('createEmptyFigure', 'com.srscicomp.fc.fig.FGraphicModel', loc);
   if(~isjava(jFig) || isempty(jFig))
      error('Unable to create new figure -- invalid location or dimensions?');
   else
      emsg = javaMethod('toXML', 'com.srscicomp.fc.fig.FGModelSchemaConverter', jFig, jDstFile);
      if(ischar(emsg))
         error(['Error saving FypML figure to file: ', char(emsg)]);
      end;
   end;
   return;
end;

% read in existing figure file
ebuf = java.lang.StringBuffer();
jFig = javaMethod('fromXML', 'com.srscicomp.fc.fig.FGModelSchemaConverter', jSrcFile, ebuf);
if(~isjava(jFig) || isempty(jFig))
   msg = strcat('Unable to read source FypML file: ', char(ebuf.toString()));
   error(msg);
end;

% update existing figure IAW the specified OP type
identical = false;
if(strcmpi(op, 'note'))
   ok = javaMethod('replaceFigureNote', 'com.srscicomp.fc.matlab.MatlabUtilities', jFig, strIn);
   if(~ok)
      error('Unable to update figure note');
   end;
elseif(strcmpi(op, 'data'))
   % retrieve the data set that is being replaced
   jOldDS = jFig.getDataset(id);
   if(~isjava(jOldDS) || isempty(jOldDS))
      error('ID (arg 2) does not identify an existing data set in source figure');
   end;
   
   % prepare the replacement data set, then inject it into the source figure
   jNewDS = prepareDataSet(x, y, jOldDS);
   if(~isjava(jNewDS) || isempty(jNewDS))
      error('Unable to generate replacement data set from X,Y args; not compatible with set identified by ID?');
   end;
   
   % inject the replacement data set into the source figure. IF the replacement set is identical to the original, no
   % action is taken. In this scenario, the figure is saved to file ONLY if an alternate destination file was specified.
   identical = jNewDS.equals(jOldDS);
   if(~identical)
      ok = jFig.replaceDataSetInUse(jNewDS);
      if(~ok)
         error('Unable to inject new data into source figure');
      end;
   end;
elseif(strcmpi(op, 'text') || strcmpi(op, 'title'))
   ok = javaMethod('replaceTitle', 'com.srscicomp.fc.matlab.MatlabUtilities', jFig, id, strIn);
   if(~ok)
      error(['Unable to replace title or text content of object with ID = ' id]);
   end;
elseif(strcmpi(op, 'legend'))
   ok = javaMethod('replaceDataGroupLegendLabel', 'com.srscicomp.fc.matlab.MatlabUtilities', ...
         jFig, id, uint32(grpPos), strIn);
   if(~ok)
      error(['Unable to replace data group legend label for bar/area/pie chart with ID = ' id]);
   end;
else
   % 'graph' or 'addgraph': convert specified axes object to a FypML graph, then inject it into the figure -- either 
   % replacing an existing graph or adding it as a new one
   jGraph = matfig2fyp(axesH);
   if(~isjava(jGraph) || isempty(jGraph))
      error('Unable to convert axes or polaraxes object to a FypML 2D or 3D graph element');
   end;
   if(strcmpi(op, 'graph'))
      ok = jFig.replaceGraphInFigure(id, jGraph);
      if(~ok)
         error(['Unable to replace graph with ID = ' id]);
      end;
   else
      ok = jFig.addGraphToFigure(jGraph, loc);
      if(~ok)
         error('Unable to add graph to figure.');
      end;
   end;
end;

% raise confirmation dialog, unless user chose not to.
ok = true;
if(confirm)
   ok = javaMethodEDT('raiseConfirmSaveDialog', 'com.srscicomp.fc.matlab.DNFigureSaveDlg', jFig, jDstFile);
end;

% if confirmed, save the converted figure to file. Don't save if replacement set was identical to original, unless
% we're saving the figure to an alternate destination.
if(ok && (altDst || ~identical))
   emsg = javaMethod('toXML', 'com.srscicomp.fc.fig.FGModelSchemaConverter', jFig, jDstFile);
   if(ischar(emsg))
      error(['Error saving FypML figure to file: ', char(emsg)]);
   end;
end;


   %=== prepareDataSet(x, y, jOld) ====================================================================================
   % Nested function handles the details of converting Matlab 2D data (X,Y) into a FypML data set that can replace the
   % specified FypML data set object, jOld. If successful, it returns the replacement data set -- an instance of the
   % Java class com.srscicomp.fc.data.DataSet; otherwise, it returns an empty matrix.
   %
   function jRes = prepareDataSet(x, y, jOld)
      import com.srscicomp.fc.data.DataSet;

      jRes = [];

      % the data format codes
      PTSET=0; MSET=1; SERIES=2; MSERIES=3; RASTER1D=4; XYZIMG=5; XYZSET=6;

      % the format of the data set being replaced guides our conversion of X,Y into a FypML-supported data format
      fmt = jOld.getFormat().getIntCode();

      % raster1d -- X ignored, Y must be an NxM matrix or a cell vector
      if(fmt == RASTER1D)
         % rasterdata = [];
         if(ismatrix(y) && isnumeric(y))
            ncols = size(y,2);
            nrows = 0;
            for i=1:ncols
               nrows = nrows + length(find(y(:, i) ~= 0));
            end;
            rasterdata = zeros(1, ncols + nrows);

            start = ncols + 1;
            for i=1:ncols
               train = find(y(:,i) ~= 0)';
               n = length(train);
               rasterdata(i) = n;
               if(n > 0)
                  rasterdata(start:start+n-1) = train;
                  start = start + n;
               end;
            end;
         elseif(iscell(y) && (isempty(y) || isvector(y)))
            ncols = length(y);
            nrows = 0;
            for i=1:ncols
               train = y{i};
               if(~(isempty(train) || (isnumeric(train) && isvector(train))))
                  return;
               end;
               nrows = nrows + length(train);
            end;
            rasterdata = zeros(1, ncols + nrows);

            start = ncols + 1;
            for i=1:ncols 
               train = y{i};
               if(size(train,1) > size(train,2))
                  train = train';
               end;
               n = length(train);
               rasterdata(i) = n;
               if(n > 0)
                  rasterdata(start:start+n-1) = train;
                  start = start + n;
               end;
            end;
         else
            % bad Y argument. Fail.
            return;
         end;

         if(isempty(rasterdata))
            % special case: an empty raster set
            jRes = DataSet.createEmptySet(jOld.getFormat(), jOld.getID());
         else
            jRes = DataSet.createDataSet(jOld.getID(), RASTER1D, [], nrows, ncols, rasterdata);
         end;

         return;
      end;

      % xyzimg -- X ignored, Y must be an NxM matrix. We adopt the params of the data set being replaced. Empty case
      % is handled specially because Matlab maps [] to null, in which case createDataSet() fails...
      if(fmt == XYZIMG && ismatrix(y) && isnumeric(y))
         if(isempty(y))
            jRes = DataSet.createEmptySet(jOld.getFormat(), jOld.getID());
         else
            [nrows, ncols] = size(y);
            jRes = DataSet.createDataSet(jOld.getID(),XYZIMG,jOld.getParams(), nrows,ncols, reshape(y',nrows*ncols,1));
         end;
         return;
      end;
      
      % XYZSET -- X ignored, Y must be an Nx3 matrix holding (x,y,z) coordinates of N points in 3D space. If Y does not
      % have exactly 3 columns, then operation fails.
      if(fmt == XYZSET && ismatrix(y) && isnumeric(y))
         if(isempty(y))
            jRes = DataSet.createEmptySet(jOld.getFormat(), jOld.getID());
         else
            [nrows, ncols] = size(y);
            if(ncols == 3)
               jRes = DataSet.createDataSet(jOld.getID(),XYZSET,[], nrows,ncols, reshape(y',nrows*ncols,1));
            end;
         end;
         return;
      end;
      
      % the remaining formats are all compatible
      if(fmt == PTSET || fmt == MSET || fmt == SERIES || fmt == MSERIES)
         if(~(ismatrix(y) && isnumeric(y) && (isempty(x) || (length(x) == size(y,1)))))
            return;
         end;
      
         % handle special case: empty set
         if(isempty(y))
            jRes = DataSet.createEmptySet(jOld.getFormat(), jOld.getID());
            return;
         end;

         % first, decide whether we'll use a series-type format. If so, determine params = [dx x0]
         params = [];
         isSeries = false;
         if(isempty(x))
            % in this case, new data set must be series-type. If the old set was a series, we use its [dx, x0]; else,
            % we assume dx = 1, x0 = 0.
            isSeries = true;
            if(fmt == SERIES || fmt == MSERIES)
               params = jOld.getParams();
            else
               params = [1 0];
            end;
         elseif(length(x) > 2)
            % since X vector is specified, we can scan it to see if contains regularly spaced values. Since we're doing
            % floating-pt comparison in this test, we introduce a tolerance of 0.0001. If X passes the test, we can
            % compute values for dx and x0 and use a series-type format.
            x0 = x(1);
            dx = x(2) - x(1);
            
            isSeries = true;
            for i=2:length(x)
               xTest = x0 + dx * (i-1);
               if(abs(xTest-x(i)) > 0.0001)
                  isSeries = false;
                  break;
               end;
            end;

            if(isSeries)
               params = [dx x0];
            end;
         end;

         if(isSeries)
            % for series data, everything is in the Y argument. If the number of columns in Y is in [1..3], then the
            % target format could be SERIES or MSERIES. In that case, if the old set was a series-type, we use its 
            % format; else we assume SERIES.
            [nrows, ncols] = size(y);
            if(ncols >= 1 && ncols <= 3)
               if(~(fmt == SERIES || fmt == MSERIES))
                  fmt = SERIES;
               end;
            else
               fmt = MSERIES;
            end;

            jRes = DataSet.createDataSet(jOld.getID(), fmt, params, nrows, ncols, reshape(y',nrows*ncols,1));
         else
            % for non-series data, we need to incorporate the X vector in the raw data array. If the number of columns
            % in [x, y] is in [2..6], then the target format could be PTSET or MSET. In that case, if the old set was 
            % one of these two formats, we leave the format unchanged; else, we assume PTSET.
            raw = [x, y];
            [nrows, ncols] = size(raw);
            if(ncols >= 2 && ncols <= 6)
               if(~(fmt == PTSET || fmt == MSET))
                  fmt = PTSET;
               end;
            else
               fmt = MSET;
            end;

            jRes = DataSet.createDataSet(jOld.getID(), fmt, [], nrows, ncols, reshape(raw', nrows*ncols, 1));
         end;
      end;
   end
   %=== end of nested function prepareDataSet(x, y, jOld) =============================================================
   

end
%=== end of primary function put2fyp(f,op,id,...) =====================================================================
