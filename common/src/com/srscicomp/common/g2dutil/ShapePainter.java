package com.srscicomp.common.g2dutil;

import java.awt.Graphics2D;
import java.awt.Shape;
import java.awt.font.TextAttribute;
import java.awt.font.TextLayout;
import java.awt.geom.AffineTransform;
import java.awt.geom.GeneralPath;
import java.awt.geom.PathIterator;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.text.AttributedCharacterIterator;
import java.text.AttributedString;
import java.util.Iterator;
import java.util.StringTokenizer;

import com.srscicomp.common.ui.BkgFill;
import com.srscicomp.common.util.Utilities;


/**
 * <b>ShapePainter</b> paints a scalable shape primitive at one or more locations, with an optional text label. 
 * Possible uses include the rendering of multiple marker symbols, flowchart shapes, etc.
 * 
 * <p>To support scalability, the {@link PaintableShape} supplied to the shape painter is typically specified in a unit 
 * design box, with the origin at the <i>center</i> of the box. When rendered, the defined shape is scaled IAW a 
 * specified width and height, and the resulting scaled shape is drawn such that the design origin is coincident with 
 * the target location. The optional text label is centered both horizontally and vertically about the target location; 
 * thus, if the shape is centered about its design origin, the label should appear centered WRT the shape. Both the 
 * shape and its accompanying label may also be rotated about the target location. In addition, a "rotation angle" 
 * producer may be specified, in which case each shape is rotated about the target location IAW the angle provided by 
 * this producer.</p>
 * 
 * <p>As specified in the {@link Painter} contract, <b>ShapePainter</b> assumes that it renders itself into a logical 
 * coordinate system that is right-handed. It therefore always inverts the y-axis of its current graphic context prior 
 * to rendering the text label -- because text-rendering routines in Java2D assume a left-handed coordinate system. This
 * is done regardless of the painter's specified rotation angle.
 * 
 * <p>The appearance of the shape is governed by the painter's {@link PainterStyle}. The stroke characteristics and font
 * size are NOT scaled with the shape's dimensions, however. The shape outline is stroked IAW the painter's stroke 
 * styling. If the shape is filled, there are two alternatives:
 * <ul>
 * <li>A background fill is specified. The background fill may be a solid color (including a transparent color, which is
 * the same as not filling it at all), an axial gradient, or a radial gradient. The gradient fills, by convention, span
 * the bounding box of the shape in one cycle, but only the inside of the shape (a closed shape, that is) is painted.
 * In this case, the text label is drawn using the painter's text/fill color.</li>
 * <li>No background fill is specified. In this case, the shape is filled with the painter's text/fill color, and the
 * text label, if any, is drawn using the stroke color. This is how <b>ShapePainter</b> worked prior to the introduction
 * of the gradient fill options via {@link BkgFill}.</li>
 * </ul>
 * 
 * <p>If any location generated by the painter's "location producer" is ill-defined (either it is a null value, or at 
 * least one coordinate is NaN or infinite), <b>ShapePainter</b> will simply ignore that location during rendering.</p>
 * 
 * <p><b>ShapePainter</b> supports canceling an ongoing paint operation; it will check for cancellation of the
 * rendering task after painting every 50 locations, or every 200 locations if there is no text label to draw.</p>
 * 
 * @author sruffner
 */
public class ShapePainter extends Painter
{
   /**
    * Creates a custom shape defined by a series of "moveto" and "lineto" commands in a text string having the 
    * (required) format: "M x0 y0 {M/L} x1 y1 ... {M/L} xN yN [Z]", where "M" = "moveto", "L" = "lineto", and (xi,yi) 
    * are the coordinates of the point to moveto or lineto, in logical units. Note that whitespace is the token 
    * separator in this definition string, that the string MUST start with "M", and that all coordinates must be 
    * parsable as numbers. An optional "Z" at the end will close the path by drawing a line to the first point.
    * 
    * @param defn String defining shape as a series of line segments, in the format described.
    * @return The <code>Shape</code> defined by the supplied path string. If the path string cannot be properly parsed 
    * for whatever reason, or if it makes no marks (no linetos), the method returns <code>null</code>.
    */
   public static Shape parseShape(String defn)
   {
      Shape shape = null;
      // parse definition string, constructing the GeneralPath that implements the shape
      try
      {
         GeneralPath p = new GeneralPath();
         StringTokenizer tokenizer = new StringTokenizer(defn.toUpperCase());
         boolean gotFirstMoveto = false;
         int nLineTos = 0;
         Point2D currentPt = new Point2D.Double();
         p.moveTo(0,0);
         while(tokenizer.hasMoreTokens())
         {
            String token = tokenizer.nextToken();
            //noinspection IfCanBeSwitch
            if(token.equals("M"))
            {
               // the next two tokens must be numbers, representing the coordinate of the point to move to.
               double x = Double.parseDouble(tokenizer.nextToken());
               double y = Double.parseDouble(tokenizer.nextToken());

               // always move to the first point in the path. We ignore any subsequent moveto if the new location is the
               // same as the current point.
               if((!gotFirstMoveto) || (x != currentPt.getX()) || (y != currentPt.getY()))
               {
                  currentPt.setLocation(x, y);
                  p.moveTo((float)x, (float)y);
                  gotFirstMoveto = true;
               }
            }
            else if(token.equals("L"))
            {
               if(!gotFirstMoveto)
                  throw new Exception("Shape path must start with M!");

               // the next two tokens must be numbers, representing the coordinate of the point to move to.
               double x = Double.parseDouble(tokenizer.nextToken());
               double y = Double.parseDouble(tokenizer.nextToken());

               // ignore if specified point is same as current point!
               if((x != currentPt.getX()) || (y != currentPt.getY()))
               {
                  currentPt.setLocation(x, y);
                  p.lineTo((float)x, (float)y);
                  ++nLineTos;
               }
            }
            else if(token.equals("Z"))
            {
               if(!gotFirstMoveto)
                  throw new Exception("Shape path must start with M!");
               if(nLineTos > 0)
                  p.closePath();
               break;
            }
            else
               throw new Exception("Unrecognized token in shape path");
         }

         if(nLineTos > 0)
         {
            shape = p;
         }
      }
      catch(Exception ignored) {}

      return(shape);
   }

   /** The shape rendered by this shape painter. */
   private PaintableShape paintedShape = null;

   /** The default shape, if no shape has been specified. It is a unit-radius circle. */
   private final static PaintableShape DEFAULTSHAPE = new BasicPaintableShape();

   /**
    * Set the shape rendered by this shape painter.
    * 
    * <p>If the shape is to be scalable, it should be designed within a unit (1x1) design box, with the origin at the 
    * center of the box. If the shape need not be rescaled, it can be specified at its final size in logical units, and 
    * the shape origin can be anywhere (but, of course, this location will determine where the shape is positioned at 
    * rendering time). Also, if the shape will not be rescaled, the width and height of this shape painter should be 
    * set to 1 using {@link #setSize(float)}.</p
    * 
    * <p>This method sets the "shape fill" flag if the shape is closed, otherwise it clears the flag. Thus, a closed 
    * shape will be both filled and stroked, while an unclosed shape is only stroked. To override this behavior, call 
    * {@link #setFilled(boolean)} <i>after</i> setting the shape.</p>
    * 
    * @param s The desired shape, as described.  If null, a unit circle is assumed.
    */
   public void setPaintedShape(PaintableShape s)
   {
      this.paintedShape = (s==null) ? DEFAULTSHAPE : s;
      filled = paintedShape.isClosed();
      updateScaledShape();
   }

   /** 
    * Rendered width of shape, in logical coordinates. The design shape will be scaled by this value horizontally. If
    * negative or zero, the shape will not be drawn.
    */
   private float width = 1.0f;
   
   /** 
    * Rendered height of shape, in logical coordinates. The design shape will be scaled by this value vertically. If
    * negative or zero, the shape will not be drawn.
    */
   private float height = 1.0f;

   /**
    * Change the width and height of the shape rendered by this shape painter.
    * 
    * @param size Desired size in logical units. Both width and height ar set to this value. Range restricted to 
    * non-negative values.
    */
   public void setSize(float size)
   {
      float sq = Math.max(size, 0f);
      this.width = sq;
      this.height = sq;
      updateScaledShape();
   }

   /**
    * Change the dimensions of the shape rendered by this shape painter.
    * 
    * @param w Desired width in logical units. Range-restricted to non-negative values.
    * @param h Desired height in logical units. Range-restricted to non-negative values.
    */
   public void setSize(float w, float h)
   {
      this.width = Math.max(w, 0f);
      this.height = Math.max(h, 0f);
      updateScaledShape();
   }
   
   /** 
    * An attributed string defining the label centered horizontally and vertically in the shape's bounding box. If null
    * or empty, no label is drawn.
    */
   private AttributedString attrLabel = null;

   /** Flag set to indicate that original text source for shape's label was an unattributed string. */
   private boolean isPlainText = false;
   
   /**
    * Set the text label that is centered horizontally and vertically about each location at which a shape is drawn by 
    * this painter.
    * @param aStr The label's text, in the form of an attributed string. If null, no label is drawn.
    */
   public void setTextLabel(AttributedString aStr)
   {
      attrLabel = aStr;
      isPlainText = false;
   }
   
   /**
    * Set the text label that is centered horizontally and vertically about each location at which a shape is drawn by 
    * this painter.
    * @param s The label's text. If null or empty, no label is drawn.
    */
   public void setTextLabel(String s)
   {
      attrLabel = (s==null || s.isEmpty()) ? null : new AttributedString(s);
      isPlainText = true;
   }

   /**
    * If this flag is set, the scaled shape is filled then stroked; otherwise, it is only stroked. Typically, the flag 
    * would not be set for an unclosed shape.
    */
   private boolean filled = false;

   /**
    * Set the "shape fill" flag. If set, the scaled shape is filled then stroked by this shape painter; otherwise it is 
    * only stroked. Typically, the flag is set for closed shapes and cleared for open ones.
    * 
    * @param filled True if the shape painter should fill its shape.
    */
   public void setFilled(boolean filled)
   {
      this.filled = filled;
   }

   /** 
    * Shape's background fill. Supports gradient as well as solid-color fill. If null, then painter's text/fill color
    * is used to fill shape, and its stroke color is used to draw the text label.
    */
   private BkgFill bkgFill = null;
   
   /**
    * Set the shape painter's background fill, which supports axial and radial gradients as well as solid-color fills.
    * When a background fill is defined, that fill is used to paint the interior of the shape, while the painter's 
    * text/fill color is used to draw the text label. When the background fill is NOT defined (null), the interior of
    * the shape is filled with the text/fill color, and the text label (if any) is drawn in the painter's stroke color.
    * @param bf The background fill. Set to null to remove a previously defined background fill descriptor.
    */
   public void setBackgroundFill(BkgFill bf)
   {
      this.bkgFill = bf;
   }
   
   /**
    * Angle by which the scaled shape, and the accompanying text label, are rotated about the target location. Default 
    * is zero deg.
    */
   private double rotation = 0;

   /**
    * Set the angle by which scaled shape is rotated about the target location. If a valid rotation angle producer has 
    * been specified by a call to {@link #setRotationProducer(Iterable)}, then this method has no effect.
    * @param rotation Rotation angle in degrees.
    */
   public void setRotation(double rotation) { this.rotation = rotation; }

   /** Provides angle by which scaled shape is rotated about the target location. May be null. */
   private Iterable<Float> rotationProducer = null;
   
   /**
    * Set the rotation angle producer for this shape painter.
    * 
    * <p>During rendering, this should provide a rotation angle (in deg) for each target location generated by the 
    * painter's location producer -- thus allowing each shape to be rotated differently. If the rotation producer 
    * generates fewer instances than the location producer, the remaining shapes are not rotated; if it generates more,
    * the additional rotation angles are simply ignored.</p>
    * 
    * <p>If the rendered shapes are all rotated by the same angle or not at all, the rotation producer should be set to 
    * null (the default); call {@link #setRotation(double)} instead.</p>
    * 
    * @param rotationProducer The rotation angle producer, as described. Set to null if all rendered shapes are rotated
    * by the same angle or not at all.
    */
   public void setRotationProducer(Iterable<Float> rotationProducer) {this.rotationProducer = rotationProducer; }
   
   /** Angle by which shape's accompanying text label, if any, is rotated WRT the shape itself. Default is 0 degrees. */
   private double labelRotation = 0;

   /**
    * Set angle by which text label is rotated (about the target location) WRT the shape itself.
    * <p>Normally, the accompanying text label appears at the same orientation as the scaled shape itself. To change 
    * this default behavior, use this method to rotate the text label WRT the shape.</p>
    * @param labelRotation Orientation of text label WRT the scaled shape, a rotation angle in degrees.
    */
   public void setLabelRotation(double labelRotation) { this.labelRotation = labelRotation; }

   /**
    * Construct a shape painter initialized to draw a single circle with a diameter = 10 logical units. The location 
    * producer is initially unspecified, so the constructed painter will not actually render anything. Default paint 
    * attributes are applied. No background fill defined, so shape is filled with solid color - the text/fill color.
    */
   public ShapePainter()
   {
      this(null, null, null, 10f, null);
   }

   /**
    * Construct a shape painter to render the specified shape. No background fill defined, so shape is filled with solid
    * color - the text/fill color defined in the painter's style attributes.
    * 
    * @param style Collection of graphic attributes applied to this painter. If null, default values are used.
    * @param producer The location producer for this painter. If null, then the painter renders nothing.
    * @param s The shape to be rendered. If null, a unit circle is assumed. This  object provides shape info including 
    * the actual {@link Shape} primitive, which is typically designed in a 1x1 box with origin at the box center. If the
    * shape is closed, the "shape fill" flag is set; otherwise, the flag is cleared. Thus, closed shapes are typically 
    * filled and stroked, while open shapes are only stroked. Use {@link #setFilled(boolean)} to override this behavior.
    * @param size Desired size of shape when rendered, in logical units. Both width and height are set to this value.
    * Range-restricted to non-negative values. If zero, the shape will not be rendered (but the text label would be 
    * rendered, if there is one).
    * @param label The text of a label to be rendered on top of the shape at each location specified. If this string 
    * is null or empty, no label is drawn. The text is NOT clipped to the shape bounds.
    */
   public ShapePainter(PainterStyle style, Iterable<Point2D> producer, PaintableShape s, float size, String label)
   {
      super(style, producer);
      setPaintedShape(s);
      float sq = Math.max(size, 0f);
      this.width = sq;
      this.height = sq;
      this.attrLabel = (label==null || label.isEmpty()) ? null : new AttributedString(label);
      this.isPlainText = true;
      this.bkgFill = null;
      updateScaledShape();
   }

   //
   // Painting the shape
   //

   /** 
    * As currently configured, does this painter render anything?
    * @return True if painter has a valid location producer and either a shape is drawn or the shape's label is drawn.
    */
   boolean isRendered()
   {
      boolean doLabel = isLabelRendered();
      boolean doShape = (width > 0f) && (height > 0f) && (shouldFill() || style.isStroked());
      return(locationProducer != null && (doShape || doLabel));
   }
   
   /** 
    * Does this shape painter render a centered label? The label must contain at least one character, and the text
    * color must not be fully transparent.
    */
   private boolean isLabelRendered()
   {
      boolean doLabel = (attrLabel != null);
      if(doLabel)
      {
         AttributedCharacterIterator aci = attrLabel.getIterator();
         doLabel = (aci.getEndIndex() - aci.getBeginIndex() > 0);
         if(doLabel)
            doLabel = ((bkgFill == null) ? style.getStrokeColor() : style.getFillColor()).getAlpha() != 0;
      }
      return(doLabel);
   }
   
   /**
    * The shape is filled if the filled flag is set and then fill style is not transparent. Note that whether or not
    * the shape is closed is not a consideration; filling an open shape is allowed (but results may be unpredictable!).
    * @return True if painter should fill the shape.
    */
   private boolean shouldFill()
   {
      return(filled && (bkgFill != null ? !bkgFill.isTransparent() : style.getFillColor().getAlpha() != 0));
   }
   
   /**
    * Interval at which <code>ShapePainter</code> updates progress and checks for cancellation when the shape includes 
    * a text label, in #locations actually painted.
    */
   private final static int PROGRESSINTV = 50;

   /**
    * Interval at which <code>ShapePainter</code> updates progress and checks for cancellation when the shape has no 
    * text label, in #locations actually painted.
    */
   private final static int PROGRESSINTV_NOLABEL = 200;

   @Override
   protected boolean paintInternal(Graphics2D g2d)
   {
      // check for obvious cases in which nothing is rendered
      boolean doLabel = isLabelRendered();
      boolean doFill = shouldFill();
      boolean doShape = (width > 0f) && (height > 0f) && (doFill || style.isStroked());
      if(locationProducer == null || !(doShape || doLabel))
         return(true);

      g2d.setStroke(style.getStroke(0));
      g2d.setFont(style.getFont());

      // if label is drawn, get string bounding box and use it to determine the offset from each shape's center pt to 
      // the label's starting point. Since text must be drawn in a left-handed coord system (x-axis increasing to right, 
      // y-axis increasing downward), we compute offsets that are consistent with such a coord system.
      float fLblOffsetX = 0f;
      float fLblOffsetY = 0f;
      if(doLabel)
      {
         if(isPlainText) attrLabel.addAttribute(TextAttribute.FONT, style.getFont());
         TextLayout layout = new TextLayout(attrLabel.getIterator(), fontRC);
         Rectangle2D textBounds = layout.getBounds();
         fLblOffsetX = (float) (-textBounds.getX() - textBounds.getWidth()/2.0);
         fLblOffsetY = (float) -(textBounds.getY() + textBounds.getHeight()/2.0);
      }

      // get shape and text rotation angles in radians (shape rotation angle ignored if there's an angle producer)
      double rot = Math.toRadians(rotation);
      double labelRot = Math.toRadians(labelRotation);

      // get rotation angle iterator, if applicable
      Iterator<Float> rotIterator = (rotationProducer == null) ? null : rotationProducer.iterator();
      
      // for progress reporting...
      int nLocsPainted = 0;
      int nEvery = doLabel ? PROGRESSINTV : PROGRESSINTV_NOLABEL;

      Shape s = (width == 1f && height == 1f) ? paintedShape.getDesignShape() : scaledShape;
      double xPrev = 0;
      double yPrev = 0;
      for(Point2D p : locationProducer)
      {
         // skip ill-defined locations.
         if(!Utilities.isWellDefined(p))
         {
            ++nLocsPainted;
            if(rotIterator != null && rotIterator.hasNext()) rotIterator.next();
            continue;
         }

         // translate origin from previous point to the current point
         double dx = p.getX() - xPrev;
         double dy = p.getY() - yPrev;
         g2d.translate(dx, dy);
         xPrev = p.getX();
         yPrev = p.getY();

         // rotate about the target location, if necessary
         double shapeRot = 0;
         if(rotIterator != null)
         {
            if(rotIterator.hasNext()) shapeRot = Math.toRadians(rotIterator.next());
         }
         else shapeRot = rot;
         if(shapeRot != 0) g2d.rotate(shapeRot);

         // if shape is drawn, optionally fill it, then stroke it
         if(doShape)
         {
            if(doFill)
            {
               if(bkgFill != null)
               {
                  // the origin is at center of shape's bounding box instead of bottom-left corner..
                  g2d.setPaint(bkgFill.getPaintForFill(width, height, -width/2.0f, -height/2.0f));
               }
               else 
                  g2d.setColor(style.getFillColor());
               g2d.fill(s);
               
            }
            if(style.isStroked())
            {
               g2d.setColor(style.getStrokeColor());
               g2d.draw(s);
            }
         }

         // draw label if there is one. Since text must be drawn in a left-handed coordinate system and all Painter 
         // implementations assume a right-handed one, we temporarily flip the y-axis while rendering text. Also, the
         // text is drawn with the painter's text/fill color if a background fill is defined; if not, it is painted
         // with the stroke color (since shape will be filled with the text/fill color).
         if(doLabel)
         {
            if(labelRot != 0) g2d.rotate(labelRot);
            g2d.scale(1,-1);
            g2d.setColor(bkgFill == null ? style.getStrokeColor() : style.getFillColor());
            g2d.drawString(attrLabel.getIterator(), fLblOffsetX, fLblOffsetY);
            g2d.scale(1,-1);
            if(labelRot != 0) g2d.rotate(-labelRot);
         }

         // undo rotation before moving on to the next location!
         if(shapeRot != 0) g2d.rotate(-shapeRot);

         // check for render task cancellation at regular intervals
         ++nLocsPainted;
         if(nLocsPainted >= nEvery)
         {
            nLocsPainted = 0;
            if(stopPainting()) return(false);
         }
      }

      return(true);
   }

   @Override protected void recalcBounds2D(Rectangle2D r)
   {
      // start out with an empty rectangle
      r.setFrame(0, 0, 0, 0);

      // check for obvious cases in which nothing is rendered
      boolean doLabel = isLabelRendered();
      boolean doFill = shouldFill();
      boolean doShape = (width > 0f) && (height > 0f) && (doFill || style.isStroked());
      if(locationProducer == null || !(doShape || doLabel))
         return;

      // compute rectangle that bounds the UNROTATED shape, located at (0,0). Compensate for stroke width.
      Rectangle2D bounds = null;
      if(doShape)
      {
         Shape s = (width == 1f && height == 1f) ? paintedShape.getDesignShape() : scaledShape;
         bounds = style.getStroke(0).createStrokedShape(s).getBounds2D();
      }

      // if the shape has a label, compute rectangle that bounds the text, possibly rotated WRT the shape. The text 
      // label is centered both vertically and horizontally about (0,0). Combine text bounds with shape bounds.
      if(doLabel && fontRC != null)
      {
         if(isPlainText) attrLabel.addAttribute(TextAttribute.FONT, style.getFont());
         TextLayout layout = new TextLayout(attrLabel.getIterator(), fontRC);
         Rectangle2D textBounds = layout.getBounds();
         textBounds.setFrame(-textBounds.getWidth()/2, -textBounds.getHeight()/2, 
               textBounds.getWidth(), textBounds.getHeight());
         if(labelRotation != 0) 
         {
            double rot = Math.toRadians(labelRotation);
            textBounds = AffineTransform.getRotateInstance(rot).createTransformedShape(textBounds).getBounds2D();
         }

         if(bounds == null) bounds = textBounds;
         else Rectangle2D.union(bounds, textBounds, bounds); 
      }

      // this could happen if the shape itself is invisible and we don't yet have a font render context for measuring 
      // the text label.
      if(bounds == null) return;

      // if rotation producer not specified, all shapes are rotated by the same angle. If this angle is nonzero,
      // go ahead and rotate the bounding rectangle above, and find the rectangle bounding that rotated rect.
      if(rotationProducer == null && rotation != 0)
      {
        double rot = Math.toRadians(rotation);
        bounds = AffineTransform.getRotateInstance(rot).createTransformedShape(bounds).getBounds2D();
      }
      
      // iterate over all shape locations, possibly rotating each shape differently, and find the left, right, top 
      // and bottom edges of the rectangle that bounds all shapes
      double xMin = Double.POSITIVE_INFINITY;
      double xMax = Double.NEGATIVE_INFINITY;
      double yMin = Double.POSITIVE_INFINITY;
      double yMax = Double.NEGATIVE_INFINITY;

      Iterator<Float> rotIterator = (rotationProducer == null) ? null : rotationProducer.iterator();
      for(Point2D p : locationProducer)
      {
         // skip ill-defined locations.
         if(!Utilities.isWellDefined(p)) 
         {
            if(rotIterator != null && rotIterator.hasNext()) rotIterator.next();
            continue;
         }

         Rectangle2D rotatedBounds = bounds;
         if(rotIterator != null && rotIterator.hasNext())
         {
            double rot = Math.toRadians((double) rotIterator.next());
            if(rot != 0) 
               rotatedBounds = AffineTransform.getRotateInstance(rot).createTransformedShape(bounds).getBounds2D();
         }
         
         double x = p.getX() + rotatedBounds.getX();
         if(x < xMin) xMin = x;
         x += rotatedBounds.getWidth();
         if(x > xMax) xMax = x;
         
         double y = p.getY() + rotatedBounds.getY();
         if(y < yMin) yMin = y;
         y += rotatedBounds.getHeight();
         if(y > yMax) yMax = y;
      }
      
      // as long as at least one shape will be rendered, set the bounding rectangle accordingly
      if(Utilities.isWellDefined(xMin)) r.setRect(xMin, yMin, xMax-xMin, yMax-yMin);
   }

   
   /**
    * So we don't have to reallocate a GeneralPath every time we rescale the design shape.
    */
   private GeneralPath scaledShape = null;

  /**
    * Recomputes the path for the shape scaled to the current dimensions.  Invoke this method whenever the design shape 
    * or its dimensions change.
    */
   private void updateScaledShape()
   {
      if(width > 0f && height > 0f && (width != 1f || height != 1f))
      {
         if(scaledShape == null) scaledShape = new GeneralPath();
         else scaledShape.reset();
         PathIterator pi = 
               paintedShape.getDesignShape().getPathIterator(AffineTransform.getScaleInstance(width,height));
         scaledShape.setWindingRule(pi.getWindingRule());
         scaledShape.append(pi, false);
      }
   }

   /**
    * Get a copy of this shape painter's design shape scaled IAW the painter's width and height properties.
    * 
    * @return The painter's design shape scaled by the painter's width and height, in logical units. If the current size
    * is 0, then an empty path is returned.
    */
   public Shape getScaledShape()
   {
      Shape s;
      if(width <= 0f || height <= 0f) s = new GeneralPath();
      else if(width == 1f && height == 1f) s = paintedShape.getDesignShape();
      else s = new GeneralPath(scaledShape);
      return(s);
   }

}
