package com.srscicomp.common.g2dutil;

import java.awt.Graphics2D;
import java.awt.geom.Line2D;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.text.AttributedString;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

import com.srscicomp.common.util.Utilities;

/**
 * <code>LineSegmentPainter</code> is a <code>Painter</code> which paints one or more line segments with an adornment 
 * drawn at the first endpoint, second endpoint, and/or midpoint of each line segment. 
 * 
 * <p>Implementation details. The painter renders a line segment for each pair of points generated by its "location 
 * producer". If either point in the pair is ill-defined, that pair is ignored. The line segment's adornment is 
 * characterized by a <code>PaintableShape</code>. The adornment is oriented such that its positive x-axis in "design 
 * space" is colinear with the line segment and points in the same direction as the ray from the first to the second 
 * endpoint. If the shape is <em>not</em> vertically symmetric</p>, it will be flipped 180deg at the first endpoint of 
 * the line segment -- a useful feature for a line segment adorned with arrows or similar shapes at the endpoints. If 
 * this default flip behavior is not desirable, you can override it. Finally, the adornment may optionally have a text 
 * label centered horizontally and vertically about the adornment's center point. The label is drawn in the stroke 
 * color rather than the fill/text color specified by the <code>PainterStyle</code> assigned to the adornment (else it 
 * would be obliterated inside a filled adornment!). Even if the first adornment is flipped, its label is drawn at the 
 * same orientation as the labels in the other two adornments.</p>
 * 
 * <p>Separate <code>PainterStyle</code>s may be specified for rendering line segment vs the adornment. Internally, 
 * <code>LineSegmentPainter</code> delegates the task of rendering the adornments to a <code>ShapePainter</code>.</p>
 * 
 * @author  sruffner
 */
public class LineSegmentPainter extends Painter
{
   /** If set, the adornment (if there is one) will be rendered at the first endpoint of the line segment. */
   private boolean isP0Adorned = false;

   /** If set, the adornment (if there is one) will be rendered at the second endpoint of the line segment. */
   private boolean isP1Adorned = false;

   /** If set, the adornment (if there is one) will be rendered at the midpoint of the line segment. */
   private boolean isMidAdorned = false;

   /** "Flip" policy for a non-vertically symmetric adornment at the first endpoint of line segment. */
   private boolean doFlip = true;

   /** Draw the line segment IAW the painter's stroking properties if this flag is set (default = true). */
   private boolean enaLine = true;
   
  /**
    * Set the properties of any adornments drawn along line segment by this <code>LineSegmentPainter</code>.
    * 
    * <p><em>Note</em> that an adornment is drawn if it has a positive size OR its label is a non-empty string.</p>
    * 
    * @param style The painter style with which adornments should be rendered. If <code>null</code>,
    * any adornments are drawn using the painter style applied to the line segment itself.
    * @param shape The <code>PaintableShape</code> that represents the adornment to be rendered, at unit size. If 
    * <code>null</code>, no adornments will be rendered.
    * @param size The desired size of the adornment(s), in logical units. The adornment will be scaled by this value 
    * both horizontally and vertically at render time. If nonpositive and there is no label, then nothing is drawn.
    * @param label An optional label to be centered horizontally and vertically about each location at which the 
    * adornment is drawn. The label is drawn using the stroke color rather than the fill/text color of the 
    * <code>PainterStyle</code> in which adornment is rendered. If <code>null</code> or empty string, no label is 
    * drawn.
    * @param atP0 If <code>true</code>, the adornment will be rendered at the first endpoint of the line segment.
    * @param atP1 If <code>true</code>, the adornment will be rendered at the second endpoint of the line segment.
    * @param atMid If <code>true</code>, the adornment will be rendered at the midpoint of the line segment.
    * @param doFlip If <code>true</code>, a non-vertically symmetric adornment will be rotated 180deg at the first 
    * endpoint, so it "opposes" the unflipped adornment drawn at the second endpoint. If <code>false</code>, no flip is 
    * performed.
    */
   public void setAdornment(PainterStyle style, PaintableShape shape, float size, String label, boolean atP0, 
         boolean atP1, boolean atMid, boolean doFlip)
   {
      this.isP0Adorned = atP0;
      this.isP1Adorned = atP1;
      this.isMidAdorned = atMid;
      this.doFlip = doFlip && shape != null && !shape.isVSymmetric();

      // update our internal shape painter and force a recalculation of render bounds
      adornPainter.setStyle((style != null) ? style : this.style);
      adornPainter.setPaintedShape(shape);
      adornPainter.setSize(shape == null ? 0f : size);
      adornPainter.setTextLabel(label); 
      adornPainter.invalidateBounds();
      invalidateBounds();
   }

   /**
    * Set the adornment text label as an attributed character string on this line segment painter.
    * @param aStr The adornment label as an attributed string.
    */
   public void setAttributedAdornmentLabel(AttributedString aStr) { adornPainter.setTextLabel(aStr); }
   
   /**
    * Enable/disable stroking the line segment that connects each pair of well-defined points generated by the painter's
    * location producer. By default, the line segment is stroked (unless the stroke width is 0 or the stroke color is
    * fully transparent). This method provides a way of disabling the stroke without altering the painter's style
    * properties. (Use case: When drawing symbols at the end or middle of an unstroked line segment.)
    * @param ena True to enable, false to disable stroking.
    */
   public void setEnaDrawLineSegment(boolean ena) { enaLine = ena; }
   
   /**
    * Construct a <code>LineSegmentPainter</code> with no location producer, no adornment defined, and a default 
    * painter style. The painter constructed will render nothing.
    */
   public LineSegmentPainter()
   {
      this(null, null);
   }

   /**
    * Construct a <code>LineSegmentPainter</code>.  Initially, no adornment is defined, so the constructed painter will 
    * only drawn line segments between each pair of well-defined points generated by its location producer. To define 
    * an adornment, call <code>setAdornmment()</code>.
    * 
    * @param style Collection of graphic attributes applied to this painter.  If <code>null</code>, then the painter
    * uses defaults.
    * @param producer The location producer for this painter. If <code>null</code>, then the painter renders nothing!
    */
   public LineSegmentPainter(PainterStyle style, Iterable<Point2D> producer)
   {
      super(style, producer);

      // set up internal painter for rendering adornments
      adornPainter = new ShapePainter();
      pAdorn = new Point2D.Double();
      List<Point2D> adornLoc = new ArrayList<>();
      adornLoc.add(pAdorn);
      adornPainter.setLocationProducer(adornLoc);
      setAdornment(null, null, 0f, null, false, false, true, true);
   }

   //
   // Painting the line segments
   //

   /**
    * The interval, in #line segments completed, at which a <code>LineSegmentPainter</code> reports progress and checks 
    * for job cancellation during a rendering pass.
    */
   private final static int PROGRESSINTV = 50;

   /**
    * The <code>ShapePainter</code> used to draw endpoint/midpoint adornments for this <code>LineSegmentPainter</code>. 
    * It is set up during a rendering pass.
    */
   private final ShapePainter adornPainter;

   /**
    * The point at which an adornment is drawn by the internal <code>ShapePainter</code>. It is reused to draw all 
    * adornments during a rendering pass.
    */
   private final Point2D pAdorn;

   @Override
   protected boolean paintInternal(Graphics2D g2d)
   {
      // check for obvious cases in which nothing is rendered
      boolean isStroked = enaLine && style.isStroked();
      boolean doAdorn = adornPainter.isRendered() && (isP0Adorned || isP1Adorned || isMidAdorned);
      if(locationProducer == null || !(isStroked || doAdorn)) 
         return(true);

      boolean flip = doAdorn && doFlip;

      // draw each line segment in turn...
      int nSegsDone = 0;
      g2d.setColor(style.getStrokeColor());
      g2d.setStroke(style.getStroke(0));
      Line2D lineSeg = new Line2D.Double();
      Iterator<Point2D> locIterator = locationProducer.iterator();
      Point2D p0;
      Point2D p1;
      while(locIterator.hasNext())
      {
         // get next pair of points from location provider
         p0 = locIterator.next();
         if(!locIterator.hasNext()) break;
         p1 = locIterator.next();

         // ignore pair if they're not both well-defined
         if(!(Utilities.isWellDefined(p0) && Utilities.isWellDefined(p1))) 
         {
            ++nSegsDone;
            continue;
         }

         if(isStroked)
         {
            lineSeg.setLine(p0, p1);
            g2d.draw(lineSeg);
         }

         if(doAdorn)
         {
            // compute orientation of line segment. Adornments are rotated so that their positive x-axis in 
            // "design" space is parallel to the line segment and points in same direction as a ray from the 
            // first to the second endpoint.
            double ori = Math.toDegrees(Math.atan2(p1.getY()-p0.getY(), p1.getX()-p0.getX()));

            if(isP0Adorned)
            {
               // first endpoint adornment. We may flip it if it is not V-symmetric. In that case, if it has a text 
               // label, we adjust the orientation of the text label so that it is the same as the text label in 
               // each of the other adornments.
               pAdorn.setLocation(p0);
               adornPainter.setRotation(ori + (flip ? 180 : 0));
               if(flip) adornPainter.setLabelRotation(-180);
               adornPainter.render(g2d, null);
               if(flip) adornPainter.setLabelRotation(0);
            }
            if(isMidAdorned)
            {
               // midpoint adornment
               pAdorn.setLocation( (p0.getX() + p1.getX())/2, (p0.getY() + p1.getY())/2 );
               adornPainter.setRotation(ori);
               adornPainter.render(g2d, null);
            }
            if(isP1Adorned)
            {
               // second endpoint adornment
               pAdorn.setLocation(p1);
               adornPainter.setRotation(ori);
               adornPainter.render(g2d, null);
            }
         }

         // report progress and check for cancellation every once in a while
         ++nSegsDone;
         if(nSegsDone >= PROGRESSINTV)
         {
            nSegsDone = 0;
            if(stopPainting()) return(false);
         }
      }

      return(true);
   }

   @Override protected void recalcBounds2D(Rectangle2D r)
   {
      // start out with an empty rectangle
      r.setFrame(0, 0, 0, 0);

      // check for obvious cases in which nothing is rendered
      boolean isStroked = enaLine && style.isStroked();
      boolean doAdorn = adornPainter.isRendered() && (isP0Adorned || isP1Adorned || isMidAdorned);
      if(locationProducer == null || !(isStroked || doAdorn)) 
         return;

      // find bounding box enclosing all valid line segments
      boolean gotValidSegment = false;
      double xMin = Double.POSITIVE_INFINITY;
      double xMax = Double.NEGATIVE_INFINITY;
      double yMin = Double.POSITIVE_INFINITY;
      double yMax = Double.NEGATIVE_INFINITY;
      Iterator<Point2D> locIterator = locationProducer.iterator();
      Point2D p0;
      Point2D p1;
      while(locIterator.hasNext())
      {
         // get next pair of points from location provider
         p0 = locIterator.next();
         if(!locIterator.hasNext()) break;
         p1 = locIterator.next();

         // segment can't be drawn if the endpoints are not both well-defined
         if(!(Utilities.isWellDefined(p0) && Utilities.isWellDefined(p1))) 
            continue;

         gotValidSegment = true;
         if(p0.getX() < xMin) xMin = p0.getX();
         if(p0.getX() > xMax) xMax = p0.getX();
         if(p0.getY() < yMin) yMin = p0.getY();
         if(p0.getY() > yMax) yMax = p0.getY();

         if(p1.getX() < xMin) xMin = p1.getX();
         if(p1.getX() > xMax) xMax = p1.getX();
         if(p1.getY() < yMin) yMin = p1.getY();
         if(p1.getY() > yMax) yMax = p1.getY();
      }

      // now grow bounding box by 1/2 of the larger of: the line segment's stroke width and the larger dimension of 
      // the adornment painter's bounding box (if applicable).
      if(gotValidSegment)
      {
         double grow = isStroked ? style.getStrokeWidth() : 0;
         if(doAdorn)
         {
            adornPainter.invalidateBounds();
            adornPainter.getBounds2D(r);
            double s = Math.max(r.getWidth(),r.getHeight()) + adornPainter.style.getStrokeWidth();
            if(s > grow) grow = s;
         }
         r.setRect(xMin-grow/2, yMin-grow/2, xMax-xMin+grow, yMax-yMin+grow);
      }
   }
}
