package com.srscicomp.common.g2dutil;

import java.awt.Graphics2D;
import java.awt.geom.GeneralPath;
import java.awt.geom.PathIterator;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;

import com.srscicomp.common.util.Utilities;

/**
 * <code>PolylinePainter</code> is a <code>Painter</code> which strokes and/or fills a path specified by a sequence of
 * points generated by the painter's "location producer". The points should be expressed in the logical coordinate 
 * system of the <code>Graphics2D</code> context passed to the painter's <code>render()</code> method.
 * 
 * <p>Handling ill-defined points.  If any point provided by the location producer is ill-defined -- as determined by 
 * the method <code>Utilities.isWellDefined(Point2D)</code> --, it must be omitted from the polyline path. Such points 
 * can introduce "subpaths" into the polyline path, depending on the painter's "connection policy":
 * <ul>
 *    <li><code>ConnectPolicy.CONNECTED</code>: Ill-defined points are simply ignored, and <code>PolylinePainter</code> 
 *    simply executes a "lineto" the next valid location. The result is a single, connected polyline path.</li>
 *    <li><code>ConnectPolicy.GAPS</code>: Ill-defined points start a new subpath; <code>PolylinePainter</code> executes 
 *    a "moveto" the next valid location. The result is a polyline path with gaps introduced by any ill-defined 
 *    points. This is the default connection policy.</li>
 *    <li><code>ConnectPolicy.CLOSED</code>: An ill-defined point closes the current subpath, then starts a new one; 
 *    <code>PolylinePainter</code> executes a "closepath" followed by a "moveto" the next valid location. This policy 
 *    makes it possible to render multiple polygons with a single painter.</li>
 * </ul>
 * </p>
 * 
 * <p><em>On progress reporting and cancelling a paint operation:</em></p>
 * 
 * <p><code>PolylinePainter</code> does its rendering work by assembling a <code>GeneralPath</code> that represents the 
 * polyline in painting coordinates, then submitting that to the <code>Graphics2D.fill()</code> and <code>draw()</code> 
 * methods for filling and stroking, respectively. The problem here is that, if the polyline path is very long, these 
 * primitive graphic operations can take a significant amount of time to complete. In that case, reporting progress and 
 * checking for cancellation after the fill and again after stroking is not sufficiently fine-grained. For example, a 
 * 4000-pt polyline of random points covering a roughly 4x6in area took ~1.8 sec to fill and stroke on a WinXP machine 
 * (built circa 2003) running J2SE5.0. Tests have shown that stroking takes significantly longer than filling the 
 * polyline path (4x longer). Preparation of the <code>GeneralPath</code> occupied an insignificant amount of time.</p>
 * 
 * <p><code>PolylinePainter</code> addresses this problem by stroking the polyline in 500-pt chunks. This, of course, 
 * introduces a loss in graphic fidelity. The "join" between the chunks will not be correct. Also, even though we 
 * compensate the stroke dash phase at the start of each chunk IAW the path travelled thus far, tests have shown that 
 * the stroke dash pattern gets screwed up across the polyline chunks. Since this loss of graphic fidelity may not be 
 * desirable, <code>PolylinePainter</code> will, by default, stroke the entire polyline in one go.  To enable the 
 * lower-fidelity, but more fine-grained implementation, use <code>setAllowChunking()</code>.</p>
 * 
 * @author  sruffner
 */
public class PolylinePainter extends Painter
{
   /**
    * Enumeration of connection policies supported by <code>PolylinePainter</code>. The connection policy determines 
    * how subpaths in the painter's polyline path -- introduced by ill-defined points from its location producer -- 
    * are connected to each other.
    * 
    * @author  sruffner
    */
   public enum ConnectPolicy
   {
      /**
       * Disjoint unclosed subpaths: <code>PolylinePainter</code> executes a "moveto" the next valid location from its
       * location producer.
       */
      GAPS,

      /**
       * Fully connected single polyline path: <code>PolylinePainter</code> executes a "lineto" the next valid location 
       * from its location producer.
       */
      CONNECTED,

      /**
       * Disjoint closed subpaths: <code>PolylinePainter</code> executes a "closepath" followed by a "moveto" the next 
       * valid location from its location producer.
       */
      CLOSED
   }

    /**
    * The current connection policy, which determines how <code>PolylinePainter</code> treats ill-defined points from 
    * its location producer.
    */
   private ConnectPolicy connect = ConnectPolicy.GAPS;

   /**
    * Set connection policy for handling a polyline path interrupted by an ill-defined point
    * 
    * <p><em><strong>NOTE</strong></em>: Closed subpaths are not compatible with chunking. If chunking is enabled and 
    * the connection policy is <code>ConnectPolicy.CLOSED</code>, chunking will only occur after completing a closed 
    * subpath.</p>
    * 
    * @see PolylinePainter#setAllowChunking(boolean)
    * @param policy The new connection policy. If <code>null</code>, <code>ConnectPolicy.GAPS</code> is assumed.
    */
   public void setConnectionPolicy(ConnectPolicy policy)
   {
      this.connect = (policy==null) ? ConnectPolicy.GAPS : policy;
   }

   /**
    * Fill flag. If set, the polyline path is filled. Default is <code>false</code>.
    */
   private boolean filled = false;

   /**
    * Set the fill flag.
    * 
    * <p>A <code>PolylinePainter</code> can fill and/or stroke the polyline path defined by its location producer. The 
    * fill is done first, followed by the stroke. This method determines whether or not the path is filled.</p>.
    * 
    * @param filled If unset (the default), the polyline path is not filled; else it is.
    */
   public void setFilled(boolean filled)
   {
      this.filled = filled;
   }

   /**
    * Stroke flag. If set, the polyline path is stroked. Default is <code>true</code>.
    */
   private boolean stroked = true;

   /**
    * Set the stroked flag.
    * 
    * <p>A <code>PolylinePainter</code> can fill and/or stroke the polyline path defined by its location producer. The 
    * fill is done first, followed by the stroke. This method determines whether or not the path is stroked.</p>.
    * 
    * @param stroked If set (the default), the polyline path is stroked; else it is not.
    */
   public void setStroked(boolean stroked)
   {
      this.stroked = stroked;
   }

   /**
    * If set, painter will stroke the polyline in chunks rather than all at once.
    */
   private boolean allowChunking = false;

   /**
    * Set policy for stroking a polyline with many points.
    * 
    * <p>When a polyline has thousands of defining points, and the total path travelled is very long, it can take a 
    * very significant amount of time to stroke the entire polyline. Since there is no way to monitor the progress of 
    * the primitive drawing operation, the only way to achive a more fine-grained rendering -- for the purposes of 
    * reporting progress and checking for premature cancellation -- is to draw the polyline in chunks.  Doing so 
    * results in a loss of graphic fidelity, so <code>PolylinePainter</code> disallows "chunking" by default. Call this 
    * method to change the policy.</p>
    * 
    * <p><em><strong>NOTE</strong></em>: Closed subpaths are not compatible with chunking. If chunking is enabled and 
    * the connection policy is <code>ConnectPolicy.CLOSED</code>, chunking will only occur after completing a closed 
    * subpath.</p>
    * 
    * @see PolylinePainter#setConnectionPolicy(ConnectPolicy)
    * @param allowChunking <code>True</code> iff chunking is allowed when stroking the polyline.
    */
   public void setAllowChunking(boolean allowChunking)
   {
      this.allowChunking = allowChunking;
   }

   /**
    * Construct a <code>PolylinePainter</code> with no location producer and default graphic styles. The painter 
    * constructed will render nothing.
    */
   public PolylinePainter()
   {
      this(null, null);
   }

   /**
    * Construct a <code>PolylinePainter</code>. Initially, the polyline path is stroked but not filled, subpaths 
    * introduced by any ill-defined points from the location producer are neither closed nor connected to each other, 
    * and chunking of the polyline path is not allowed.
    * 
    * @param style Collection of graphic attributes applied to this painter. If <code>null</code>, then the painter 
    * uses default attributes.
    * @param producer The location producer for this painter. If <code>null</code>, then the painter
    * renders nothing!
    */
   public PolylinePainter(PainterStyle style, Iterable<Point2D> producer)
   {
      super(style, producer);
      setFilled(false);
      setStroked(true);
      setConnectionPolicy(ConnectPolicy.GAPS);
      setAllowChunking(false);
   }

   //
   // Painting the polyline
   //

   /**
    * Number of points in one continuously stroked "chunk" of the polyline path.
    */
   private final static int STROKECHUNK = 500;

   @Override
   protected boolean paintInternal(Graphics2D g2d)
   {
      // check for obvious cases in which nothing is rendered
      boolean isStroked = stroked && style.isStroked();
      if(locationProducer == null || !(filled || isStroked))
         return(true);
 
      // build the entire polyline path
      GeneralPath polyline = new GeneralPath();
      boolean gotValidLoc = false;              // we MUST move to the first valid location in list
      boolean nextOpIsMoveTo = true;
      int nValidLocs = 0;
      for(Point2D p : locationProducer)
      {
         if(Utilities.isWellDefined(p))
         {
            if((!gotValidLoc) || nextOpIsMoveTo)
            {
               polyline.moveTo((float)p.getX(), (float)p.getY());
            }
            else
               polyline.lineTo((float)p.getX(), (float)p.getY());
            gotValidLoc = true;
            nextOpIsMoveTo = false;
            ++nValidLocs;
         }
         else if(gotValidLoc)
         {
            // handle ill-defined point IAW connection policy
            if(connect == ConnectPolicy.CONNECTED)
               nextOpIsMoveTo = false;
            else
            {
               nextOpIsMoveTo = true;
               if(connect == ConnectPolicy.CLOSED)
               {
                  polyline.closePath();
               }
            }
         }
      }

      // check for job cancellation
      if(stopPainting()) return(false);

      // handle extreme degenerate case!
      if(nValidLocs < 2)
         return(true);

      // fill path if required; then check for job cancellation
      if(filled && nValidLocs > 2)
      {
         g2d.setColor(style.getFillColor());
         g2d.fill(polyline);

         if(stopPainting()) return(false);
      }

      // stroke path if required. If chunking allowed, check for job cancellation after each chunk.
      if(isStroked)
      {
         if(nValidLocs <= 2*STROKECHUNK || !allowChunking)
         {
            g2d.setColor(style.getStrokeColor());
            g2d.setStroke(style.getStroke(0));
            g2d.draw(polyline);

             return !stopPainting();
         }
         else
         {
            // if stroke is not solid we'll have to adjust dash phase for each subsequent chunk. We do so by setting 
            // the phase to the path length traversed thus far.
            boolean isSolid = style.isStrokeSolid();
            double totalPathLen = 0;

            g2d.setColor(style.getStrokeColor());
            g2d.setStroke(style.getStroke(0));

            PathIterator pi = polyline.getPathIterator(null);
            float[] coords = new float[] {0, 0, 0, 0, 0, 0};
            GeneralPath chunk = new GeneralPath(polyline.getWindingRule(), STROKECHUNK);
            Point2D pLast = null;
            Point2D pLastMoveto = null;
            while( !pi.isDone() )
            {
               int i = 0;
               double chunkPathLen = 0;
               boolean isChunkDone = false;
               while(!isChunkDone && !pi.isDone())
               {
                  int type = pi.currentSegment(coords);
                  if(type == PathIterator.SEG_MOVETO) 
                  {
                     chunk.moveTo(coords[0], coords[1]);
                     if(pLastMoveto == null) pLastMoveto = new Point2D.Double();
                     pLastMoveto.setLocation(coords[0], coords[1]);
                  }
                  else if(type == PathIterator.SEG_LINETO) chunk.lineTo(coords[0], coords[1]);
                  else if(type == PathIterator.SEG_CLOSE) chunk.closePath();
                  else assert(true);

                  // accumulate path length travelled so far
                  if(type == PathIterator.SEG_CLOSE && pLastMoveto != null)
                     chunkPathLen += pLast.distance(pLastMoveto);
                  else if(pLast != null) 
                     chunkPathLen += pLast.distance(coords[0], coords[1]);

                  // remember last point
                  if(pLast == null) pLast = new Point2D.Double();
                  if(type == PathIterator.SEG_CLOSE)
                     pLast.setLocation(pLastMoveto);
                  else
                     pLast.setLocation(coords[0], coords[1]);

                  pi.next();
                  ++i;

                  // break out when we're done with chunk. If connection policy introduces closed subpaths, then we 
                  // only stop at the end of a closed subpath!!
                  if(i >= STROKECHUNK)
                     isChunkDone = (connect != ConnectPolicy.CLOSED) || (type == PathIterator.SEG_CLOSE);
               }

               g2d.draw(chunk);
               if(stopPainting()) return(false);

               // start a new chunk that begins with a moveto the end of the previous chunk
               chunk.reset();
               if(pLast != null) chunk.moveTo((float)pLast.getX(), (float)pLast.getY());

               // adjust stroke dash phase if stroke is not solid
               if(!isSolid)
               {
                  totalPathLen += chunkPathLen;
                  g2d.setStroke(style.getStroke((float)totalPathLen));
               }
            }
         }
      }
      
      return(true);
   }

   @Override protected void recalcBounds2D(Rectangle2D r)
   {
      // start out with an empty rectangle
      r.setFrame(0, 0, 0, 0);

      // check for obvious cases in which nothing is rendered
      boolean isStroked = stroked && style.isStroked();
      if(locationProducer == null || !(filled || isStroked))
         return;
 
      // find bounding box of valid locations
      boolean gotValidLoc = false;
      double xMin = Double.POSITIVE_INFINITY;
      double xMax = Double.NEGATIVE_INFINITY;
      double yMin = Double.POSITIVE_INFINITY;
      double yMax = Double.NEGATIVE_INFINITY;
      for(Point2D p : locationProducer) if(Utilities.isWellDefined(p))
      {
         gotValidLoc = true;
         if(p.getX() < xMin) xMin = p.getX();
         if(p.getX() > xMax) xMax = p.getX();

         if(p.getY() < yMin) yMin = p.getY();
         if(p.getY() > yMax) yMax = p.getY();
      }

      // grow strict bounding box by half-stroke width so bounding box encompasses strokes near its edge
      if(gotValidLoc)
      {
         double strokeW = isStroked ? style.getStrokeWidth() : 0;
         r.setRect(xMin-strokeW/2, yMin-strokeW/2, xMax-xMin+strokeW, yMax-yMin+strokeW);
      }
   }
}
