package com.srscicomp.fc.matlab;

import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Collection;
import java.util.Map;

import com.jmatio.io.MatFileHeader;
import com.jmatio.io.MatFileReader;
import com.jmatio.types.MLArray;
import com.jmatio.types.MLCell;
import com.jmatio.types.MLChar;
import com.jmatio.types.MLDouble;
import com.jmatio.types.MLSingle;
import com.jmatio.types.MLStructure;
import com.srscicomp.fc.fig.FGraphicModel;

/**
 * Utility that reads in a <i>Matlab</i> figure and converts it to a <i>DataNav</i> FypML figure graphic model.
 *
 * <p>The class is not instantiated. It includes two public static methods, one that checks whether or not an arbitrary
 * file's content is consistent with that of a valid Matlab Level 5 FIG file (compatible with Matlab versions 5 and up),
 * and another that imports a Level 5 FIG file as a <i>DataNav</i> FypML figure.</p>
 *
 * <p>CREDIT: <a href="https://github.com/gradusnikov/jmatio">JMatIO library by Wojciech Gradkowsky</a>. We rely on a
 * slightly revised version of this library to read in the Handle Graphics hierarchy stored in a Matlab FIG file. The
 * {@link MatFileReader} class was slightly modified to skip over data elements in the FIG file representing
 * Matlab function handles -- these elements are NOT documented in the Mathworks MAT file format specification. We do
 * not need them for the purposes of importing a Matlab FIG file as a FypML figure.</p>
 *
 * @author sruffner
 */
public class MatlabFigureImporter
{
   /**
    * For test/development use only: Use to import a problem figure, so we can investigate why import isn't working.
    * @param args Arguments are not used.
    */
   public static void main(String[] args)
   {
      BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
      
      // get pathname to a directory of files to be tested
      System.out.print("Specify full pathname of a FIG file to be imported\n> ");
      String fname = null;
      try
      {
         fname = in.readLine();
      }
      catch(IOException ioe)
      {
         System.out.println("Unexpected IO error while reading file path:\n   " + ioe.getMessage() + "\nQUITTING!");
      }
      if(fname == null)
         System.exit(0);
      
      File f = new File(fname);
      if(!isMatlabFigFile(f))
         System.out.println("===> NOT a FIG file, or FIG file format not supported.");
      else
      {
         StringBuffer eBuf = new StringBuffer();
         FGraphicModel fgm = importMatlabFigureFromFile(f, eBuf);
         if(fgm == null)
         {
            System.out.println("Import FAILED. Error dump:");
            System.out.println(eBuf);
         }
         else
         {
            System.out.println("Import OK. Tree dump:");
            System.out.println(eBuf);
            
            DNFigureSaveDlg.raiseConfirmSaveDialog(fgm, new File("/Users/sruffner/Desktop/imported.fyp"));
         }
      }
   }
   
   /**
    * Is the specified file a Matlab Level 5 FIG file? The method checks the following constraints:
    * <ul>
    * <li>The file must exist and its name must end with the ".fig" extension.</li>
    * <li>The file's 128-byte header must be consistent with that of a Matlab Level 5 MAT file.</li>
    * </ul>
    * Of course, satisfying these constraints is NOT an iron-clad guarantee that the file is a Matlab FIG file, but it
    * would too time-consuming to read in and validate the entire file. As it stands, this method should be reasonably
    * safe to call on the Swing event dispatch thread.
    * 
    * @param f The candidate file.
    * @return True if specified file meets all of the requirements outlined.
    */
   public static boolean isMatlabFigFile(File f)
   {
      boolean isFig = (f != null) && f.isFile();
      if(isFig)
      {
         String name = f.getName();
         isFig = (name.length() > 4) && (".fig".equalsIgnoreCase(name.substring(name.length()-4)));
      }
      
      if(isFig) isFig =  MatFileReader.checkForFigFileLevel5(f);
      
      return(isFig);
   }
   
   /**
    * Import the specified Matlab figure file (.FIG extension) as a FypML figure graphic model. <b>This method should
    * only be called on a background thread, since importing a large figure could take a noticeable amount of time.</b>
    * 
    * <p>A previous version of this method expected the FIG file to contain a SINGLE Matlab structure array at root
    * level, with its name starting with "hgS_". This was developed with testing under R2013a. However, the FIG file 
    * generated by R2013b seems to contain another element at root level, a uint8 array with name "@". I do not know if
    * this is consistent, but I've since modified this method so that it looks for a structure array at root level with
    * a name starting with "hgS_", which it then processes as usual. Any other elements at root level are ignored.</p>
    * 
    * <p><b>Matlab R2014b</b>: Starting with this release, we observed that there are two items at root level -- the
    * 'hgS_070000' Matlab structure array as before, plus another field 'hgM_070000' that is a Matlab object array.
    * We currently do NOT support processing this array. One consequence: the 'scribe.colorbar' object was revamped in
    * R2014b and no longer is a specialized 'axes' object. The color bar label is described by the 'Label' property,
    * which is a Matlab Text object. This property does not exist in the HG tree rooted at 'hgS_070000'; thus, we won't
    * be able to reproduce color axis labels when importing a FIG file generated by R2014b or later.</p>
    * 
    * @param f The file containing the Matlab figure to be imported. Required file extension = ".fig".
    * @param ebuf If import fails, this contains error text. It could contain many text lines. Cannot be null.
    * @return If import is successful, the FypML figure that is equivalent (to the extent possible) to the Matlab figure
    * stored in the file specified. Else, returns null.
    */
   public static FGraphicModel importMatlabFigureFromFile(File f, StringBuffer ebuf)
   {
      if(ebuf == null) throw new IllegalArgumentException("Error description buffer must be specified");
      ebuf.setLength(0);
      
      if(f == null || !f.isFile())
      {
         ebuf.append("File not found.");
         return(null);
      }
      String name = f.getName();
      if(name.length() <= 4 || !".fig".equalsIgnoreCase(name.substring(name.length()-4)))
      {
         ebuf.append("Invalid Matlab figure file extension: ").append(name.substring(name.length() - 3));
         return(null);
      }
      
      MatFileReader matReader;
      try
      {
         matReader = new MatFileReader(f);
      }
      catch(IOException ioe)
      {
         ebuf.append("An IO error occurred while reading FYP file:\n  ").append(ioe.getMessage());
         return(null);
      }
      
      // check that MAT file version is 1 -- which corresponds to Level 5. We don't support Level 4 or HDF format.
      MatFileHeader hdr = matReader.getMatFileHeader();
      if(hdr.getVersion() != 1)
      {
         ebuf.append("FYP file has unsupported MAT file version. Only Level 5 MAT files supported.");
         return(null);
      }

      // among the root-level contents there must be a 1x1 structure array S with the usual fields for a Matlab HG 
      // object. In particular S.type == 'figure'. This is the top-level check that we're looking at a .FIG file. If we
      // don't find such an object, the import fails. Else import proceeds with the contents of that object. Other
      // elements at root level, if any, are simply ignored.
      Map<String, MLArray> contents = matReader.getContent();
      MLStructure fig = null;
      for(String key : contents.keySet()) if(key.startsWith("hgS_") && contents.get(key).isStruct())
      {
         fig = (MLStructure) contents.get(key);
         break;
      }
            
      if(fig != null)
      {
         Collection<String> fields = fig.getFieldNames();
         boolean isFig = fig.getN() == 1 && fig.getM() == 1 && fields.contains("type") && fields.contains("handle") &&
               fields.contains("properties") && fields.contains("children") && fields.contains("special");
         if(isFig)
         {
            MLArray type = fig.getField("type");
            isFig = (type != null) && type.isChar() && ((MLChar) type).getString(0).equals("figure");
         }
         if(!isFig) fig = null;
      }
      if(fig == null)
      {
         ebuf.append("FYP file does not appear to contain a Matlab Handle Graphics figure hierarchy.");
         return(null);
      }

      // traverse FYP file's HG hierarchy and construct a tree of HGObjects that include only those elements of the
      // original Matlab figure that we can handle.
      HGObject figObj;
      try { figObj = constructHGObject(fig, 0); }
      catch(IllegalStateException ise)
      {
         ebuf.append("Error occurred while parsing HG object hierarchy in FYP file:\n  ").append(ise.getMessage());
         return(null);
      }
      
      // we don't need the FIG file contents at this point. Encourage garbage collection.
      //noinspection UnusedAssignment
      matReader = null;
      
      // convert tree of HGObjects to a FypML figure, if possible
      return(MatlabUtilities.matFigToFyp(figObj, 0, ebuf, true));
   }

   /**
    * Construct the {@link HGObject} encapsulating the Handle Graphics object stored in the Matlab structure given.
    * <i>This method is called recursively to construct a tree of HG objects.</i>
    * 
    * @param hgs Matlab structure array <i>M</i> holding one or more Handle Graphics objects.
    * @param idx The zero-based index of the structure array element to be parsed
    * @return A <code>HGObject</code> containing the type, handle, properties, and children of the Handle Graphics
    * object defined by <i>M(idx)</i>.
    * @throws IllegalStateException if Matlab structure array does not contain the required fields for a Matlab Handle
    * Graphics object.
    */
   private static HGObject constructHGObject(MLStructure hgs, int idx) throws IllegalStateException
   {
      String type = getHGType(hgs, idx);
      double handle = getHGHandle(hgs, idx);
      if(type == null || handle == 0)
         throw new IllegalStateException("Unable to parse HG object type or handle");
      
      String info = "type=" + type + ", handle=" + handle;
      
      // For 'axes' (and 'scribe.colorbar', which is really a specialized 'axes'), the 'special' field holds the Matlab
      // indices of child text objects defining axes title and axis labels: [iTitle iXLabel iYLabel iZLabel]. We need
      // these, but we cannot simply pass on the original indices to our Java representation of an 'axes' because we do 
      // not necessarily add all the children during this translation. Therefore, we store the relevant child handles 
      // instead. If there is no label defined, the handle is set to 0.
      double[] labelHandles = null;
      if(type.equals("axes") || type.equals("scribe.colorbar"))
         labelHandles = getHGLabelChildHandles(hgs, idx);
      
      HGObject hgObj = new HGObject(type, handle, labelHandles);
      MLStructure mlProps = getHGProperties(hgs, idx);
      if(mlProps == null) throw new IllegalStateException("Unable to parse properties from HG struct: " + info);
      processProperties(hgObj, mlProps);
      
      // recursion happens here...
      MLStructure mlChildren = getHGChildren(hgs, idx);
      if(mlChildren != null && !mlChildren.isEmpty()) addRelevantChildren(hgObj, mlChildren);
      
      return(hgObj);
   }

   /**
    * Add all "relevant" children to the {@link HGObject} under construction. <i>Method is called recursively to build
    * the tree of HG objects defining a <i>Matlab</i> figure.</i>
    * 
    * <p><i>DataNav</i> cannot import any possible Matlab figure; Matlab can generate many kinds of graphs that cannot
    * be reproduced in a FypML figure. While traversing and parsing a Matlab figure's Handle Graphics hierarchy, this
    * method skips any HG object that {@link MatlabUtilities#matFigToFyp(HGObject, double, StringBuffer, boolean)} will
    * be unable to convert. Child object types are limited as follows:
    * <ul>
    * <li>Parent = "figure" : See {@link #FIGUREKIDS}</li>
    * <li>Parent = "axes" : See {@link #AXESKIDS}.</li>
    * <li>Parent = "matlab.graphics.axis.PolarAxes": See {@link #POLARAXESKIDS}. (New in Matlab 2016a/b.)</li>
    * <li>Parent = "scribe.colorbar" : See {@link #COLORBARKIDS}.</li>
    * <li>Parent = "specgraph.barseries", "specgraph.areaseries", or "specgraph.contourgroup" : See {@link 
    * #BAR_AREAKIDS}.</li>
    * </ul>
    * All other child objects are ignored and will not be included in the tree of <code>HGObject</code>s representing
    * the Matlab figure.
    * </p>
    * 
    * @param parent The parent <code>HGObject</code> under construction.
    * @param mlKids The Matlab structure array (the "children" field) holding the definitions of the Handle Graphic
    * entities that are children of the <code>HGObject</code> under construction.
    * @throws IllegalStateException if Matlab structure array does not contain the required fields for a Matlab Handle
    * Graphics object.
    */
   private static void addRelevantChildren(HGObject parent, MLStructure mlKids) throws IllegalStateException
   {
      String[] kidTypes;
      String parentType = parent.getType();
      switch(parentType)
      {
      case "figure":
         kidTypes = FIGUREKIDS;
         break;
      case "axes":
         kidTypes = AXESKIDS;
         break;
      case "matlab.graphics.axis.PolarAxes":
         kidTypes = POLARAXESKIDS;
         break;
      case "scribe.colorbar":
         kidTypes = COLORBARKIDS;
         break;
      case "specgraph.barseries":
      case "specgraph.areaseries":
      case "specgraph.contourgroup":
         kidTypes = BAR_AREAKIDS;
         break;
      default:
         return;
      }
      
      for(int i=0; i<mlKids.getSize(); i++)
      {
         String type = getHGType(mlKids, i);
         if(type == null) 
         {
            String emsg = "Failed to parse HG object type of child at index " + i + " in Matlab 'children' struct";
            emsg += "Parent object type = " + parentType + ", handle = " + parent.getHandle();
            throw new IllegalStateException(emsg);
         }
         
         boolean relevant = false;
         for(int j = 0; j < kidTypes.length && !relevant; j++) relevant = type.equals(kidTypes[j]);

         if(relevant) parent.addChild(constructHGObject(mlKids, i));
      }
      
      // post-processing of HG objects to coalesce plots and deal with a polar graph...
      parent.afterChildrenAdded();
   }

   /** These Handle Graphic object types will be parsed if they are children of a "figure" object. */
   private static final String[] FIGUREKIDS = new String[] {
      "axes", "matlab.graphics.axis.PolarAxes", "scribe.legend", "scribe.colorbar"
   };
   /** These Handle Graphic object types will be parsed if they are children of a "axes" object. */
   private static final String[] AXESKIDS = new String[] {
      "graph2d.lineseries", "specgraph.errorbarseries", "specgraph.scattergroup", "histogram", "specgraph.stairseries", 
      "specgraph.barseries", "specgraph.baseline", "specgraph.areaseries", "specgraph.stemseries", 
      "graph3d.surfaceplot", "specgraph.contourgroup", "patch", "surface", "image", "line", "text"
   };
   /** These Handle Graphic object types will be parsed if they are children of a "polaraxes" object. */
   private static final String[] POLARAXESKIDS = new String[] {
      "graph2d.lineseries", "specgraph.scattergroup", "histogram", "text"
   };
   /** These Handle Graphic object types will be parsed if they are children of a "scribe.colorbar" object. */
   private static final String[] COLORBARKIDS = new String[] {"text"};
   /** These Handle Graphic object types will be parsed if they are children of a "specgraph.barseries" object. */
   private static final String[] BAR_AREAKIDS = new String[] {"patch"};

   /**
    * Get the value of the "type" field in the <i>n</i>-th element of a Matlab structure array defining a set of Handle
    * Graphics objects.
    * 
    * @param hgs A Matlab structure array defining one or more HG objects. The array should contain the named field
    * "type", the value of which should be a Matlab character array.
    * @param idx The zero-based array index <i>n</i>.
    * @return The HG object type, or null if "type" field is missing or invalid.
    */
   private static String getHGType(MLStructure hgs, int idx) 
   {
      String type = null;
      if(hgs != null)
      {
         MLArray typeAr = hgs.getField("type", idx);
         if(typeAr != null && typeAr.isChar()) type = ((MLChar) typeAr).getString(0);
      }
      return(type);
   }
   
   /**
    * Get the value of the "handle" field in the <i>n</i>-th element of a Matlab structure array defining a set of 
    * Handle Graphics objects.
    * 
    * @param hgs A Matlab structure array defining one or more HG objects. The array should contain the named field
    * "handle", the value of which should be a scalar double
    * @param idx The zero-based array index <i>n</i>.
    * @return The HG object handle, or 0 if "handle" field is missing or invalid.
    */
   private static double getHGHandle(MLStructure hgs, int idx)
   {
      double handle = 0; 
      if(hgs != null)
      {
         MLArray handleAr = hgs.getField("handle", idx);
         if(handleAr != null && handleAr.isDouble()) handle = ((MLDouble) handleAr).get(0);
      }
      return(handle);
   }
   
   /**
    * Get the value of the "properties" field in the <i>n</i>-th element of a Matlab structure array defining a set of 
    * Handle Graphics objects.
    * 
    * @param hgs A Matlab structure array defining one or more HG objects. The array should contain the named field
    * "properties", the value of which should be a 1x1 Matlab structure array.
    * @param idx The zero-based array index <i>n</i>.
    * @return The HG object's properties, or null if "properties" field is missing or invalid.
    */
   private static MLStructure getHGProperties(MLStructure hgs, int idx)
   {
      MLStructure mlProps = null;
      if(hgs != null)
      {
         MLArray propsAr = hgs.getField("properties", idx);
         int[] dims = propsAr != null ? propsAr.getDimensions() : null;
         if(propsAr != null && propsAr.isStruct() && dims != null && dims.length == 2 && dims[0] == 1 && dims[1] == 1)
            mlProps = (MLStructure) propsAr;
      }
      return(mlProps);
   }

   /**
    * Get the value of the "children" field in the <i>n</i>-th element of a Matlab structure array defining a set of 
    * Handle Graphics objects.
    * 
    * @param hgs A Matlab structure array defining one or more HG objects. The array should contain the named field
    * "handle", the value of which should be a scalar double
    * @param idx The zero-based array index <i>n</i>.
    * @return The HG object's array of children, or null if "children" field is missing or invalid. <i>May return null 
    * or an empty structure array if the parent HG object has no children.</i>
    */
   private static MLStructure getHGChildren(MLStructure hgs, int idx)
   {
      MLStructure mlKids = null;
      if(hgs != null)
      {
         MLArray kidsAr = hgs.getField("children", idx);
         if(kidsAr != null && kidsAr.isStruct() && (kidsAr.isEmpty() || isVector(kidsAr)))
            mlKids = (MLStructure) kidsAr;
      }
      return(mlKids);
   }

   /**
    * Is the Matlab array a vector (1D array)? A Matlab vector has two dimensions, one of which is length 1. Note that
    * an empty array is not considered a vector.
    * @param mlArray The candidate Matlab array.
    * @return True iff the array is not null, not empty, and has exactly two dimensions, at least one of which == 1.
    */
   private static boolean isVector(MLArray mlArray)
   {
      if(mlArray == null || mlArray.isEmpty()) return(false);
      int[] dims = mlArray.getDimensions();
      return(dims != null && dims.length == 2 && (dims[0] == 1 || dims[1] == 1));
   }
   
   /**
    * Get the handles assigned to the "text" children of a Matlab "axes" or "scribe.colorbar" (which is really just a 
    * special-purpose "axes") that correspond to its X-axis label, Y-axis label, or title.
    * 
    * <p>The conversion function {@link MatlabUtilities#matFigToFyp(HGObject, double, StringBuffer, boolean)} needs
    * these handles so that it treats those particular child objects correctly during the conversion. The handles are
    * located in the "special" field of the Matlab "axes" or "scribe.colorbar" HG object. This field should be a 
    * double-valued 4-vector containing the child handles in order: title, X-axis label, Y-axis label, Z-axis label.</p>
    * 
    * @param hgs A Matlab structure array containing the definition of a Matlab "axes" or "scribe.colorbar" object, 
    * among possible other HG objects.. The array should contain the named field "special", the value of which should be
    * as described above.
    * @param idx The zero-based array index identifying which element in the structure array contains the "axes" or 
    * "scribe.colorbar" object of interest.
    * @return A 4-element array [hTitle, hXLabel, hYLabel, hZLabel] holding the requested object handles. If the 
    * "special" fiel is missing or invalid, returns [0, 0, 0, 0].
    */
   private static double[] getHGLabelChildHandles(MLStructure hgs, int idx)
   {
      double[] handles = new double[] {0, 0, 0, 0};
      if(hgs != null)
      {
         MLArray specialAr = hgs.getField("special", idx);
         if(specialAr != null && specialAr.isDouble() && specialAr.getSize() == 4)
         {
            MLDouble specialDAr = (MLDouble) specialAr;
            int[] childIndices = new int[4];
            childIndices[0] = specialDAr.get(0).intValue() - 1;   // Convert 1-based Matlab to 0-based indices!!
            childIndices[1] = specialDAr.get(1).intValue() - 1;
            childIndices[2] = specialDAr.get(2).intValue() - 1;
            childIndices[3] = specialDAr.get(3).intValue() - 1;

            MLStructure mlKids = getHGChildren(hgs, idx);
            if(mlKids != null) for(int i=0; i<4; i++)
            {
               if(childIndices[i] >= 0 && childIndices[i] < mlKids.getSize()) 
                  handles[i] = getHGHandle(mlKids, childIndices[i]);
            }
         }
      }
      return(handles);
   }
   
   /**
    * Parse the properties of a Handle Graphics object which are needed to import a Matlab figure to its FypML
    * equivalent. The set of properties processed are a small subset of the universe of Matlab HG object properties,
    * and they vary with the particular HG object peing processed.
    * 
    * @param hgo The <code>HGObject</code> under construction.
    * @param mlProps The Matlab structure whose fields represent the <i>explicitly defined</i> properties of that HG 
    * object. Supported properties not included in the structure typically take on default values. See Matlab Handle
    * Graphics documentation for the details.
    */
   private static void processProperties(HGObject hgo, MLStructure mlProps)
   {
      // get the list of properties we support for the given HG object type. If type not supported, fail.
      String[] relevantProps;
      String type = hgo.getType();
      switch(type)
      {
      case "figure":
         relevantProps = FIGUREPROPS;
         break;
      case "scribe.legend":
         relevantProps = LEGENDPROPS;
         break;
      case "scribe.colorbar":
         relevantProps = COLORBARPROPS;
         break;
      case "axes":
         relevantProps = AXESPROPS;
         break;
      case "matlab.graphics.axis.PolarAxes":
         relevantProps = POLARAXESPROPS;
         break;
      case "graph2d.lineseries":
      case "specgraph.stairseries":
         relevantProps = LINESERIESPROPS;
         break;
      case "specgraph.errorbarseries":
         relevantProps = EBARSERIESPROPS;
         break;
      case "specgraph.scattergroup":
         relevantProps = SCATTERPROPS;
         break;
      case "specgraph.stemseries":
         relevantProps = STEMPROPS;
         break;
      case "specgraph.barseries":
         relevantProps = BARSERIESPROPS;
         break;
      case "specgraph.baseline":
         relevantProps = BASELINEPROPS;
         break;
      case "specgraph.areaseries":
         relevantProps = AREASERIESPROPS;
         break;
      case "specgraph.contourgroup":
         relevantProps = CONTOURPROPS;
         break;
      case "patch":
         relevantProps = PATCHPROPS;
         break;
      case "histogram":
         relevantProps = HISTOGRAMPROPS;
         break;
      case "graph3d.surfaceplot":
      case "surface":
      case "image":
         relevantProps = SURFACEPROPS;
         break;
      case "line":
         relevantProps = LINEPROPS;
         break;
      case "text":
         relevantProps = TEXTPROPS;
         break;
      default:
         return;
      }
      
      // find all relevant properties in the properties structure provided. Convert each property object to the
      // appropriate Java type. If a property is not found, it is assumed to be implicit.
      for(String propName : relevantProps)
      {
         MLArray propAr = mlProps.getField(propName);

         if(propAr != null) hgo.putProperty(propName, convertHGProperty(propAr));
         else if(type.equals("line") && (propName.equals("XData") || propName.equals("YData")))
         {
            // special case: For a "line" object, default (implicit) value for "XData" and "YData" properties is [0 1].
            hgo.putProperty(propName, new double[] {0, 1});
         }
      }

      // special case: if a figure contains just one axes, 'Position' may not be specified. In this case, simply set 
      // this property manually to [0.15 0.15 0.7 0.7] so that the axes fills up most of the figure
      if(type.equals("axes") && mlProps.getField("Position") == null)
      {
         hgo.putProperty("Position", new double[] {0.15, 0.15, 0.7, 0.7});
         hgo.putProperty("Units", "normalized");
      }
      
      // special case: For an 'axes', the handle of an associated 'scribe.legend' object is buried in the property
      // 'ApplicationData', in the field 'LegendPeerHandle'. If we find this field, we put it directly as a property of 
      // the HGObject representing the 'axes'. MatlabUtilities.matFigToFyp() relies upon this to find find the 
      // 'scribe.legend' object attached to an 'axes'.
      // Analogously for the handle of an associated 'scribe.colorbar', which is in field 'ColorbarPeerHandle' of the
      // 'axes' object's 'ApplicationData' property.
      // (28feb2018) It appears that, like the new 'polaraxes' object (see below), the two peer handles are now stored
      // in a vector array in 'ApplicationData.LayoutPeers'. We check for both scenarios.
      if(type.equals("axes"))
      {
         MLArray appData = mlProps.getField("ApplicationData");
         int[] dims = (appData != null) ? appData.getDimensions() : null;
         if(dims != null && dims.length == 2 && dims[0] == 1 && dims[1] == 1 && appData.isStruct())
         {
            MLArray peerAr = ((MLStructure) appData).getField("LegendPeerHandle");
            if(peerAr != null && peerAr.isDouble() && peerAr.getSize() == 1)
               hgo.putProperty("LegendPeerHandle", ((MLDouble) peerAr).get(0));
            
            peerAr = ((MLStructure) appData).getField("ColorbarPeerHandle");
            if(peerAr != null && peerAr.isDouble() && peerAr.getSize() == 1)
               hgo.putProperty("ColorbarPeerHandle", ((MLDouble) peerAr).get(0));
            
            peerAr = ((MLStructure) appData).getField("LayoutPeers");
            if(peerAr != null && peerAr.isDouble() && peerAr.getSize() > 0)
            {
               MLDouble peerDbl = (MLDouble) peerAr;
               double[] peers = new double[peerDbl.getSize()];
               for(int i=0; i<peers.length; i++) peers[i] = peerDbl.get(i);
               hgo.putProperty("LayoutPeers", peers);
            }
         }
      }
      
      // special case: For the 'polaraxes' object (introduced in R2016a), the legend and/or colorbar peer handles are
      // instead stored in a vector array in 'ApplicationData.LayoutPeers'. If we find this field, we put it directly 
      // as a property of the HGObject representing the 'polaraxes'.
      // (14aug2018) When a 'polaraxes' object is saved to a FIG file, its 'Title' property is not preserved -- so 
      // we cannot get the title string and color. Matfig2fyp() has access to the 'Title' property because it runs in
      // the Matlab environment, and it stores the string and color as named properties 'Title_Str' and 'Title_Color'.
      // As a workaround, if SAVEFIGASIS is used to save the FIG file, the title string and color are stored in a 1x2
      // cell array in the 'UserData' field, which is preserved in the FIG file. Here we check for and process the
      // 'UserData' field and set up the 'Title_Str' and 'Title_Color' properties accordingly.
      if(type.equals("matlab.graphics.axis.PolarAxes"))
      {
         MLArray appData = mlProps.getField("ApplicationData");
         int[] dims = (appData != null) ? appData.getDimensions() : null;
         if(dims != null && dims.length == 2 && dims[0] == 1 && dims[1] == 1 && appData.isStruct())
         {
            MLArray peerAr = ((MLStructure) appData).getField("LayoutPeers");
            if(peerAr != null && peerAr.isDouble() && peerAr.getSize() > 0)
            {
               MLDouble peerDbl = (MLDouble) peerAr;
               double[] peers = new double[peerDbl.getSize()];
               for(int i=0; i<peers.length; i++) peers[i] = peerDbl.get(i);
               hgo.putProperty("LayoutPeers", peers);
            }
         }
         
         MLArray userData = mlProps.getField("UserData");
         if(userData != null && userData.isCell() && userData.getM() == 1 && userData.getN() == 2)
         {
            MLCell cellAr = (MLCell) userData;
            boolean ok = (cellAr.get(0).isChar()) && (cellAr.get(0).isEmpty() || cellAr.get(0).getM() == 1);
            if(ok) 
            {
               hgo.putProperty("Title_Str", ((MLChar) cellAr.get(0)).getString(0));
               hgo.putProperty("Title_Color", convertHGProperty(cellAr.get(1)));
            }
         }
      }
      
      // special case: For selected plot objects, if an entry for the object is included in a 'scribe.legend' associated
      // with the parent axes, then the plot object's 'ApplicationData' property will have a double-valued field called 
      // 'legend_texthandle' (undocumented feature). If we find this field, we put it directly as a property of the 
      //  HGObject representing the plot object. MatlabUtilities.matFigToFyp() may check this property when deciding
      // whether or not to set the corresponding FypML trace's "showInLegend" attribute.
      if(type.equals("graph2d.lineseries") || type.equals("specgraph.errorbarseries")
            || type.equals("specgraph.scattergroup") || type.equals("patch") || type.equals("specgraph.stairseries")
            || type.equals("specgraph.barseries") || type.equals("specgraph.areaseries")
            || type.equals("specgraph.stemseries") || type.equals("histogram"))
      {
         MLArray appData = mlProps.getField("ApplicationData");
         int[] dims = (appData != null) ? appData.getDimensions() : null;
         if(dims != null && dims.length == 2 && dims[0] == 1 && dims[1] == 1 && appData.isStruct())
         {
            MLArray lphAr = ((MLStructure) appData).getField("legend_texthandle");
            if(lphAr != null && lphAr.isDouble() && lphAr.getSize() == 1)
               hgo.putProperty("legend_texthandle", ((MLDouble) lphAr).get(0));
         }
      }
   }
   
   /** Imported properties of a Matlab "figure" object. */
   private static final String[] FIGUREPROPS = new String[] {"Colormap", "Name", "PaperUnits", "PaperPosition"};
   /** Imported properties of a Matlab "scribe.legend" object. */
   private static final String[] LEGENDPROPS = new String[] {"TextColor", "Position", "Units", "NumColumns", "String",
         "FontName", "FontSize", "FontUnits", "FontWeight", "FontAngle", "Color", "Box", "LineWidth"};
   /** 
    * Imported properties of a Matlab "scribe.colorbar" object. <i>NOTE: This object was considered a specialized
    * 'axes' object prior to Matlab release 2014b. For 2014b and higher, it is distinct object type with only those
    * properties that are relevant. It has no 'text' children; any text label is in the 'Label' property, but its value
    * is a Matlab text object primitive and we cannot read that from a FIG file.</i>
    */
   private static final String[] COLORBARPROPS = new String[] {
      "Color", "FontAngle", "FontName", "FontSize", "FontUnits", "FontWeight", "Limits", "LineWidth", "Location", 
      "Position", "TickDir", "TickLength", "Visible", "XColor", "YColor", "XTick", "YTick", "TickDirection", "Ticks",
      "Units", "UserData"
   };
   /**
    * Imported properties of a Matlab "axes" object. 
    * <p><b>NOTE</b>. Matlab 2014b incorrectly saves property 'XTickLabelMode' as 'XTickLabelsMode'. VERY ANNOYING; now
    * we check for both properties to decide whether or not to use 'XTickLabel'. Same for 'YTickLabel(s)Mode' and
    * for 'ZTickLabel(s)Mode'!</p>
    */
   private static final String[] AXESPROPS = new String[] {
      "CLim", "FontAngle", "FontName", "FontSize", "FontUnits", "FontWeight", "LabelFontSizeMultiplier", 
      "LineWidth", "GridLineStyle", "GridColor", "Position", "PlotBoxAspectRatio", 
      "PlotBoxAspectRatioMode", "DataAspectRatioMode", "TickDir", "TickLength", "Units", "Visible", "XAxisLocation", 
      "YAxisLocation", "XColor", "YColor", "XDir", "YDir", "XGrid", "YGrid", "XLim", "YLim", "XScale", "YScale", 
      "XTick", "YTick", "XMinorTick", "YMinorTick", "XTickLabelMode", "XTickLabelsMode", "XTickLabel", "YTickLabelMode", 
      "YTickLabelsMode", "YTickLabel",
      "View", "CameraUpVector", "Projection", "Color", "Box", "BoxStyle",
      "ZLim", "ZScale", "ZGrid", "ZTick", "ZMinorTick", "ZTickLabelMode", "ZTickLabelsMode", "ZTickLabel"
   };
   /**
    * Imported properties of a Matlab "polaraxes" object (first introduced in Matlab R2016a.
    */
   private static final String[] POLARAXESPROPS = new String[] {
      "CLim", "Color", "FontAngle", "FontName", "FontSize", "FontUnits", "FontWeight", "LineWidth", "GridAlpha", 
      "GridColor", "GridLineStyle", "Position", "RAxisLocation", "RColor", "RDir", "RGrid", "RLim", "RTick", 
      "RTickLabel", "RTickLabelMode", "ThetaAxisUnits", "ThetaColor", "ThetaDir", "ThetaGrid", "ThetaLim", "ThetaTick", 
      "ThetaTickLabel", "ThetaTickLabelMode", "ThetaZeroLocation", "TitleFontWeight", "TitleFontSizeMultiplier", 
      "Units", "Visible"
   };
   /** Imported properties of a Matlab "graph2d.lineseries" or "specgraph.stairseries" object. */
   private static final String[] LINESERIESPROPS = new String[] {
      "Color", "DisplayName", "LineStyle", "LineWidth", "Marker", "MarkerEdgeColor", "MarkerFaceColor", "MarkerSize", 
      "XDataMode", "XData", "YData", "ZData"
   };
   /** Imported properties of a Matlab "specgraph.errorbarseries" object. */
   private static final String[] EBARSERIESPROPS = new String[] {
      "CapSize", "Color", "DisplayName", "LData", "LineStyle", "LineWidth", "Marker", "MarkerEdgeColor", 
      "MarkerFaceColor", "MarkerSize", "UData", "XDataMode", "XData", "XNegativeDelta", "XPositiveDelta", 
      "YData", "YNegativeDelta", "YPositiveDelta"
   };
   /** Imported properties of a Matlab "specgraph.scattergroup" object. */
   private static final String[] SCATTERPROPS = new String[] {
      "CData", "DisplayName", "LineWidth", "Marker", "MarkerEdgeAlpha", "MarkerEdgeColor", 
      "MarkerFaceAlpha", "MarkerFaceColor", "SizeData", "XData", "YData", "ZData"
   };
   /** Imported properties of a Matlab "specgraph.stemseries" object. */
   private static final String[] STEMPROPS = new String[] {
      "BaseValue", "Color", "DisplayName", "LineWidth", "LineStyle", "Marker", "MarkerEdgeColor", "MarkerFaceColor", 
      "MarkerSize", "XData", "YData", "ZData"
   };
   /** Imported properties of a Matlab "specgraph.barseries" object. */
   private static final String[] BARSERIESPROPS = new String[] {
      "BarLayout", "BarWidth", "BaseValue", "CDataMapping", "DisplayName", "EdgeAlpha", "EdgeColor", 
      "FaceAlpha", "FaceColor", "Horizontal", "LineStyle", "LineWidth", "XDataMode", "XData", "YData"
   };
   /** Imported properties of a Matlab "specgraph.baseline" object. */
   private static final String[] BASELINEPROPS = new String[] {
      "BaseValue", "Color", "LineStyle", "LineWidth", "Visible"
   };
   /** Imported properties of a Matlab "specgraph.areaseries" object. */
   private static final String[] AREASERIESPROPS = new String[] {
      "BaseValue", "CDataMapping", "DisplayName", "EdgeAlpha", "EdgeColor", "FaceAlpha", "FaceColor", 
      "LineStyle", "LineWidth", "XDataMode", "XData", "YData", "YCoords"
   };
   /** Imported properties of a Matlab "patch" object. */
   private static final String[] PATCHPROPS = new String[] {
      "CDataMapping", "DisplayName", "EdgeColor", "FaceColor", "FaceAlpha", "Faces", "FaceVertexCData", "LineStyle", 
      "LineWidth", "UserData", "Vertices"
   };
   /** Imported properties of a Matlab "histogram" object. */
   private static final String[] HISTOGRAMPROPS = new String[] {
      "BinEdges", "BinWidth", "Data", "DisplayName", "DisplayStyle", "EdgeColor", "EdgeAlpha", "FaceColor", "FaceAlpha", 
      "LineWidth", "LineStyle", "Normalization", "Orientation", "Visible"
   };
   /** Imported properties of a Matlab "specgraph.contourgroup" object, which is translated to a FypML contour node. */
   private static final String[] CONTOURPROPS = new String[] {
      "DisplayName", "Fill", "LevelList", "LineColor", "LineWidth", "LineStyle", "XData", "YData", "ZData"
   };
   /** 
    * Imported properties of a Matlab "surface", "image" or "graph3d.surfaceplot" object. In a 2D graph container, the
    * first two objects will be converted to a FypML contour node in the heatmap display mode. In a 3D graph, the 
    * "graph3d.surfaceplot" is translated to a FypML 3D surface node, while a "surface" may be converted to a FypML
    * 3D scatter node in one of its bar plot display modes -- but only if that Matlab surface is configured to render 
    * 3D bars, as generated by the <i>bar3()</i> function. NOTE: Not all of these properties are applicable to the 
    * different use cases.
    */
   private static final String[] SURFACEPROPS = new String[] {
      "CData", "CDataMapping", "DisplayName", "EdgeAlpha", "EdgeColor", "FaceAlpha", "FaceColor", "LineStyle", 
      "LineWidth", "XData", "YData", "ZData"
   };
   /** Imported properties of a Matlab "line" object. */
   private static final String[] LINEPROPS = new String[] {
      "Color", "DisplayName", "LineStyle", "LineWidth", "Marker", "MarkerEdgeColor", "MarkerFaceColor", "MarkerSize", 
      "XData", "YData"
   };
   /** Imported properties of a Matlab "text" object. */
   private static final String[] TEXTPROPS = new String[] {
      "Color", "DisplayName", "FontAngle", "FontName", "FontSize", "FontUnits", "FontWeight", "HorizontalAlignment", 
      "Position", "Rotation", "String", "Units", "VerticalAlignment"
   };
   
   /**
    * Analyze the specified property value and convert it from a Matlab array ({@link com.jmatio.types.MLArray}) to one
    * of the following Java object value types: a simple string or single character; an array of strings; a scalar 
    * floating-point value; a 1D or 2D floating-point array. All Matlab Handle Graphics properties that are processed to
    * convert a Matlab figure to a FypML figure will have one of these value types. Note that all floating-point-valued 
    * properties should involve real numbers only.
    * 
    * <p>(15jan2015) Added support for manual tick labels via the 'XTickLabel' and 'YTickLabel' properties of an 'axes'
    * object. Support parsing these properties in either of two formats: a cell array of strings (each cell contains
    * one tick label), or a 2D character matrix (each row is one tick label, padded with blank characters as needed).
    * In both cases, the <code>MLArray</code> is translated into a Java string array, String[].</p>
    * 
    * <p>(02aug2021) Added support for converting single-precision floating-point scalars and 1D/2D arrays. Before this
    * change, FC would not handle property values stored in single-precision.</p>
    * 
    * @param propAr The property value as a generic Matlab array.
    * @return The property value as a {@link String}, String[], {@link Double}, double[], or double[][].
    */
   private static Object convertHGProperty(MLArray propAr)
   {
      if(propAr == null) return(null);
      Object out = null;
      
      
      if(propAr.isChar() && propAr.getNDimensions() == 2 && propAr.getSize() > 0)
      {
         // (note that we ignore empty character matrices!)
         MLChar mlChar = (MLChar) propAr;
         
         // handle 1D character array (convert to String) or 2D char matrix (convert to String[]). NOTE that 1D array
         // could be a row- or column-vector!
         if(mlChar.getM() == 1)
            out = mlChar.getString(0);
         else if(mlChar.getN() == 1)
         {
            StringBuilder sb = new StringBuilder();
            for(int i=0; i<mlChar.getM(); i++) sb.append(mlChar.getChar(i, 0));
            out = sb.toString();
         }
         else
         {
            String[] strAr = new String[propAr.getM()];
            for(int i=0; i<strAr.length; i++) strAr[i] = ((MLChar) propAr).getString(i);
            out = strAr;
         }
      }
      else if(propAr.isCell())
      {
         // handle cell array if all cells are 1D character arrays
         MLCell cellAr = (MLCell) propAr;
         boolean ok = (cellAr.getM() == 1 || cellAr.getN() == 1);
         for(int i=0; ok && i<cellAr.getSize(); i++) 
            ok = cellAr.get(i).isChar() && (cellAr.get(i).isEmpty() || cellAr.get(i).getM() == 1);
         if(ok)
         {
            String[] strAr = new String[cellAr.getSize()];
            for(int i=0; i<strAr.length; i++) strAr[i] = ((MLChar) cellAr.get(i)).getString(0);
            out = strAr;
         }
      }
      else if(propAr.isDouble())
      {
         MLDouble dblAr = (MLDouble) propAr;
         int[] dims = dblAr.getDimensions();
         if(dims.length != 2) return(null);
         if(dims[0] == 1 && dims[1] == 1)
            out = dblAr.getReal(0);
         else if(dims[0] == 1 || dims[1] == 1)
         {
            double[] d = new double[dblAr.getSize()];
            for(int i=0; i<dblAr.getSize(); i++) d[i] = dblAr.getReal(i);
            out = d;
         }
         else
            out = dblAr.getArray();
      }
      else if(propAr.isSingle())
      {
         MLSingle sglAr = (MLSingle) propAr;
         int[] dims = sglAr.getDimensions();
         if(dims.length != 2) return(null);
         if(dims[0] == 1 && dims[1] == 1)
            out = sglAr.getReal(0).doubleValue();
         else if(dims[0] == 1 || dims[1] == 1)
         {
            double[] d = new double[sglAr.getSize()];
            for(int i=0; i<sglAr.getSize(); i++) d[i] = sglAr.getReal(i).doubleValue();
            out = d;
         }
         else
         {
            double[][] result = new double[sglAr.getM()][];
            
            for(int m = 0; m < sglAr.getM(); m++)
            {
               result[m] = new double[ sglAr.getN() ];
               for(int n = 0; n < sglAr.getN(); n++)
               {               
                   result[m][n] = sglAr.getReal(m,n).doubleValue();
               }
            }
            out = result;
         }
      }
      
      return(out);
   }
}
