package com.srscicomp.fc.fig;

import java.awt.Graphics2D;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.NoSuchElementException;

import com.srscicomp.common.g2dutil.CircularArcPainter;
import com.srscicomp.common.g2dutil.Painter;
import com.srscicomp.common.g2dutil.PolylinePainter;
import com.srscicomp.common.g2dviewer.RenderTask;
import com.srscicomp.common.util.Utilities;
import com.srscicomp.fc.data.DataSet;
import com.srscicomp.fc.data.DataSet.Fmt;

/**
 * <b>RasterNode</b> is the <b><i>presentation</i></b> element for the one-dimensional data set format {@link 
 * Fmt#RASTER1D RASTER1D}; it is applicable only to data sets in this format. It subclasses {@link
 * FGNPlottableData}, which manages the actual data set source.
 * 
 * <p>A <b>RASTER1D</b> data set is typically a collection of many individual rasters, each of which will have a 
 * different number of samples. Each raster sample is a primary coordinate value (x or theta). In the neuroscience 
 * arena, it is the data set of choice for representing neural spike trains recorded over a set of repeated trials; in 
 * this case, each "sample" is the arrival time of a single spike.</p>
 * 
 * <p><b>RasterNode</b> supports seven alternate display modes. In two of them -- "trains" and "trains2" -- the data is 
 * shown as a series of "spike trains", where each train corresponds to a single raster in the collection and a single 
 * sample in a raster is represented by a short vertical hash mark, or "spike" (the modes are different in how the 
 * vertical spacing between trains in specified).</p>
 * 
 * <p>The other display modes render the data as a histogram and are suitable for any kind of 1D sampled data, not 
 * necessarily "spike trains". The original "histogram" display mode renders samples/bin across the raster samples in 
 * the data set. The height of each bar in the histogram reflects the number of samples in the corresponding bin -- or 
 * average samples per bin per raster (dividing by the number of rasters in the data set) -- depending on the state of 
 * the boolean property, {@link #getAveraged()}. Alternatively, in the "normhist" display mode, each histogram bar
 * reflects the normalized count per bin: (#samples in bin) / (#total samples), i.e., the relative probability that a
 * given sample will reside in a given bin. The "pdf" display mode renders a histogram that is an estimate of the 
 * sampled data's probability density function, while the "cdf" mode offers an estimate of its cumulative density 
 * function.</p>.
 * 
 * <p>The "pdf" and "cdf" display modes were added in V5.0.2, along with an additional property that explicitly 
 * specifies the histogram sample range [S..E], i.e., the limits over which the raster sample data is binned to form the
 * histogram. Previously, the bin limits were always the actual observed sample range, and this is still the case when
 * S >= E. Control over the sample ranges lets you omit some outliers without altering the original sample set, or force
 * the histogram to span a certain range for comparison with another histogram in the same graph. This also makes it
 * possible to import a histogram generated by the Matlab <i>histogram()</i> function into FypML. The "normhist" mode
 * was added in V5.2.1.</p>
 * 
 * <p>See {@link DisplayMode} for a further explanation of each of the display modes, as well as the properties of the 
 * <b>RasterNode</b> that affect the rendering of the underlying data set in these different modes.</p>
 * 
 * @author sruffner
 */
public class RasterNode extends FGNPlottableData implements Cloneable
{
   /**
    * Construct a raster node initially configured to display an empty raster collection in "trains" mode. It will make
    * no marks in the parent graph. Initially, the raster line height is set to 1 and the inter-line spacer to 3 (in 
    * stroke-width units), the x-coordinate offset and y-coordinate baseline are zero (user units), and the number of 
    * histogram bins is set to 10. All styling attributes are initially implicit (inherited); no font-related styles are
    * associated with this node. It has no title initially.
    */
   public RasterNode()
   {
      super(HASFILLCATTR|HASSTROKEATTRS|HASSTRKPATNATTR|HASTITLEATTR|ALLOWATTRINTITLE);
      setTitle("");
      mode = DisplayMode.TRAINS;
      xOffset = baseline = 0;
      lineHeight = 1;
      lineSpacer = 3;
      numBins = 10;
   }

   //
   // Support for child nodes -- none permitted!
   //
   
   @Override public FGNodeType getNodeType() { return(FGNodeType.RASTER); }


   //
   // Properties
   //

   /** An enumeration of the different data display modes supported by <code>RasterNode</code>. */
   public enum DisplayMode
   {
      /** 
       * The traditional rendering of "time-stamped events" as a series of vertically spaced "raster trains". The 
       * underlying data set is typically a collection of many individual rasters, each having a different number of 
       * "events". In this display mode, each individual raster is drawn as a train of short vertical lines sharing a 
       * common baseline in the secondary coordinate. The raster sample values and the x-coordinate offset determine the
       * placement of the marks along the primary coordinate axis. The baseline attribute defines the location of the
       * first raster train along the secondary coordinate axis, while the spacer attribute defines the inter-train 
       * spacing. Stroke width, stroke color, and raster line height govern the appearance of the individual raster 
       * train hash marks.
       */
      TRAINS, 
      
      /**
       Similar to {@link DisplayMode#TRAINS} mode, but the spacer attribute is ignored and the baseline of each 
       individual raster is its ordinal position (starting at 0) in the raster collection, offset by the value of the 
       baseline attribute. Thus, the positioning of the raster lines is tied to the V axis of the parent graph.
       */
      TRAINS2,
      
      /**
       * A "counts-per-bin" histogram is computed from the underlying raster data. The raster sample range [S..E] is 
       * divided into <i>N</i> equal bins, and the number of counts in each bin is accumulated. The resulting histogram 
       * is rendered in the parent graph's viewport. Each histogram bar spans the calculated bin width. The bin value is
       * the total or average count for that bin, depending on the state of the <i>avg</i> flag; in the latter case, the
       * total count is divided by the number of individual rasters in the collection. The histogram is drawn IAW the
       * node's style attributes. It may be offset vertically by a non-zero <i>baseline</i> property and horizontally 
       * by the <i>XOffset</i> property. In a polar graph context (rare usage!), the bars become circular pie wedges or 
       * radial sections. The raster sample range [S..E] may be explicitly set by the user. If S >= E, this range is
       * ignored and the actual observed sample range is used.
       */
      HISTOGRAM,
      
      /**
       * Same as {@link #HISTOGRAM}, but the height of each histogram bar is C / T, where C is the number of samples in
       * the corresponding bin and T is the total number of samples across the sample range. Thus, each bar represents
       * the relative probability of a sample falling within the corresponding bin. The <i>avg</i> flag is ignored.
       */
      NORMHIST,
      
      /** 
       * Same as {@link DisplayMode#HISTOGRAM}, but the height of each histogram bar is C / (T*W), where C is the number
       * of samples in the corresponding bin, T is the total number of samples across the sample range [S..E], and W is 
       * the computed bin width. The <i>avg</i> flag is ignored. This provides an approximate representation of the 
       * data's probability density function.
       */
      PDF,
      
      /** 
       * Same as {@link DisplayMode#PDF}, except that the histogram bar height = S / T, where S is the total number of 
       * samples in the corresponding bin <i>and all precediing bins</i> and T is the total number of samples across the
       * sample range [S..E]. The <i>avg</i> flag is ignored. Observe that the last bar will have a height of T/T = 1. 
       * This provides an approximate representation of the data's cumulative density function.
       */
      CDF; 
      
      @Override
      public String toString() { return(super.toString().toLowerCase()); }
   }

   /** The current data display mode. */
   private DisplayMode mode;

   /**
    * Get the current data display mode for this raster node.
    * @return The current data display mode.
    */
   public DisplayMode getMode() { return(mode); }

   /**
    * Set the data display mode for this raster node. If a change is made, {@link #onNodeModified()} is invoked.
    * @param mode The new display mode. Null is rejected.
    * @return True if new value was accepted; false otherwise.
    */
   public boolean setMode(DisplayMode mode)
   {
      if(mode == null) return(false);
      if(this.mode != mode)
      {
         if(doMultiNodeEdit(FGNProperty.MODE, mode)) return(true);
         
         DisplayMode oldMode = this.mode;
         this.mode = mode;
         if(areNotificationsEnabled())
         {
            onNodeModified(FGNProperty.MODE);
            FGNRevEdit.post(this, FGNProperty.MODE, mode, oldMode);
         }
      }
      return(true);
   }

   /** An X-coordinate offset (or theta in a polar context!). */
   private float xOffset;

   /**
    * Get the X-coordinate offset. This essentially offsets the rendered raster trains or histogram along the primary
    * axis of the parent graph.
    * @return The X-coordinate offset value, in "user" units.
    */
   public float getXOffset() { return(xOffset); }
   
   /**
    * Set the X-coordinate offset. If a change is made, {@link #onNodeModified()} is invoked.
    * @param xoff A new value for the X-coordinate offset. NaN and +/-infinity are rejected.
    * @return True if new value was accepted; false otherwise.
    */
   public boolean setXOffset(float xoff) 
   {
      if(!Utilities.isWellDefined(xoff)) return(false);
      if(xOffset != xoff)
      {
         if(doMultiNodeEdit(FGNProperty.XOFF, new Float(xoff))) return(true);
         
         Float old = new Float(xOffset);
         xOffset = xoff;
         if(areNotificationsEnabled())
         {
            onNodeModified(FGNProperty.XOFF);
            FGNRevEdit.post(this, FGNProperty.XOFF, new Float(xOffset), old);
         }
      }
      return(true);
   }

   /** The Y-coordinate baseline, in user units. */
   private float baseline;

   /**
    * Get the Y-coordinate baseline. In the raster train display modes, it serves to locate the baseline of the first 
    * train along the secondary axis of the parent graph. In the various histogram modes, it sets the baseline for the 
    * histogram -- all histogram bars start along this baseline.
    * @return The Y-coordinate baseline, in user units.
    */
   public float getBaseline() { return(baseline); }
    
   /**
    * Set the Y-coordinate baseline. If a change is made, {@link #onNodeModified()} is invoked.
    * @param base The new baseline, in user units. NaN and +/-infinity are rejected.
    * @return True if new value was accepted; false otherwise.
    */
   public boolean setBaseline(float base) 
   {
      if(!Utilities.isWellDefined(base)) return(false);
      if(baseline != base)
      {
         if(doMultiNodeEdit(FGNProperty.BASELINE, new Float(base))) return(true);
         
         Float old = new Float(baseline);
         baseline = base;
         if(areNotificationsEnabled())
         {
            onNodeModified(FGNProperty.BASELINE);
            FGNRevEdit.post(this, FGNProperty.BASELINE, new Float(baseline), old);
         }
      }
      return(true);
   }

   /** Minimum number of bins allowed in any of the histogram display modes. */
   public final static int MINNUMBINS = 2;
   
   /** Maximum number of bins allowed in any of the histogram display modes. */
   public final static int MAXNUMBINS = 500;
   
   /** Number of bins in histogram (applicable to histogram display modes only).*/
   private int numBins;

   /**
    * Get the number of histogram bins (applicable only to the histogram display modes).
    * @return Number of bins.
    */
   public int getNumBins() { return(numBins); }
    
   /**
    * Set the number of histogram bins. If a change is made, {@link #onNodeModified()} is invoked. 
    * 
    * @param n Requested number of bins. Values outside [{@link #MINNUMBINS}, {@link #MAXNUMBINS}] are rejected.
    * @return True if new value was accepted; false otherwise.
    */
   public boolean setNumBins(int n) 
   {
      if(n < MINNUMBINS || n > MAXNUMBINS) return(false);
      if(numBins != n)
      {
         if(doMultiNodeEdit(FGNProperty.NBINS, new Integer(n))) return(true);
         
         Integer old = new Integer(numBins);
         numBins = n;
         if(areNotificationsEnabled())
         {
            onNodeModified(FGNProperty.NBINS);
            FGNRevEdit.post(this, FGNProperty.NBINS, new Integer(numBins), old);
         }
      }
      return(true);
   }

   /** Calculate histogram as total counts-per-bin (false) or average counts per raster per bin. */
   private boolean averaged = true;

   /**
    * In the {@link DisplayMode#HISTOGRAM} display mode only, should each histogram bar reflect the average count per
    * per raster for each bin (total count for the bin divided by the number of individual rasters in the raster 
    * collection), rather than the raw total count per bin across the entire data set?
    * 
    * @return True/false if histogram reflects average/total count per bin in {@link DisplayMode#HISTOGRAM} mode.
    */
   public boolean getAveraged() { return(averaged); }

   /**
    * Select whether or not histogram bar reflects average count per raster per bin or total count per bin in the {@link 
    * DisplayMode#HISTOGRAM} mode only. If a change is made, {@link #onNodeModified()} in invoked.
    * @param b True for average count; false for total count.
    */
   public void setAveraged(boolean b)
   {
      if(b != averaged)
      {
         if(doMultiNodeEdit(FGNProperty.AVG, new Boolean(b))) return;
         
         Boolean old = new Boolean(averaged);
         averaged = b;
         if(areNotificationsEnabled())
         {
            onNodeModified(FGNProperty.AVG);
            FGNRevEdit.post(this, FGNProperty.AVG, new Boolean(averaged), old);
         }
      }
   }

   /** The raster line height, in stroke-width units. Must be 1 or larger. */
   private int lineHeight;

   /**
    * Get the raster line height, ie, the height of each hash mark rendered at each raster sample datum in the relevant
    * display modes.
    * @return Raster line height in stroke-width units.
    */
   public int getLineHeight() { return(lineHeight); }

   /**
    * Set the raster line height. If a change is made, {@link #onNodeModified()} is invoked.
    * @param n The raster line height, in stroke-width units. Rejected if non-positive.
    * @returns True if new value was accepted; false otherwise.
    */
   public boolean setLineHeight(int n)
   {
      if(n < 1) return(false);
      if(lineHeight != n)
      {
         if(doMultiNodeEdit(FGNProperty.HEIGHT, new Integer(n))) return(true);
         
         Integer old = new Integer(lineHeight);
         lineHeight = n;
         if(areNotificationsEnabled())
         {
            onNodeModified(FGNProperty.HEIGHT);
            FGNRevEdit.post(this, FGNProperty.HEIGHT, new Integer(lineHeight), old);
         }
      }
      return(true);
   }

   /** The raster line spacer, in stroke-width units. Must be 1 or larger. */
   private int lineSpacer;

   /**
    * Get the raster line spacer, i.e., the spacer between the baselines of consecutive raster trains -- for the {@link 
    * DisplayMode#TRAINS} mode only.
    * @return Raster line spacer in stroke width units.
    */
   public int getLineSpacer() { return(lineSpacer); }

   /**
    * Set the raster line spacer. If a change is made, {@link #onNodeModified()} is invoked.
    * @param n The raster line spacer, in stroke-width units. Rejected if non-positive.
    * @returns True if new value was accepted; false otherwise.
    */
   public boolean setLineSpacer(int n)
   {
      if(n < 1) return(false);
      if(lineSpacer != n)
      {
         if(doMultiNodeEdit(FGNProperty.SPACER, new Integer(n))) return(true);
         
         Integer old = new Integer(lineSpacer);
         lineSpacer = n;
         if(areNotificationsEnabled())
         {
            onNodeModified(FGNProperty.SPACER);
            FGNRevEdit.post(this, FGNProperty.SPACER, new Integer(lineSpacer), old);
         }
      }
      return(true);
   }

   /** Sample range [S, E] applicable to all histogram-like display modes. */
   private double[] range = new double[] {0, 0};
   
   /**
    * Get the start S of the sample range [S..E] which controls the bar width and overall extent of the rendered 
    * histogram in any of the histogram display modes. Note that bin width will be (E-S)/N, the number of bins as 
    * specified by {@link #getNumBins()}. If S >= E, then the observed sample range will be used instead. Otherwise, any
    * samples that fall outside of [S..E] will not be accounted for in the rendered histogram.
    * 
    * @return Start of histogram sample range.
    */
   public double getHistogramRangeStart() { return(range[0]); }
   /**
    * Get the end E of the histogram sample range [S..E].
    * @return End of histogram sample range.
    * @see #getHistogramRangeStart()
    */
   public double getHistogramRangeEnd() { return(range[1]); }
   
   /**
    * Set the histogram sample range [S..E], which controls the bar width and overall extent of the rendered histogram 
    * in any of the histogram display modes. If a change is made, {@link #onNodeModified()} is invoked. Note that if 
    * S >= E, this range is ignored and the actual observed sample range is used instead.
    * @param s Start of the range, S.
    * @param e End of the range, E.
    * @return True if new range was accepted; false otherwise. Both values must be finite and well-defined.
    * @see #getHistogramRangeStart()
    */
   public boolean setHistogramRange(double s, double e)
   {
      if(!(Utilities.isWellDefined(s) && Utilities.isWellDefined(s))) return(false);
      if(s == range[0] && e == range[1]) return(true);
      if(doMultiNodeEdit(FGNProperty.RANGE, new double[] {s, e})) return(true);

      double[] old = new double[] {range[0], range[1]};
      range[0] = s;
      range[1] = e;
      if(areNotificationsEnabled())
      {
         onNodeModified(FGNProperty.RANGE);
         FGNRevEdit.post(this, FGNProperty.RANGE, new double[] {range[0], range[1]}, old, "Change histogram range");
      }

      return(true);
   }
   
   @Override boolean setPropertyValue(FGNProperty p, Object propValue)
   {
      boolean ok = false;
      switch(p)
      {
         case MODE : ok = setMode((DisplayMode)propValue); break;
         case XOFF: ok = setXOffset((Float)propValue); break;
         case BASELINE: ok = setBaseline((Float)propValue); break;
         case NBINS: ok = setNumBins((Integer)propValue); break;
         case AVG: setAveraged((Boolean)propValue); ok = true; break;
         case HEIGHT: ok = setLineHeight((Integer)propValue); break;
         case SPACER: ok = setLineSpacer((Integer)propValue); break;
         case RANGE: 
            double[] rng = (double[]) propValue;
            ok = setHistogramRange(rng[0], rng[1]);
            break;
         default : ok = super.setPropertyValue(p, propValue); break;
      }
      return(ok);
   }

   @Override Object getPropertyValue(FGNProperty p)
   {
      Object value = null;
      switch(p)
      {
         case MODE : value = getMode(); break;
         case XOFF: value = new Float(getXOffset()); break;
         case BASELINE: value = new Float(getBaseline()); break;
         case NBINS: value = new Integer(getNumBins()); break;
         case AVG: value = new Boolean(getAveraged()); break;
         case HEIGHT: value = new Integer(getLineHeight()); break;
         case SPACER: value = new Integer(getLineSpacer()); break;
         case RANGE : value = new double[] {getHistogramRangeStart(), getHistogramRangeEnd()}; break;
         default : value = super.getPropertyValue(p); break;
      }
      return(value);
   }


   //
   // Support for style sets
   //
   
   @Override public boolean supportsStyleSet() { return(true); }

   /**
    * The node-specific properties exported in a raster node's style set include the display mode, line height and 
    * spacer for raster trains; #bins and average flag for histogram mode; and the include-in-legend flag. Histogram
    * sample range is NOT included.
    */
   @Override protected void putNodeSpecificStyles(FGNStyleSet styleSet)
   {
      styleSet.putStyle(FGNProperty.MODE, getMode());
      styleSet.putStyle(FGNProperty.NBINS, new Integer(getNumBins()));
      styleSet.putStyle(FGNProperty.AVG, new Boolean(getAveraged()));
      styleSet.putStyle(FGNProperty.LEGEND, new Boolean(getShowInLegend()));
      styleSet.putStyle(FGNProperty.HEIGHT, new Integer(getLineHeight()));
      styleSet.putStyle(FGNProperty.SPACER, new Integer(getLineSpacer()));
   }

   @Override protected boolean applyNodeSpecificStyles(FGNStyleSet applied, FGNStyleSet restore)
   {
      boolean changed = false;
      
      DisplayMode dm = (DisplayMode) applied.getCheckedStyle(FGNProperty.MODE, getNodeType(), DisplayMode.class);
      if(dm != null && !dm.equals(restore.getStyle(FGNProperty.MODE)))
      {
         mode = dm;
         changed = true;
      }
      else restore.removeStyle(FGNProperty.MODE);
      
      Integer n = (Integer) applied.getCheckedStyle(FGNProperty.NBINS, getNodeType(), Integer.class);
      if(n != null && (n>=MINNUMBINS) && (n<=MAXNUMBINS) && !n.equals(restore.getStyle(FGNProperty.NBINS)))
      {
         numBins = n.intValue();
         changed = true;
      }
      else restore.removeStyle(FGNProperty.NBINS);
      
      n = (Integer) applied.getCheckedStyle(FGNProperty.HEIGHT, getNodeType(), Integer.class);
      if(n != null && (n >= 1) && !n.equals(restore.getStyle(FGNProperty.HEIGHT)))
      {
         lineHeight = n.intValue();
         changed = true;
      }
      else restore.removeStyle(FGNProperty.HEIGHT);
      
      n = (Integer) applied.getCheckedStyle(FGNProperty.SPACER, getNodeType(), Integer.class);
      if(n != null && (n >= 1) && !n.equals(restore.getStyle(FGNProperty.SPACER)))
      {
         lineSpacer = n.intValue();
         changed = true;
      }
      else restore.removeStyle(FGNProperty.SPACER);
      
      // the next three boolean properties may be specified on various plottable node types and have similar meaning
      Boolean b = (Boolean) applied.getCheckedStyle(FGNProperty.LEGEND, null, Boolean.class);
      if(b != null && !b.equals(restore.getStyle(FGNProperty.LEGEND)))
      {
         setShowInLegendNoNotify(b);
         changed = true;
      }
      else restore.removeStyle(FGNProperty.LEGEND);
      
      b = (Boolean) applied.getCheckedStyle(FGNProperty.AVG, null, Boolean.class);
      if(b != null && !b.equals(restore.getStyle(FGNProperty.AVG)))
      {
         averaged = b.booleanValue();
         changed = true;
      }
      else restore.removeStyle(FGNProperty.AVG);
            
      return(changed);
   }


   // 
   // FGNPlottableData, FGNPlottable
   //
   
   /**
    * Initializes the raster node's data set to include 5 random rasters with samples spanning the range of the graph's
    * X-axis. Other parameters are adjusted as needed to ensure the raster train shows up in the graph's data window.
    */
   @Override protected void initializeDefaultData(double[] axisRng, boolean isPolar)
   {
      float x0 = (float) axisRng[0];
      float x1 = (float) axisRng[1];
      float y0 = (float) axisRng[2];
      float y1 = (float) axisRng[3];
      
      baseline = y0 + (y1-y0)/3.0f;
      
      float[] fData = new float[5 + 5*30];
      for(int i=0; i<5; i++)
      {
         fData[i] = 30;
         for(int j=5+i*30; j<5+(i+1)*30; j++) fData[j] = x0 + (x1-x0)*((float) Math.random());
      }
      
      DataSet ds = DataSet.createDataSet(getDataSet().getID(), Fmt.RASTER1D, null, 5*30, 5, fData);
      if(ds != null) setDataSet(ds);
   }

   @Override protected boolean recalcDataRange(Object hint)
   {
      boolean needRecalc = 
         hint==null || hint==FGNProperty.SRC || hint==FGNProperty.MODE || hint==FGNProperty.XOFF || 
         hint==FGNProperty.BASELINE || hint==FGNProperty.NBINS || hint==FGNProperty.RANGE || hint==FGNProperty.AVG;
      if(!needRecalc) return(false);
      
      DataSet set = getDataSet();
      float minX = 0;
      float maxX = 0;
      float minY = 0;
      float maxY = 0;
      boolean useObservedRng = (range[0] >= range[1]);
      if(mode == DisplayMode.TRAINS || mode == DisplayMode.TRAINS2)
      {
         minX = xOffset + set.getXMin();
         maxX = xOffset + set.getXMax();
         
         // NOTE: For TRAINS mode there's no real y-range b/c vertical spacing is set by line height and spacer in 
         // stroke-width units, NOT in user units.
         minY = maxY = baseline;
         if(mode == DisplayMode.TRAINS2) maxY += (set.getNumberOfSets() + 1);
      }
      else if(countsPerBin.length == 0)
      {
         // special case: empty raster set -- empty histogram
         minX = maxX = xOffset;
         minY = maxY = baseline;
      }
      else if(mode != DisplayMode.CDF)
      {
         minX = (float) ((useObservedRng ? set.getXMin() : range[0]) + xOffset);
         maxX = (float) ((useObservedRng ? set.getXMax() : range[1]) + xOffset);
         maxY = -Float.MAX_VALUE;
         minY = Float.MAX_VALUE;
         int nTotal = 0;
         for(int i=0; i<countsPerBin.length; i++)
         {
            nTotal += countsPerBin[i];
            float y = countsPerBin[i];
            if(averaged && mode==DisplayMode.HISTOGRAM) y /= set.getNumberOfSets();
            if(y > maxY) maxY = y;
            if(y < minY) minY = y;
         }
         if(mode == DisplayMode.PDF)
         {
            float binW = (maxX-minX)/numBins;
            minY = baseline;
            maxY = baseline + maxY/(nTotal*binW);
         }
         else if(mode == DisplayMode.NORMHIST)
         {
            minY = baseline;
            maxY = baseline + maxY/nTotal;
         }
         else
         {
            // in all other histogram display modes, the bar is drawn from baseline to (baseline + binBarHt). Only in
            // HISTOGRAM mode is the bar drawn from baseline to binBarHt. Subtle difference!!
            minY = Math.min(baseline, minY);
            maxY = Math.max(baseline, maxY);
         }
      }
      else  // CDF
      {
         minX = (float) ((useObservedRng ? set.getXMin() : range[0]) + xOffset);
         maxX = (float) ((useObservedRng ? set.getXMax() : range[1]) + xOffset);
         minY = baseline;
         maxY = baseline + 1;
      }

      
      boolean changed = (cachedDataRange[0] != minX) || (cachedDataRange[1] != maxX);
      changed = changed || (cachedDataRange[2] != minY) || (cachedDataRange[3] != maxY);
      if(changed)
      {
         cachedDataRange[0] = minX;
         cachedDataRange[1] = maxX;
         cachedDataRange[2] = minY;
         cachedDataRange[3] = maxY;
      }
      return(changed);
   }

   private final static Fmt[] supportedFormats = new Fmt[] {Fmt.RASTER1D};
   
   /** Only {@link Fmt#RASTER1D} data sets are supported by the raster node. */
   @Override public boolean isSupportedDataFormat(Fmt fmt) { return(fmt == Fmt.RASTER1D); }
   @Override public Fmt[] getSupportedDataFormats() { return(supportedFormats); }
   
   @Override public boolean useBarInLegend() { return(mode != DisplayMode.TRAINS && mode != DisplayMode.TRAINS2); }

   /**
    * Overridden to recalculate and cache a "counts-per-bin" histogram of the raster data whenever any property changes
    * that could affect the histogram in width or the per-bin sample count in any of the histogram display modes.
    */
   @Override protected void onNodeModified(Object hint)
   {
      if(hint==null || hint==FGNProperty.SRC || hint==FGNProperty.MODE || 
            hint==FGNProperty.NBINS || hint==FGNProperty.RANGE)
         calcHistogram();
      super.onNodeModified(hint);
   }


   //
   // Focusable/Renderable support
   //
   
   @Override protected Rectangle2D getRenderBoundsForSelf(Graphics2D g2d, boolean forceRecalc)
   {
      if(forceRecalc || rBoundsSelf == null || painter == null)
      {
         updatePainter();
         painter.updateFontRenderContext(g2d);
         painter.invalidateBounds();
         rBoundsSelf = painter.getBounds2D(null);

         // if parent graph clips its data, then we need to clip the render bounds to the graph's data viewport
         FGNGraph g = getParentGraph();
         if(g != null && g.getClip())
            Rectangle2D.intersect(rBoundsSelf, g.getBoundingBoxLocal(), rBoundsSelf);
      }
      return((Rectangle2D)rBoundsSelf.clone());
   }

   /**
    * This method releases the internal painter used to render the raster node, as well as the cached rectangle bounding
    * any marks made by that painter.
    */
   @Override protected void releaseRenderResourcesForSelf()
   {
      painter = null;
      rBoundsSelf = null;
   }

   /**
    * Render this raster node into the current graphics context in the manner appropriate to the current display mode.
    * 
    * <p>Rendering is handled by a single {@link Painter} that is maintained and updated internally as the node's
    * definition changes.</p>
    * 
    * @see #updatePainter()
    */
   public boolean render(Graphics2D g2d, RenderTask task)
   {
      if(needsRendering(task))
      {
         if(painter == null) updatePainter();
         if(!painter.render(g2d, task)) return(false);
      }
      return(true);
   }

   //
   // Internal rendering resources
   //

   /** A histogram of the current raster sample data, in # counts per bin. */
   private int[] countsPerBin = new int[0];
   
   /** 
    * Helper method recalculates the "counts-per-bin" summary histogram for the underlying raster data set. Note that
    * we use the histogram sample range [S..E] as set via {@link #setHistogramRange()}; if this range is a subset of the
    * observed sample range, any samples outside [S..E] are unaccounted for in the computed histogram. If S >= E, the
    * observed sample range is used.
    * 
    * <p><i>Histogram in polar plot.</i> In a polar plot, the raster samples are interpreted as angles presumably in
    * degrees, and unique values are limited to the unit circle [0..360]. To prepare the histogram in this scenario, 
    * each "angle" sample is mapped to its equivalent angle in the unit circle [S..S+360], where S is the start of the 
    * histogram range (it may not be zero). Note also that, if the user specifies a histogram range [S, E] spanning
    * more than 360 degrees, the end of the range will be set to [S..S+360].</p>
    */
   private void calcHistogram()
   {
      DataSet set = getDataSet();
      if(set.isEmpty())
      {
         if(countsPerBin.length > 0) countsPerBin = new int[0];
         return;
      }
      
      if(countsPerBin.length != numBins) countsPerBin = new int[numBins];
      for(int i=0; i<countsPerBin.length; i++) countsPerBin[i] = 0;
      
      // special case: polar graph: Effective range limited to [S..S+360], and all raster samples are interpreted in
      // degrees and mapped to the equivalent angle in that range.
      FGNGraph g = getParentGraph();
      boolean isPolar = (g != null) && g.isPolar();
      
      boolean useObservedRange = (range[0] >= range[1]);
      float xMin = (float) (useObservedRange ? set.getXMin() : range[0]);
      float xMax = (float) (useObservedRange ? set.getXMax() : range[1]);
      if(isPolar && (xMax - xMin > 360)) xMax = xMin + 360;
      
      float binSize = (xMax-xMin)/((float)numBins);
      for(int i=0; i<set.getNumberOfSets(); i++)
      {
         for(int j=0; j<set.getDataSize(i); j++)
         {
            float datum = set.getX(j,i);
            if(isPolar) datum = (float) Utilities.restrictAngle(datum, xMin);
            if(Utilities.isWellDefined(datum) && datum >= xMin && datum <= xMax)
            {
               int nBin = Utilities.rangeRestrict(0, countsPerBin.length-1, (int) ((datum - xMin)/binSize));
               ++(countsPerBin[nBin]);
            }
         }
      }
   }
   
   /**
    * Cached rectangle bounding only the marks made by this raster node. An empty rectangle indicates that the element 
    * makes no marks when "rendered". If null, the rectangle has yet to be calculated.
    */
   private Rectangle2D rBoundsSelf = null;

   /** The painter which is responsible for rendering this raster node IAW its current state. */
   private Painter painter = null;

   /**
    * Create/update the internal {@link Painter} responsible for rendering this raster node IAW its current definition.
    * 
    * <p>For the "train"-like display modes: A {@link PolylinePainter} is configured to connect render all of the 
    * individual vertical hash marks that comprise the raster trains. It is styled IAW this nodes own draw styles. Any
    * ill-defined raster samples are omitted. The inner class {@link #RasterTrainProducer} serves as the location 
    * producer for this painter.</p>
    * 
    * <p>For the "histogram" display modes. In these modes, a histogram is prepared from the raster sample data and 
    * drawn IAW several histogram-specific properties. The exact nature of the histogram depends on the display mode
    * chosen: a "raw" histogram indicating count per bin or average counts per raster per bin if {@link #getAveraged()}
    * is true; a normalized histogram in which the raw count per bin is divided by the total number of samples in the
    * data set; a probability density function; or a cumulative density function. In all cases, the inner class {@link 
    * #HistogramVertexProducer} serves as the location for the internal painter -- a {@link PolylinePainter} configured 
    * to draw the rectangular histogram bars in a Cartesian graph, or a {@link CircularArcPainter} to draw the histogram
    * bars as pie wedges or radial sections in a polar graph.</p>
    */
   private void updatePainter()
   {
       if(mode == DisplayMode.TRAINS || mode == DisplayMode.TRAINS2)
          painter = new PolylinePainter(this, new RasterTrainProducer());
       else
       {
          // make sure histogram has been calculated
          if(countsPerBin == null || countsPerBin.length == 0) calcHistogram();
          
          FViewport2D parentVP = getParentViewport();
          HistogramVertexProducer vertexProvider = new HistogramVertexProducer(false);
          if(parentVP.isPolar())
          {
             Point2D origin = parentVP.getPhysicalUserOrigin();
             CircularArcPainter arcPainter = new CircularArcPainter(this, vertexProvider, origin);
             arcPainter.setClosure(CircularArcPainter.Closure.SECTION);
             arcPainter.setFilled(true);

             // reference radius is the baseline property, converted from user to logical painting units
             double r = baseline;
             if(r != 0)
             {
                Point2D p = new Point2D.Double(0,r);
                parentVP.userUnitsToThousandthInches(p);
                r = origin.distance(p);
             }
             arcPainter.setReferenceRadius(r);

             painter = arcPainter;
          }
          else
          {
             PolylinePainter rectPainter = new PolylinePainter(this, vertexProvider);
             rectPainter.setConnectionPolicy(PolylinePainter.ConnectPolicy.CLOSED);
             rectPainter.setFilled(true);
             painter = rectPainter;
          }
       }
   }
   
   /**
    * Helper class provides an iterator over all of the locations in a single polyline path that renders the set of 
    * vertical "hash marks" comprising a raster train-like representation of the source raster data set. It generates 
    * three points for each well-defined raster sample datum: <i>{(x,y) (x,y+h) (NaN, NaN)}</i>, where <i>x, y, h</i> 
    * are expressed in "painting" coordinates WRT the parent graph viewport. Thus, each raster sample is rendered as a 
    * vertical hash mark (or a ray segment in polar coordinates!), and the ill-defined point introduces a gap in the 
    * polyline between consecutive hash marks.
    * 
    * <p>How do we calculate the "painting" coordinates above for each raster sample? Let X0 be the current value of the 
    * node's X-coordinate offset in user units, let B be the node's Y-coordinate baseline in user units (this is the 
    * baseline of the <i>first</i> raster train in the rendering), and let d be the nodes's stroke width in "painting" 
    * coordinates. Let lineHt and lineSpace be the values of the node's raster line height and spacer attributes.
    * <ul>
    *    <li>{@link DisplayMode#TRAINS}. In this case, lineHt and lineSpace are in stroke-width units. For each raster
    *    sample S in the n-th component raster, the point (S+X0,B) is first transformed from "user" to "painting" 
    *    coordinates (x,y0) in the parent graph viewport. This is the location of the sample along the baseline of the 
    *    first raster. The hash mark is then defined by the points <i>(x, y0 + d*n*lineSpace)</i> and <i>(x, y0 + 
    *    d*n*lineSpace + lineHt)</i> in "painting" coordinates.</li>
    *    <li>{@link DisplayMode#TRAINS2}. In this mode, lineSpace is ignored. For each raster sample S in the n-th 
    *    component raster, the point (S+X0,B+n) is first transformed from "user" to "painting" coordinates (x,y0) in 
    *    the parent graph viewport. The hash mark end points are <i>(x, y0)</i> and <i>(x, y0 + lineHt)</i>.</li>
    * </ul>
    *</p>
    * 
    * <p>Iterators provided by <b>RasterTrainProducer</b> do <i>not</i> support removal of a location. Also, the class 
    * is <i>not</i> thread-safe. Since it is used to iterate over data during rendering (which occurs in a background 
    * thread), this could be problematic!</p>
    * 
    * @author  sruffner
    */
   private class RasterTrainProducer implements Iterable<Point2D>, Iterator<Point2D>
   {
      final FViewport2D graphVP;
      final DataSet set;
      final double xOffset;
      final double baseline;
      final double lineHt;    // in mils for trains mode; height in user coords for trains2 mode
      final double lineSpacer;  // in mils
      final boolean isTrains2;
      int nPtsSoFar;
      int nSetsSoFar;
      int which;  // 0 for first pt of hash mark, 1 for second pt, 2 for undefined pt to separate from next hash!
      Point2D pCurrent;

      public Iterator<Point2D> iterator() { return(new RasterTrainProducer()); }

      RasterTrainProducer()
      {
         graphVP = getParentViewport();
         set = getDataSet();
         xOffset = getXOffset();
         baseline = getBaseline();
         isTrains2 = (getMode() == DisplayMode.TRAINS2);
         lineHt = getStrokeWidth() * getLineHeight();
         lineSpacer = getStrokeWidth() * getLineSpacer();
         nPtsSoFar = 0;
         nSetsSoFar = 0;
         which = 0;
         pCurrent = new Point2D.Double();
         
         // it is possible that some individual rasters will contain no samples. Find the first non-empty raster.
         while(nSetsSoFar < set.getNumberOfSets())
         {
            if(set.getDataSize(nSetsSoFar) > 0) break;
            ++nSetsSoFar;
         }
      }

      public boolean hasNext() { return( graphVP != null && nSetsSoFar < set.getNumberOfSets() ); }

      public Point2D next()
      {
         if(!hasNext()) throw new NoSuchElementException("Out of elements.");

         if(which == 2)
         {
            pCurrent.setLocation(Double.NaN, Double.NaN);
            which = 0;
            return(pCurrent);
         }

         if(isTrains2)
         {
            pCurrent.setLocation(set.getX(nPtsSoFar, nSetsSoFar) + xOffset, baseline + nSetsSoFar);
            if(graphVP != null) graphVP.userUnitsToThousandthInches(pCurrent);
            
            if(which == 1) pCurrent.setLocation(pCurrent.getX(), pCurrent.getY() + lineHt);
         }
         else
         {
            pCurrent.setLocation(set.getX(nPtsSoFar, nSetsSoFar) + xOffset, baseline);
            if(graphVP != null) graphVP.userUnitsToThousandthInches(pCurrent);

            double y = pCurrent.getY() + nSetsSoFar * lineSpacer + (which == 1 ? lineHt : 0);
            pCurrent.setLocation(pCurrent.getX(), y);
         }
         
         if(which == 1)
         {
            ++nPtsSoFar;
            if(nPtsSoFar >= set.getDataSize(nSetsSoFar))
            {
               // move on to next NON-EMPTY raster in the raster collection
               ++nSetsSoFar;
               nPtsSoFar = 0;
               while(nSetsSoFar < set.getNumberOfSets())
               {
                  if(set.getDataSize(nSetsSoFar) > 0) break;
                  ++nSetsSoFar;
               }
            }
         }
         ++which;

         return(pCurrent);
      }

      public void remove()
      {
         throw new UnsupportedOperationException("Removal not supported by this iterator.");
      }
   }

   /**
    * <b>HistogramVertexProducer</b> is a helper class that provides an iterator over the vertices that define the 
    * outlines of histogram bars when the raster node is in any one of the histogram display modes. It serves both as 
    * the iterator implementation and the iterator provider (it simply provides fresh copies of itself). 
    * 
    * <p>Histogram "bars" come in two different forms.
    * <ul>
    *    <li>If the parent graph is <i>not</i> polar, each histogram bar is a closed rectangle. In this case, a {@link 
    *    PolylinePainter} is used to render the histogram, and <b>HistogramVertexProducer</b> delivers the four vertices
    *    of each rectangle, separated by one undefined point so that the painter closes each rectangle before starting
    *    the next one.</li>
    *    <li>If the parent graph is polar, each histogram bar becomes a circular pie wedge or radial section (depending 
    *    on the value of the <i>baseline</o> property). In this case, an appropriately configured {@link 
    *    CircularArcPainter} renders the histogram, and <b>HistogramVertexProducer</b> delivers a pair of points in 
    *    polar coordinates -- (theta0,r) and (theta1,r), where r is the distance from the polar origin in logical units 
    *    -- for each well-defined arc. When generating vertices for the Postscript rendering the points are left in 
    *    "painting coordinates" -- the relevant {@link PSDoc} method handles the conversion to polar coordinates. 
    *    <i>[Such usage would seem extremely rare; nevertheless it is supported.]</i></li>
    * </ul>
    * </p>
    * 
    * <p>Iterators provided by <b>HistogramVertexProducer</b> do <i>not</i> support removal of a vertex. Also, the class
    *  is <i>not</i> thread-safe. Since it is used to iterate over data during rendering (which occurs in a background 
    *  thread), this could be problematic!</p>
    */
   private class HistogramVertexProducer implements Iterable<Point2D>, Iterator<Point2D>
   {
      final FViewport2D graphVP;
      final double[] hist;
      final double xOffset;
      final double xMin;
      final double binWidth;
      final double baseline;
      final boolean isPolar;
      final Point2D polarOrigin;
      final boolean forPS;
      final DisplayMode dm;
      
      int nPtsSoFar;
      int nVertsSoFar;
      Point2D[] barVertices;

      public Iterator<Point2D> iterator() { return(new HistogramVertexProducer(forPS)); }

      /**
       * Construct a 2D point producer which provides a special iterator over the vertices that define the outline of 
       * the histogram bars when the raster node is in any of the histogram display modes. See class header for a 
       * complete description. 
       * @param forPostscript Flag set if this producer will generate vertices for a Postscript rendering. When the 
       * parent graph is polar, the vertices are left in "painting coordinate" if this flag is set, rather than being 
       * converted to polar form.
       */
      public HistogramVertexProducer(boolean forPostscript)
      {
         dm = getMode();
         forPS = forPostscript;
         graphVP = getParentViewport();
         DataSet rasterData = getDataSet();
         
         xOffset = getXOffset();
         double xMax = 0;
         if(getHistogramRangeStart() < getHistogramRangeEnd())
         {
            xMin = getHistogramRangeStart();
            xMax = getHistogramRangeEnd();
         }
         else
         {
            xMin = rasterData.getXMin();
            xMax = rasterData.getXMax();
         }
         
         binWidth = (countsPerBin.length > 0) ? (xMax - xMin) / countsPerBin.length : 1;
         baseline = getBaseline();

         // prepare the correct histogram for each distinct display mode. Catch special case: an empty histogram
         int nTotal = 0; 
         for(int i=0; i<countsPerBin.length; i++) nTotal += countsPerBin[i];
         hist = new double[nTotal > 0 ? countsPerBin.length : 0];
         
         if(hist.length > 0)
         {
            if(dm==DisplayMode.HISTOGRAM)
            {
               double nRasters = (getAveraged()) ? rasterData.getNumberOfSets() : 1.0;
               for(int i=0; i<hist.length; i++) hist[i] = ((double) countsPerBin[i]) / nRasters;
            }
            else
            {
               // note: Unlike in HISTOGRAM display mode, in these nodes the bars are drawn from the baseline to 
               // (baseline + bin value). In HISTOGRAM mode, they are drawn from baseline to bin value -- so some bars
               // can extend below the baseline if the baseline > bin value!
               if(dm==DisplayMode.NORMHIST)
               {
                  for(int i=0; i<hist.length; i++) hist[i] = baseline + ((double)countsPerBin[i]) / ((double)nTotal);
               }
               else if(dm==DisplayMode.PDF)
               {
                  for(int i=0; i<hist.length; i++) hist[i] = baseline + ((double)countsPerBin[i]) / (nTotal*binWidth);
               }
               else  // CDF
               {
                  double accum = 0;
                  for(int i=0; i<hist.length; i++)
                  {
                     accum += countsPerBin[i];
                     hist[i] = baseline + (accum / nTotal);
                  }
               }
            }
         }
         
         isPolar = graphVP.isPolar();
         polarOrigin = (graphVP != null) ? graphVP.getPhysicalUserOrigin() : new Point2D.Double(0,0);

         nPtsSoFar = 0;
         nVertsSoFar = isPolar ? 2 : 5;
         barVertices = new Point2D[nVertsSoFar];
         for(int i = 0; i < nVertsSoFar; i++) 
            barVertices[i] = new Point2D.Double(0,0);
      }

      public boolean hasNext()
      {
         if(graphVP == null || hist.length == 0) return(false);
         return( !(nPtsSoFar >= hist.length && nVertsSoFar >= barVertices.length) );
      }

      public Point2D next()
      {
         if(!hasNext()) throw new NoSuchElementException("Out of elements.");

         // if we're done with the current histogram bar, compute vertices for the next one
         if(nVertsSoFar >= barVertices.length)
         {
            boolean gotNextBar = false;
            while(nPtsSoFar < hist.length && !gotNextBar)
            {
               double x = xMin + xOffset + binWidth*nPtsSoFar;
               double y = hist[nPtsSoFar];
               
               // prepare vertices needed to render next bin of histogram. Vertices prepared depend upon whether we're 
               // rendering rectangles in a Cartesian graph or arcs in a polar graph.  These are in "user" coords.
               if(isPolar)
               {
                  barVertices[0].setLocation(x, y);
                  barVertices[1].setLocation(x + binWidth, y);
               }
               else 
               {
                  barVertices[0].setLocation(x, baseline);
                  barVertices[1].setLocation(x + binWidth, baseline);
                  barVertices[2].setLocation(x + binWidth, y);
                  barVertices[3].setLocation(x, y);
                  barVertices[4].setLocation(0, 0);   // so "well-defined" test below works!
               }

               // convert to logical "painting" coordinates in the parent graph's viewport. If any of the vertices of 
               // the histogram bar are ill-defined, then we simply do not render it.
               graphVP.userUnitsToThousandthInches(barVertices);
               gotNextBar = Utilities.isWellDefined(barVertices);

               // if we got a valid histogram bar...
               if(gotNextBar)
               {
                  // if we're doing rectangles, set last point to (NaN,NaN) so PolylinePainter will close rectangle.
                  // This is also required by PSDoc.renderPolygons(). In the polar case, we must put vertices in polar 
                  // coord form for CircularArcPainter, but not so for PSDoc.renderConcentricWedges().
                  if(barVertices.length == 5) barVertices[4].setLocation(Double.NaN, Double.NaN);
                  else if(!forPS)
                  {
                     double r = polarOrigin.distance(barVertices[0]);
                     barVertices[0].setLocation(x, r);
                     barVertices[1].setLocation(x + binWidth, r);
                  }
               }

               // go to the next bin
               ++nPtsSoFar;
            }

            // degenerate case: If some histogram bars are ill-defined for whatever reason, we might have no vertices 
            // left to supply. In this case, the last bar contains ill-defined points, which painters should ignore.
            // The next call to hasNext() will return false.
            if(!gotNextBar)
            {
               for(int i = 0; i<barVertices.length; i++) barVertices[i].setLocation(Double.NaN, Double.NaN);
            }

            nVertsSoFar = 0;
         }

         Point2D nextVtx = barVertices[nVertsSoFar];
         ++nVertsSoFar;
         return(nextVtx);
      }

      public void remove()
      {
         throw new UnsupportedOperationException("Removal not supported by this iterator.");
      }
   }

   
   //
   // PSTransformable
   //
   
   public void toPostscript(PSDoc psDoc)
   {
      // if there's no data to render, do nothing!
      if(getDataSet().isEmpty()) return;
 
      // render in Postscript IAW the current display mode...
      switch(mode)
      {
         case TRAINS : 
         case TRAINS2 :   renderAsRasterTrains(psDoc); break;
         default: renderAsHistogram(psDoc); break;
       }
   }
   
   /**
    * Helper method for {@link #toPostscript()}. Handles PS rendering in any of the raster "train" display modes.
    * @param psDoc The Postscript document in which this raster node is rendered.
    */
   private void renderAsRasterTrains(PSDoc psDoc)
   {
      FViewport2D parentVP = getParentViewport();
      if(parentVP == null || !isStroked()) return;
      
      // use RasterTrainProducer to generate all the points in the polyline path
      List<Point2D> listOfPoints = new ArrayList<Point2D>();
      Iterator<Point2D> iterator = new RasterTrainProducer();
      while(iterator.hasNext()) 
         listOfPoints.add((Point2D) iterator.next().clone());   // must close, because producer reuses a Point2D!
      if(listOfPoints.size() < 2) return;
      Point2D[] coords = new Point2D[listOfPoints.size()];
      for(int i=0; i<coords.length; i++) coords[i] = listOfPoints.get(i);
      
      // now draw the polyline path in the PSDoc
      psDoc.startElement(this);
      psDoc.renderPolyline(coords, null, 0, null, null, false);
      psDoc.endElement();         
   }
   
   /**
    * Helper method for {@link toPostscript()} Handles PS rendering in any of the histogram display modes.
    * @param psDoc The Postscript document in which this raster node is rendered.
    */
   private void renderAsHistogram(PSDoc psDoc)
   {
      FViewport2D parentVP = getParentViewport();
      boolean isFill = getFillColor().getAlpha() != 0;
      if(parentVP == null || !(isStroked() || isFill)) return;

      // make sure we've calculated the histogram
      if(countsPerBin == null || countsPerBin.length == 0) calcHistogram();
      
      // use HistogramVertexProducer to generate the vertices for the histogram bar shapes.
      Iterator<Point2D> iterator = new HistogramVertexProducer(true);
      List<Point2D> vertices = new ArrayList<Point2D>();
      while(iterator.hasNext()) 
         vertices.add((Point2D) iterator.next().clone());    // must clone, b/c producer reuses a Point2D

      if(vertices.size() == 0) return;
      
      
      // if there are some histogram bars to render, invoke the Postscript document's appropriate utility method.
      psDoc.startElement(this);
      if(!parentVP.isPolar()) psDoc.renderPolygons(vertices, isFill);
      else 
      {
         Point2D origin = parentVP.getPhysicalUserOrigin();
         double baseRad = parentVP.convertUserDistanceToThousandthInches(
               new Point2D.Float(0, 0), new Point2D.Float(0, baseline));
         psDoc.renderConcentricWedges(origin, vertices, baseRad, isFill);
      }
      psDoc.endElement();
   }
   
   
   // 
   // Object
   //

   /**
    * This override ensures that the rendering infrastructure for the clone is independent of this raster node. The 
    * clone will reference the same data set, however!
    */
   @Override protected Object clone()
   {
      RasterNode copy = (RasterNode) super.clone();
      copy.painter = null;
      copy.rBoundsSelf = null;
      copy.countsPerBin = new int[0];
      return(copy);
   }

}
