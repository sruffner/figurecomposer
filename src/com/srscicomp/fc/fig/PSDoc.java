package com.srscicomp.fc.fig;

import java.awt.Color;
import java.awt.Rectangle;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.awt.image.BufferedImage;
import java.awt.image.ColorModel;
import java.awt.image.Raster;
import java.awt.print.PageFormat;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.Writer;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.Stack;
import java.util.StringTokenizer;

import com.srscicomp.common.g2dutil.Marker;
import com.srscicomp.common.g2dutil.TextAlign;
import com.srscicomp.common.ui.BkgFill;
import com.srscicomp.common.ui.FontStyle;
import com.srscicomp.common.ui.LocalFontEnvironment;
import com.srscicomp.common.ui.UnicodeSubset;
import com.srscicomp.common.util.ASCII85Encoder;
import com.srscicomp.common.util.Utilities;
import com.srscicomp.fc.fypml.FGModelSchema;
import com.srscicomp.fc.matlab.MatlabFigureImporter;
import com.srscicomp.fc.uibase.FCWorkspace;
import com.srscicomp.fc.uibase.PrinterSupport;

/**
 * <code>PSDoc</code> provides the avenue by which a <em>DataNav</em> figure is converted into a Postscript language 
 * program that can be sent to a Postscript interpreter for rendering on printed media. It is <strong>NOT</strong> the 
 * equivalent of a generic Postscript "driver"; instead, it is specifically geared to transforming a <em>DataNav</em> 
 * figure into its Postscript representation.
 * 
 * <p><code>PSDoc</code> shields the <em>DataNav</em> graphic model from the low-level details of the Postscript 
 * language. Instead, a renderable graphic object -- which must implement the <code>PSTransformable</code> interface -- 
 * will invoke a series of methods on <code>PSDoc</code> that will effectively render the object in that document. These 
 * methods, in turn, generate the actual Postscript language commands that do the work required. A typical 
 * <em>DataNav</em> figure will contain graphic elements that appear often and are executed with a similar sequence of 
 * commands -- such as the polylines that connect points in a data set, axis lines and ticks, or the symbols that may 
 * appear at data point locations. <code>PSDoc</code> internally defines Postscript "procedures" to handle such 
 * oft-repeated graphic functions. These procedures are supplied in a "prolog" that appears near the beginning of the 
 * Postscript document, before the main "script" that renders the actual figure. The use of procedures and the prolog 
 * make the final Postscript program more efficient and compact, easier to read offline, and faster to process at print 
 * time.</p>
 * 
 * <p>Postscript font support is a difficult issue, given the plethora of screen and printer fonts in existence. All 
 * TrueType fonts on the system may be downloaded onto Postscript printers that are Level 2 or higher. However, font
 * downloading is an arduous undertaking. To avoid this complication, all <em>DataNav</em> graphic nodes which may have 
 * text content specify both a screen font and a Postscript font. The set of supported Postscript fonts is limited to 
 * Latin typefaces from the well-known and well-supported "Standard 35" set. These typefaces include plain, bold,
 * italic, and bold-italic versions of the 8 font families enumerated by <code>PSFont</code>. <code>PSDoc</code> assumes
 * that all such fonts will be available on any Postscript interpreter to which the Postscript document is sent. By and
 * large, this is a safe assumption -- especially since <code>PSDoc</code> requires language level 2 support. However, 
 * the "Standard 35" is not a requirement for any Postscript device, so it is always possible that a Postscript document
 * generated by <code>PSDoc</code> will not print properly.</p>
 * 
 * <p>Unicode character support is another thorny issue. A Postscript font is limited to 255 characters at any one time, 
 * although the glyphs to which the character codes 0-255 map can be changed by altering the font's encoding vector. 
 * Even with reencoding, the number of unique glyphs supported by the common Postscript fonts is much smaller than the 
 * set of glyphs supported onscreen. We've found that Adobe's pervasive Postscript 5 driver avoids the problem of font 
 * downloading and character support by rendering characters via character paths, consulting the font file for the 
 * necessary information. This again is beyond the scope of <em>DataNav</em>, and it has the added disadvantage of 
 * creating bloated Postscript files.</p>
 * 
 * <p>The approach taken in <em>DataNav</em> is to restrict the set of Unicode characters allowed in a <em>DataNav</em> 
 * document to a subset of two common character sets supported in most Postscript environments: the Standard Latin and 
 * Symbol character sets. <code>PSDoc</code> uses composite fonts to cover all the possible characters in these sets. 
 * Given the base Postscript font specified for a text-containing element, <code>PSDoc</code> creates a composite font 
 * consisting of the base font using the <em>StandardEncoding</em> vector, that same font using the 
 * <em>ISOLatin1Encoding</em> vector, and \the <em>Symbol</em> font using a custom <em>SymbolEncoding</em> vector. Any 
 * text rendered by <code>PSDoc</code> is translated from a Unicode text string to a sequence of <em>(subFont, 
 * charCode)</em> pairs, where <em>subFont</em> indicates which font in the composite font should be used to render the 
 * character, and <em>charCode</em> is the character's Postscript character code [0..255]. See the Postscript Language 
 * Reference Manual for more details about composite fonts, which is a Level 2 feature.</p>
 * 
 * <p>Finally, <code>PSDoc</code> prepares a Postscript language document which conforms to Adobe's Document Structuring 
 * Conventions (DSC) Specification. It includes any necessary DSC comments, a separate prolog and script, restricts line 
 * length to 250 characters or less, etcetera. The prolog procedures used by <code>PSDoc</code> are organized into 
 * several distinct "procedure sets", and these definitions (some of which are lengthy) are stored as properties in a 
 * package-relative resource file, <code>PSDoc.PROLOG_RES</code>.</p>
 * 
 * <p><i>Support for image with transparent background</i>. As of V4.5.2, a Language Level 3 feature (type 4 image
 * dictionary) is used to prevent painting of any fully transparent pixels (alpha component == 0) in the source image.
 * If the PS device does not support LL3, the EPS file generated by <code>PSDoc</code> may not render correctly.</p> 
 * 
 * @author 	sruffner
 */
public class PSDoc
{
	/**
	 * Create a Postscript language page description that renders the specified Postscript-transformable object on a 
    * single "printed" page. The resulting page description can be optionally marked as an Encapsulated Postscript 
    * (EPS) document.
	 * 
	 * @param psObj The graphic object to be transformed into a Postscript page description.
	 * @param pgf The page layout to be applied to each page. If <code>null</code>, a default layout (letter size,
	 * portrait, 1-in margins) will be supplied.\
	 * @param eps The output will be tagged as "EPSF-3.0" iff this flag is set.
	 * @return A <code>PSDoc</code> representing the PS page description, ready to be streamed to file or printer.
	 * @throws UnsupportedOperationException if the page description could not be generated for any reason, or if the 
	 * specified page range was invalid.
	 */
	public static PSDoc createPostscriptDoc(PSTransformable psObj, PageFormat pgf, boolean eps) 
		throws UnsupportedOperationException
	{
      PageFormat pgfmt = (pgf == null) ? new PageFormat() : pgf;
		PSDoc doc = new PSDoc(eps, pgfmt);
		doc.createPage(psObj);
		return(doc);		
	}

	/**
	 * The maximum depth of a Postscript interpreter's graphics state stack, in Language Level 1.
	 */
	private final static int MAX_GSTATE_DEPTH = 32;

	/**
	 * The maximum number of elements (alternating dash and gap lengths) in the array argument to the Postscript 
	 * "setdash" operator.
	 */
	private final static int MAX_DASHPATTERNSIZE = 11;

	/**
	 * Exception message when an attempt is made to make marks outside a page context
	 */
	private final static String NOPAGE_EXCP = "Attempt to render outside a page context!";

	/**
	 * Exception message when the graphics state stack overflows (attempt to push onto a full stack)
	 */
	private final static String GSOVFL_EXCP = "Graphics state stack overflow";

	/**
	 * Exception message when the graphics state stack underflows (attempt to pop from an empty stack)
	 */
	private final static String GSUNFL_EXCP = "Graphics state stack underflow";

	/**
	 * A newline in the <code>PSDoc</code> is achieved by a carriage return followed by a linefeed.
	 */
	private final static String NEWLINE = "\r\n";

	/**
	 * This prolog-defined name refers to a general-purpose array object that is required by certain <code>PSDoc</code> 
    * prolog procedures. The array is loaded with required data just before invoking the procedure. The exact content 
    * of the array will vary depending on the prolog procedure that processes it. See the prolog procedure definitions 
	 * for details. Initially, the name references the Postscript "null" object.
	 */
	private final static String DATA0 = "data0";

   /** Another general-purpose array defined in prolog. See {@link #DATA0}. */
   private final static String DATA1 = "data1";

   /** Another general-purpose array defined in prolog. See {@link #DATA0}. */
   private final static String DATA2 = "data2";

	/** 
	 * This prolog procedure enables or disables the stroke operator in <em>DataNav</em> PS. It is the mechanism by which 
    * <code>PSDoc</code> ensures that no stroking occurs when the stroke width is zero. This is because, by Postscript 
    * conventions, a zero-length line width actually equates to the minimum renderable width in the PS interpreter.
	 * 
	 * <p><code>PSDoc</code> PS replaces the "stroke" operator with a private operator. It also maintains a 
    * global prolog flag which indicates whether or not stroking is enabled. Our private stroke operator ("strokeEx") 
    * simply calls "stroke" if stroking is enabled; else it simply clears the current path without stroking it. The 
    * state of the prolog "enable stroking" flag is maintained as part of the graphics state in <em>DataNav</em> PS.
	 * 
	 * <p>Postscript syntax:  N enaStroke -- : If N is zero, stroking is disabled; else, stroking is enabled.</p>
	 */
	private final static String ENABLESTROKE = "enaStroke";

	/** 
	 * This prolog procedure changes the current fill color -- which is maintained in a global prolog variable.
	 * 
	 * <p>Postscript syntax: 
	 * <ul>
	 * <li>gray 1 setFillColor -- : Sets the current fill color to the specified grayscale value.</li>
	 * <li>r g b 3 setFillColor -- : Sets the current fill color to the specified RGB color.</li>
	 * </ul>
	 * </p>
	 */
	private final static String SETFILLCOLOR = "setFillColor";

	/**
	 * This prolog procedure installs the fill color -- maintained in a global prolog variable -- as the current color 
	 * in the Postscript interpreter's graphics state. This procedure is typically invoked by other prolog procedures 
	 * that must fill a path with the current fill color and then stroke it with the current stroke color.
	 * 
	 * <p>By convention, <code>PSDoc</code> sets the current stroke color as the current color in the graphics state. 
    * This procedure may be invoked to temporarily install the fill color as the current color. To restore the stroke 
    * color after the fill is completed, ALWAYS bracket the relevant operations with a "gsave-grestore" pair.</p>
	 * 
	 * <p>Postscript syntax: -- useFillColor --</p>
	 */
	private final static String USEFILLCOLOR = "useFillColor";

	/**
	 * This prolog procedure creates an axial or gradient pattern and establishes that pattern as the current color in 
	 * the Postscript interpreter's graphics state. In typical use, a path is constructed, this procedure is called to
	 * prepare the gradient and then "fill" is called to fill the path. By design, the gradient should be designed to 
	 * just span the bounding box of the current path object.
	 * 
    * <p>By convention, <b>PSDoc</b> sets the current stroke color as the current color in the graphics state. This 
    * procedure may be invoked to temporarily install a gradient pattern as the current color. To restore the stroke 
    * color after the fill is completed, ALWAYS bracket the relevant operations with a "gsave-grestore" pair.</p>
    * 
	 * <p>Postscript syntax: type coords c0 c1 setGradFill --, where:
	 * <ul>
	 * <li><i>type</i> is the gradient type. Must be 2 for axial, 3 for radial.</li>
	 * <li><i>coords</i> is an array defining the gradient geometry. For an axial gradient, it must be an array of four
	 * numbers [x0 y0 x1 y1] specifying the endpoints of the gradient. For a radial gradient, it must be an array of six
	 * numbers [x0 y0 r0 x1 y1 r1] specifying the center points and radii of the starting and ending circles.</li>
    * <li><i>c0</i> is a 3-element array defining the RGB color at the first endpoint or starting circle.</li>
    * <li><i>c1</i> is a 3-element array defining the RGB color at the second endpoint or ending circle.</li>
	 * </ul>
	 * </p>
	 */
	private final static String SETGRADFILL = "setGradFill";
	
	/**
	 * This prolog procedure strokes a line segment from point (x0,y0) to point (x1,y1) in user space. Any current path 
	 * existing before a call to this procedure is ignored; and the current path is empty after the procedure executes.
	 * 
	 * <p>Postscript syntax:  x1 y1 x0 y0 doLine --</p>
	 */
	private final static String DO_LINE = "doLine";

	/**
	 * This prolog procedure sets the current path to a rectangle of width w and height h and bottom left corner at 
	 * (xBL, yBL) in user space. Any current path existing before a call to this procedure is ignored.
	 * 
	 * <p>Postscript syntax:  h w xBL yBL doRect --</p>
	 */
	private final static String DO_RECT = "doRect";

	/**
	 * This prolog procedure establishes the viewport for a <code>PSTransformable</code> element. The procedure 
    * translates and rotates user space, then sets a new clip rectangle if requested. It can handle the two distinct 
    * types of viewports used in <em>DataNav</em>:
	 * <ul>
	 * 	<li>The rectangular clipping viewport of a page or figure element. In this case, the clip? flag is set and 
	 * 	the remaining two arguments give the dimensions of the clipping rectangle.</li>
	 * 	<li>The non-clipping viewport of a graph element, or a linear element such as an axis or generic line. In 
	 * 	this case, the clip? flag is cleared and the remaining arguments are ignored (but they must be present!).</li>
	 * </ul>
	 * 
	 * <p>This procedure is dependent upon the <code>DO_RECT</code> procedure.</p>
	 * 
	 * <p>Postscript syntax:  h w clip? rot xBotLeft yBotLeft setViewport --</p>
	 */
	private final static String SETVIEWPORT = "setViewport";

	/**
	 * This prolog procedure draws, fills and strokes an adornment of a given size at a given location in user space, 
	 * optionally rotated. Any existing current path is ignored, and the current path is empty after execution of the 
	 * procedure. The adornment is stroked with the current color in the graphics state, which is assumed to be the 
	 * currently defined stroke color. It is filled, if requested, with the current fill color (stored in an internal 
	 * prolog variable). Finally, if a non-empty string is supplied, that string is drawn at the given location, 
	 * centered in X and adjusted in Y by the given offset. The text is always painted with the currently defined 
	 * stroke color rather than the fill color. Note that the text is rendered after the given rotation is applied!
	 * The adornment is defined by a procedure that renders the adornment's path.
	 * 
	 * <p>This procedure is dependent upon the prolog procedure <code>USEFILLCOLOR</code> and the specified adornment 
    * procedure.</p>
	 * 
	 * <p>Postscript syntax:  (str) vAdj fillCode size /proc x y rot adorn --, where:
	 * <ul>
	 * 	<li>(x,y) is the adornment's center point in user space, rot is its desired orientation, and size its 
	 * 	desired size in user units</li>
	 * 	<li>proc is the literal name of the prolog procedure that renders the adornment path.  It is critical 
	 * 	that we supply the name as a literal (ie, preceded by the forward slash), since otherwise the Postscript 
	 * 	interpreter will try to execute it rather than push it onto the operand stack for the adorn proc!</li>
	 * 	<li>fillCode specifies how the adornment should be filled: 0 = no fill; 1 = fill with the current 
	 * 	text/fill color.</li>
	 * 	<li>vAdj is used to offset the y-coordinate of the supplied text string (for vertical centering); in 
	 * 	user units.</li>
	 * 	<li>(str) is the string to be drawn, using the current stroke color rather than the current text/fill color, 
	 * 	at the adornment's center point, centered horizontally and vertically offset by vAdj.  If it is an empty 
	 * 	string, nothing is drawn.</li>
	 * </ul>
	 * </p>
	 */
	private final static String DO_ADORN = "adorn";

   /**
    * This prolog procedure is similar to {@link #DO_ADORN}, but it add new features that are specific to the FypML
    * shape node: (1) The shape can be scaled differently in the horizontal and vertical dimensions; and (2) the 
    * background fill, for a closed shape, supports axial and radial gradients as well as a single color fill or no
    * fill at all. The background fill is supplied as as argument, and the supplied text string is painted using the
    * current fill color (stored in an internal prolog variable).
    * 
    * <p>This procedure is dependent upon the prolog procedures {@link #USEFILLCOLOR} and {@link #SETGRADFILL}, as well
    * as the specified adornment procedure.</p>
    * 
    * <p>Postscript syntax:  (str) vAdj fillSpec /proc w h x y rot adornEx --, where:
    * <ul>
    *    <li>(x,y) is the adornment's center point in user space, rot is its desired orientation, and (w,h) are its 
    *    desired width and height in user units.</li>
    *    <li>proc is the literal name of the prolog procedure that renders the adornment path.  It is critical 
    *    that we supply the name as a literal (ie, preceded by the forward slash), since otherwise the Postscript 
    *    interpreter will try to execute it rather than push it onto the operand stack for the adorn proc!</li>
    *    <li>fillSpec specifies how the adornment should be filled. It is an array taking on one of four forms: [0] =
    *    no fill (transparent); [1 r g b] = solid-color fill, where r,g,b are the RGB components defining the color; 
    *    [2 coords c0 c1] is an axial gradient; [3 coords c0 c1] is a radial gradient. Note that coords, c0, and c1 are
    *    arrays prepared for supplying directly to the {@link #SETGRADFILL} procedure.</li>
    *    <li>vAdj is used to offset the y-coordinate of the supplied text string (for vertical centering); in 
    *    user units.</li>
    *    <li>(str) is the string to be drawn, using the current text/fill color, at the adornment's center point, 
    *    centered horizontally and vertically offset by vAdj.  If it is an empty string, nothing is drawn.</li>
    * </ul>
    * </p>
    */
   private final static String DO_ADORNEX = "adornEx";

	/**
	 * This prolog procedure renders a specified type of adornment at multiple locations in user space.  Each 
	 * individual adornment is rendered, stroked, and filled separately.  Each adornment is stroked with the current 
	 * stroke color (which is assumed to be the current color in the interpreter's graphics state when the procedure is 
	 * invoked) and filled IAW the specified fill code.  If the last string literal is not an empty string, it is 
	 * rendered inside each adornment, centered horizontally and adjusted vertically IAW the given offset.  The string 
	 * is painted with the current stroke color instead of the text/fill color so that it won't be "invisible" inside 
	 * painted adornments!
	 * 
	 * <p>The adornment center points {(x,y)} are assumed to be preloaded into an array of length n referenced by the 
	 * prolog variable {@link #DATA0}. Each element of this array is either null (indicating location is ill-defined) or
	 * a 2-element array AR such that AR[0]=x and AR[1]=y. Any ill-defined locations are skipped. Each adornment is 
	 * individually rendered, stroked and filled in the order that their center points appear in this array. Thus, if two
	 * adornments overlap, the adornment that's drawn later will occlude the other in the overlap region.</p>
	 * 
	 * <p>This procedure is dependent upon the prolog procs <code>DO_ADORN</code>, <code>USEFILLCOLOR</code>, and 
	 * <code>SHOWSTRING</code>, as well as the specified adornment procedure.</p>
	 * 
	 * <p>Postscript syntax:  (string) vAdj fillCode n size /proc polyAdorn --, where:
	 * <ul>
	 * 	<li>proc is the literal name of the prolog procedure that renders the adornment path.  It is critical 
	 * 	that we supply the name as a literal (ie, preceded by the forward slash), since otherwise the Postscript 
	 * 	interpreter will try to execute it rather than push it onto the operand stack for the polyAdorn proc!</li>
	 * 	<li>size is the adornment's size (size of a square box enclosing the adornment)</li>
	 * 	<li>n is the number of adornments to be rendered.  The preloaded array DATA0 must contain this number of 
	 * 	elements.</li>
	 * 	<li>fillCode specifies how the adornments should be filled: 0 = no fill; 1 = fill w/current fill color.</li>
	 * 	<li>vAdj specifies an additive adjustment in the vertical position of the text string.  It is typically used 
	 *    to vertically center the text WRT each adornment center point.</li>
	 * 	<li>string is the text string to be rendered at each adornment center point.</li>
	 * </ul>
	 * </p>
	 */
	private final static String POLYADORN = "polyAdorn";

	/**
	 * This prolog procedure was developed specifically to handle rendering of a 3D scatter or stem plot. It can render
	 * a specified adornment at multiple locations, optionally with a line segment -- a "stem" -- drawn from the center
	 * of the adornment to a second point. It is expected that the locations will be ordered from "back to front" in the
	 * 3D space so that no occlusion issues arise. The procedure supports solid-color, axial gradient, or radial gradient
	 * background fills via the {@link #DO_ADORNEX} procedure. Stems may or may not be drawn, adornment size may or may
	 * not vary at each location, and background fill may or may not vary.
	 * 
	 * <p><b>NOTE.</b> Axial and radial gradients require coordinates to define their geometry, and these coordinates 
	 * must be defined in user space with the origin at the bottom-left corner of the bounding box for the adornment 
	 * shape. Thus, for each adornment centered at (x,y), this procedure first saves the graphics state, then translates 
	 * to the BL corner  of the bounding box, <i>(x-size/2, y-size/2)</i>, then invokes {@link #DO_ADORNEX} with a center
	 * point of <i>(size/2, size/2)</i>, and restores the graphics state before proceeding to the next location.</p>
	 * 
	 * <p>Postscript syntax: stemProc s bf size n /proc polyStemAdorn --, where:
    * <ul>
    *    <li><i>stemProc</i> is a two-string array of the form "[(proc1) (proc2)]", where proc1 is the PS command 
    *    sequence that converts the current graphics state (GS) to what it should be when stroking a stem, and proc2 is
    *    the PS command that restores the original graphics state. It is expected that proc1 will start with 'gsave' to
    *    preseve the current state, and proc2 will start with 'grestore'. The proc2 command may also invoke the {@link
    *    #ENABLESTROKE} operator to restore the stroke enable state. All stems will be stroked the same way. It is 
    *    ASSUMED that the current GS when POLYSTEMADORN is invoked specifies how the adornments should be stroked. Prior
    *    to stroking a stem, <i>stemProc[0]</i> is executed via "cvx exec" to update the GS, the stem is stroked, and 
    *    then <i>stemProc[1]</i> is execute to restore the previous GS before drawing the corresponding adornment. Note 
    *    that, if stems and adornments are stroked in the same manner, both elements in <i>stemProc</i> will be empty 
    *    strings. This argument is ignored if <i>s==0</i>.</li>
    *    <li><i>s</i> is an integer flag indicating whether or not stems are drawn. If zero, only adornments are drawn
    *    at the <i>n</i> locations in DATA0. Otherwise, DATA0 contains <i>2n</i> points, where DATA0[2*i] is the center
    *    point of the i-th adornment, and the associated stem is drawn from that point to DATA0[2*i+1].</li>
    *    <li><i>bf</i> specifies the adornment's background fill. If it is an empty array, then a different fill is
    *    applied to each adornment, and DATA2 will contain the <i>n</i> fill specification arrays. Else, all adornments 
    *    are filled using the background fill defined by this array, which takes on one of four forms: [0] = no fill 
    *    (transparent); [1 r g b] = solid-color fill, where r,g,b are the RGB components defining the color; [2 coords 
    *    c0 c1] is an axial gradient; [3 coords c0 c1] is a radial gradient. Note that coords, c0, and c1 are arrays 
    *    prepared for supplying directly to the {@link #SETGRADFILL} procedure. Given that gradients contain coordinate 
    *    data relative to the BL corner of the adornment's bounding box, this is only appropriate when all adornments 
    *    are the same size.</li>
    *    <li><i>size</i> is the adornment's size (size of a square box enclosing the adornment). If this argument is 
    *    negative, then each adornment is drawn at a different size, and the <i>n</i> sizes are loaded into the DATA1
    *    array. If it is zero, then no adornment is drawn (stems only). Otherwise, all adornments are drawn at the
    *    size specified in milli-inches.</li>
    *    <li><i>n</i> is the number of adornments to be rendered.</li>
    *    <li><i>proc</i> is the literal name of the prolog procedure that renders the adornment path.  It is critical 
    *    that we supply the name as a literal (ie, preceded by the forward slash), since otherwise the Postscript 
    *    interpreter will try to execute it rather than push it onto the operand stack.</li>
    * </ul>
    * </p>
	 */
	private final static String POLYSTEMADORN = "polyStemAdorn";
	
	/**
	 * This prolog procedure is similar to <code>POLYADORN</code>, except that it also can rotate each rendered adornment 
    * about its center point. If a text string is rendered within each adornment, note that the text is painted AFTER 
    * the rotation.
	 * 
	 * <p>The adornment center points {(x,y)} are assumed to be preloaded into an array of length n referenced by the 
	 * prolog variable <code>DATA0</code>. Each element of this array is either <code>null</code> (indicating that 
    * location is ill-defined) or a 2-element array AR such that AR[0]=x and AR[1]=y. Any ill-defined locations are 
    * skipped. The adornment rotation angles are assumed to be preloaded into an array of length n referenced by the 
    * prolog variable <code>DATA1</code>.</p>
	 * 
	 * <p>This procedure is dependent upon the prolog procs <code>DO_ADORN</code>, <code>USEFILLCOLOR</code>, and 
	 * <code>SHOWSTRING</code>, as well as the specified adornment procedure.</p>
	 *
	 * <p>Postscript syntax:  (string) vAdj fillCode n size /proc polyRotAdorn --, where:
	 * <ul>
	 * 	<li>proc is the literal name of the prolog procedure that renders the adornment path.  It is critical 
	 * 	that we supply the name as a literal (ie, preceded by the forward slash), since otherwise the Postscript 
	 * 	interpreter will try to execute it rather than push it onto the operand stack for the polyAdorn proc!</li>
	 * 	<li>size is the adornment's size (size of a square box enclosing the adornment)</li>
	 * 	<li>n is the number of adornments to be rendered.  The preloaded arrays DATA0 and DATA1 must contain this 
	 * 	number of elements.</li>
	 * 	<li>fillCode specifies how the adornments should be filled: 0 = no fill; 1 = fill w/current fill color.</li>
	 * 	<li>vAdj specifies an additive adjustment in the vertical position of the text string.  It is typically used 
	 *    to vertically center the text WRT each adornment center point.</li>
	 * 	<li>string is the text string to be rendered at each adornment center point.</li>
	 * </ul>
	 * </p>
	 */
	private final static String POLYROTADORN = "polyRotAdorn";

   /**
    * This prolog procedure is similar to {@link #POLYADORN}, except that each adornment may be rendered at a different
    * size. All are drawn unrotated, with no text.
    * 
    * <p>The adornment center points {(x,y)} are assumed to be pre-loaded into an array of length <i>N</i> referenced by
    * the prolog variable {@link #DATA0}. Each element of this array is either null (indicating that location is ill-
    * defined) or a 2-element array AR such that AR[0]=x and AR[1]=y. Any ill-defined locations are skipped. The 
    * adornment sizes are assumed to be pre-loaded into an array of length <i>N</i> referenced by the prolog variable 
    * {@link #DATA1}. Each element in the array is the size of a square box enclosing the adornment, in milli-inches. All
    * of these elements should be well-defined and non-negative.</p>
    * 
    * <p>This procedure is dependent upon the prolog procedures {@link #DO_ADORN} and {@link #USEFILLCOLOR}, as well as 
    * the specified adornment procedure.</p>
    *
    * <p>Postscript syntax:  <i>fill N /proc polySizeAdorn --</i>, where:
    * <ul>
    *    <li><i>proc</i> is the literal name of the prolog procedure that renders the adornment path. It is critical 
    *    that we supply the name as a literal (i.e., preceded by the forward slash), since otherwise the Postscript 
    *    interpreter will try to execute it rather than push it onto the operand stack!</li>
    *    <li><i>N</i> is the number of adornments to be rendered. The pre-loaded arrays DATA0 and DATA1 must each 
    *    contain this number of elements.</li>
    *    <li><i>fill</i> specifies how adornments should be filled: 0 = no fill; 1 = fill w/current fill color.</li>
    * </ul>
    * </p>
    */
   private final static String POLYSIZEADORN = "polySizeAdorn";

   /**
    * This prolog procedure is similar to {@link #POLYADORN}, except that each adornment is filled with a different
    * opaque RGB color. All are drawn unrotated, with no text.
    * 
    * <p>The adornment center points {(x,y)} are assumed to be pre-loaded into an array of length <i>N</i> referenced by
    * the prolog variable {@link #DATA0}. Each element of this array is either null (indicating that location is ill-
    * defined) or a 2-element array AR such that AR[0]=x and AR[1]=y. Any ill-defined locations are skipped. The 
    * adornment colors are assumed to be pre-loaded into an array of length <i>N</i> referenced by the prolog variable 
    * {@link #DATA2}. Each element in the array is a 3-element array AR defining the R, G and B components of the desired
    * fill color as they would be supplied to {@link #SETFILLCOLOR}: AR[0] = R, AR[1] = G, AR[2] = B.</p>
    * 
    * <p>This procedure is dependent upon the prolog procedures {@link #DO_ADORN} and {@link #SETFILLCOLOR}, as well as 
    * the specified adornment procedure. Also note that it is wasteful to invoke this method with a non-closed 
    * adornment, since such adornments are never filled!</p>
    *
    * <p>Postscript syntax:  <i>N size /proc polyFillAdorn --</i>, where:
    * <ul>
    *    <li><i>proc</i> is the literal name of the prolog procedure that renders the adornment path. It is critical 
    *    that we supply the name as a literal (i.e., preceded by the forward slash), since otherwise the Postscript 
    *    interpreter will try to execute it rather than push it onto the operand stack!</li>
    *    <li><i>size</i> is the adornment size (size of square bounding box) in milli-inches.</li>
    *    <li><i>N</i> is the number of adornments to be rendered. The pre-loaded arrays DATA0 and DATA2 must each 
    *    contain this number of elements.</li>
    * </ul>
    * </p>
    */
   private final static String POLYFILLADORN = "polyFillAdorn";

   /**
    * This prolog procedure is similar to {@link #POLYADORN}, except that each adornment is drawn at a different size
    * and filled with a different opaque RGB color. All are drawn unrotated, with no text.
    * 
    * <p>This procedure assumes that three arrays have been pre-loaded with the required information. All three arrays
    * must have the same length <i>N</i>, the number of adornments to be drawn. Their contents vary:
    * <ul>
    * <li>{@link #DATA0}: The adornment center points {(x,y)}. Each element of this array is either null (indicating 
    * that location is ill-defined) or a 2-element array AR such that AR[0]=x and AR[1]=y. Any ill-defined locations are
    * skipped.</li>
    * <li>{@link #DATA1}: The adornment sizes. Each element in the array is the size of a square box enclosing the 
    * adornment, in milli-inches. All of these elements should be well-defined and non-negative.</li>
    * <li>{@link #DATA2}: The adornment colors. Each element in the array is a 3-element array AR defining the R, G and 
    * B components of the desired fill color as they would be supplied to {@link #SETFILLCOLOR}: AR[0] = R, AR[1] = G, 
    * AR[2] = B.</li>
    * </ul>
    * </p>
    * 
    * <p>This procedure is dependent upon the prolog procedures {@link #DO_ADORN} and {@link #SETFILLCOLOR}, as well as 
    * the specified adornment procedure. Also note that it is wasteful to invoke this method with a non-closed 
    * adornment, since such adornments are never filled!</p>
    *
    * <p>Postscript syntax:  <i>N /proc polySizeFillAdorn --</i>, where:
    * <ul>
    *    <li><i>proc</i> is the literal name of the prolog procedure that renders the adornment path. It is critical 
    *    that we supply the name as a literal (i.e., preceded by the forward slash), since otherwise the Postscript 
    *    interpreter will try to execute it rather than push it onto the operand stack!</li>
    *    <li><i>N</i> is the number of adornments to be rendered.</li>
    * </ul>
    * </p>
    */
   private final static String POLYSIZEFILLADORN = "polySizeFillAdorn";

	/**
	 * This prolog procedure renders a polyline that connects the set of points in user space that have been preloaded 
	 * into the <code>DATA0</code> array. If any (x,y) point in the array is <code>null</code>, this indicates a gap in 
    * the polyline. Each time such a gap occurs, a "moveto" rather than a "lineto" is used to append the next defined 
    * point in the <code>DATA0</code> array. After constructing the polyline path, it is stroked with the color that is 
    * current when the procedure is invoked. Any path existing before procedure invocation is lost, and the current 
    * path is empty afterwards.
	 * 
	 * <p>Postscript syntax:  n polyLine --, where:
	 * <ul>
	 * 	<li>n is the number of points in the polyline.  If n is less than 2, the command will have no effect.</li>
	 * </ul>
	 * </p>
	 */
	private final static String POLYLINE = "polyLine";

	/**
	 * This prolog procedure renders a series of concentric circles about the specified origin and having the specified 
	 * radii.  After constructing the path of circles, it is stroked with the color that is current when the procedure 
	 * is invoked.  Any path existing before procedure invocation is lost, and the current path is empty afterwards.
	 * 
	 * <p>This procedure depends upon the <code>A_CIRCLE</code> adornment procedure.</p>
	 * 
	 * <p>Postscript syntax:  radii[] x0 y0 polyCircles --, where (x0,y0) is the common center point in user space, and 
	 * radii[] is an array listing the radii of the circles to be rendered.  Since the procedure uses the Postscript 
	 * "forall" command to push the radii onto the operand stack, make sure that the radii[] array is not too long.</p>
	 */
	private final static String POLYCIRCLES = "polyCircles";

   /**
    * This prolog procedure renders a series of concentric arcs about the specified origin. The arc endpoints share a 
    * common theta coordinate, but each arc presumably has a different radius. The arcs are NOT connected to each 
    * other. After constructing the path that draws the arcs, it is stroked with the color that is current when the 
    * procedure is invoked. Any path existing before procedure invocation is lost, and the current path is empty 
    * afterwards.
    * 
    * <p>The arc radii are assumed to be preloaded into an array of length n referenced by the prolog variable 
    * <code>DATA0</code>. An arc is not rendered if its radius is less than or equal to zero.</p>
    * 
    * <p>Postscript syntax:  n x0 y0 a0 a1 polyArcs --, where (x0,y0) is the common center point in user space, a0 and 
    * a1 are the theta coordinates of the endpoints of each arc, and n is the number of arcs to be rendered.</p>
    */
   private final static String POLYARCS = "polyArcs";

	/**
	 * This prolog procedure renders a set of polygons in accordance with a list of vertices in user space. The polygons 
    * are not connected to each other. After constructing the path that draws the polygons, it is optionally filled IAW 
    * the specified fill code, and then stroked with the color that is current when the procedure is invoked (typically 
    * the stroke color). Any path existing before procedure invocation is lost, and the current path is empty afterwards.
	 * 
	 * <p>The polygon vertices are assumed to be preloaded into an array of length n referenced by the prolog variable 
	 * {<code>DATA0</code>. Each element of this array is a 2-element array containing (x,y) coords of a vertex. A 
    * <code>null</code> vertex marks the end of one polygon and the beginning of the next. If the vertices array does 
    * not follow these rules, the procedure may fail or render the polygons incorrectly. A polygon containing 1 vertex 
    * will not be rendered, and one defined by two vertices will be a straight line.</p>
	 * 
	 * <p>This procedure is dependent upon <code>USEFILLCOLOR</code>.</p>
	 * 
	 * <p>Postscript syntax:  fillCode n polygons --, where: 
	 * 	<li>n is the number of vertices in the "poly-polygons" array, DATA0.</li>
	 * 	<li>fillCode specifies how the adornment should be filled: 0 = no fill; 1 = fill with pure white; or 2 = fill 
	 * 	with the current fill color.</li>
	 * </ul>
	 * </p>
	 */
	private final static String POLYGONS = "polygons";

	/**
	 * This prolog procedure renders a set of circular wedges in accordance with a list of vertices in user space. The 
	 * wedges are not connected to each other. After constructing the path that draws the wedges, it is optionally 
	 * filled IAW the specified fill code, and then stroked with the color that is current when the procedure is invoked 
	 * (typically the stroke color). Any path existing before procedure invocation is lost, and the current path is 
	 * empty afterwards.
	 * 
	 * <p>The wedge vertices are assumed to be preloaded into an array of length n referenced by the prolog variable 
	 * <code>DATA0</code>. Each element of this array is a 2-element array containing (x,y) coords of a vertex. A 
    * <code>null</code> vertex marks the end of one wedge and the beginning of the next. Each wedge is defined by 2 or 
    * 4 vertices. A 2-vertex wedge yields a pie slice (arc drawn between vertices, plus lineto's from the arc endpoints 
    * to the common origin. A 4-vertex wedge [0..3] consists of two pairs of arc endpoints. Arcs are drawn from vertex 
    * 0 to 1 and vertex 2 to 3, and lineto's connect vertices 1 & 2 and 3 & 0. Typically, theta0=theta3, theta1=theta2, 
    * but this is not required. It is required, however, that r0=r1 and r2=r3. If the vertices array does not follow 
    * these rules, the procedure may fail or render the wedges incorrectly.</p>
	 * 
	 * <p><em>IMPORTANT</em>: In the 4-vertex case, it is <strong>ASSUMED</strong> that the 1st arc (between vertices 0 
    * and 1) is the inner arc of the wedge and that the 1st arc is traced in a CCW direction in the <em>DataNav</em> PS 
    * user space, while the 2nd arc is the outer arc of the wedge, traced CW. Thus, it uses the Postscript 'arcn' 
    * operator for the 1st arc and 'arc' for the second! Be sure that the vertices satisfy this assumption!!</p>
	 * 
	 * <p>This procedure is dependent upon <code>USEFILLCOLOR</code>.</p>
	 * 
	 * <p>Postscript syntax:  fillCode n x0 y0 polyWedges --, where: 
	 * 	<li>x0,y0 are the user space coordinates of the concentric wedges' common origin.</li>
	 * 	<li>n is the number of vertices in the vertices array, DATA0.</li>
	 * 	<li>fillCode specifies how the adornment should be filled: 0 = no fill; 1 = fill with pure white; or 2 = fill 
	 * 	with the current fill color.</li>
	 * </ul>
	 * </p>
	 */
	private final static String POLYWEDGES = "polyWedges";

   /**
    * This prolog procedure renders a polygon "mesh" in accordance with a list of vertices in user space. The mesh is a 
    * set of N 4-sided polygons, with the rendering order implied by the order of the vertices in the supplied list. 
    * Each mesh polygon is optionally filled then stroked separately. The stroke is governed by the properties of the 
    * current graphic state. A fill code determines how they are filled. All polygons may be unfilled (resulting in a 
    * "wire frame" effect), or filled with the same color -- the current fill color. Alternatively, a different fill
    * color or linear axial color gradient may be specified for each polygon. Any path existing before procedure 
    * invocation is lost, and the current path is empty afterwards.
    * 
    * <p>The polygon vertices are assumed to be preloaded into an array of length 4N referenced by the prolog variable 
    * {@link #DATA0}. Each element of this array is a 2-element array containing (x,y) coords of a vertex. All such
    * vertices must be well-defined. Each set of 4 vertices represents one mesh polygon.</p>
    * 
    * <p>If the fill code is 2, then each polygon is filled with a different solid color, and these colors are assumed
    * to be preloaded into an array of length N referenced by the prolog variable {@link #DATA1}. Each entry in the 
    * array is a color encoded as a packed RGB integer, 0x00RRGGBB. The mesh procedure handles the conversion of this 
    * format to the (r, g, b) triplet, where r/g/b all lie in [0..1].</p>
    * 
    * <p>If the fill code is 3, then each polygon is filled either with a solid color OR a linear axial color gradient.
    * In this scenario, the array in {@link #DATA1} has a length L in the range [2N..4N]. Each polygon is associated
    * with either 2 or 4 entries in the array, depending on the value of the first entry. If the first entry is null,
    * then the polygon is filled with a solid color, and the next entry is the color encoded as a packed RGB integer.
    * If the first entry is non-null, then that entry and the next three define the coordinates [x0 y0 x1 y1] in user
    * space for the endpoints of the axis for the gradient fill. These coordinates, along with the specified color LUT
    * key frames and colors are supplied to the {@link #CMAPFILL} procedure, which defines the axial gradient 
    * shading pattern and sets that pattern as the current color in the graphics state. Any regions before or after the 
    * endpoints in the filled path will map to the boundary colors for this gradient.</p>
    * 
    * <p>Postscript syntax:  keyFrames keyColors fc n mesh --, where: 
    *    <li><i>keyFrames</i>: Key frames defining the axial color gradient. See {@link #CMAPFILL} for details.
    *    Applicable only for axial gradient fills (<i>fc==3</i>); may be null if not used.</li>
    *    <li><i<keyColors</i>: Key colors defining the axial color gradient. See {@link #CMAPFILL} for details.
    *    Applicable only for axial gradient fills (<i>fc==3</i>); may be null if not used.</li>
    *    <li><i>fc</i> is a fill code specifying how the mesh polygons are filled: 0 = no fill; 1 = fill with the 
    *    current fill color; 2 = fill with corresponding color in {@link #DATA1}, as described above; and 3 = fill with 
    *    a solid color or gradient fill IAW information in {@link #DATA1}, again as described above.</li>
    *    <li><i>n</i> is the number of 4-sided mesh polygons to be rendered.</li>
    * </ul>
    * </p>
    */
   private final static String MESH = "mesh";
   
   /**
    * This prolog procedure optionally strokes and/or fills the region bounded by a polyline. Any path existing before 
    * procedure invocation is lost, and the current path is empty afterwards.
    * 
    * <p>The polyline is assumed to be defined by a point array of length n that is preloaded into prolog variable 
    * <code>DATA0</code>. Each element in this array is a 2-element array containing the (x,y) coords of a point. The 
    * method will first fill, then stroke the polyline. In the fill phase, it creates a single closed path by skipping 
    * over any ill-defined points and connecting the last point in the array to the first. If the path is stroked, it 
    * simply invokes the <code>POLYLINE</code> procedure.</p>
    * 
    * <p>This procedure is dependent upon <code>USEFILLCOLOR</code> and <code>POLYLINE</code>.</p>
    * 
    * <p>Postscript syntax:  stroke? fill? n polyFill --, where: 
    *    <li>n is the number of points in the polyline array, which should already be stored in DATA0.</li>
    *    <li>If the fill? flag is set (nonzero), the region bounded by the (fully-connected polyline) is filled with 
    *    the current fill color; else it is not filled.</li>
    *    <li>if the stroke? flag is set (nonzero), the polyline will be stroked; else not. In this case, ill-defined 
    *    points in the polyline array create gaps in the stroked path.</li>
    * </ul>
    * </p>
    */
   private final static String POLYFILL = "polyFill";

   /**
    * This prolog procedure is a slightly different version of the {@link #POLYFILL} procedure that independently 
    * controls whether or not the polyline path is closed, filled, and stroked; it also can specify fill and stroke
    * colors other that what is defined in the current graphic state. Note that, unlike <b>POLYFILL</b>, this 
    * procedure does NOT introduce gaps in the stroked path.
    * 
    * <p>The polyline is assumed to be defined by a point array of length <i>n</i> that is preloaded into the prolog 
    * variable {@link #DATA0}. Each element in this array is a 2-element array containing the (x,y) coords of a point. 
    * The method will first construct the path, the optionally fill and stroke the polyline.</p>
    * 
    * <p>This procedure is dependent upon {@link #USEFILLCOLOR}.</p>
    * 
    * <p>Postscript syntax:  strkRGB fillRGB close? n polyFillEx --, where: 
    *    <li>n is the number of points in the polyline array, which should already be stored in DATA0.</li>
    *    <li>If close? flag is set (nonzero), the path defined by the points array is closed by <i>closepath</i>.</li>
    *    <li>fillRGB is an integer that sets the path's fill color: -2 = use the current fill color in the graphics
    *    state; -1 = NO fill; non-negative = the desired fill color as a packed RGB integer 0x00RRGGBB.</li>
    *    <li>strkRGB is an integer that sets the path's stroke color: -2 = use the current stroke color in the graphics
    *    state; -1 = NO stroke; non-negative = the desired stroke color as a packed RGB integer 0x00RRGGBB.</li>
    * </ul>
    * </p>
    */
   private final static String POLYFILLEX = "polyFillEx";

	/**
	 * This prolog procedure paints normal horizontal text that is left-, center-, or right-aligned about the specified 
	 * coordinates (x,y). Vertically, the text is bottom aligned -- that is, the normal font baseline is set at the 
	 * specified y-coordinate. The text is rendered in the current font. <code>PSDoc</code> uses composite fonts to 
    * render text. These composite fonts are created by the <code>MAKECOMPFONT</code> procedure.
	 * 
	 * <p>Text may be painted (we do not support outlined text) with the current text/fill color or the current stroke 
	 * color, depending on the value of the 'useFill?' flag. In order to temporarily make the text/fill color the current 
    * color in the PS interpreter, this procedure is dependent upon the prolog procedure <code>USEFILLCOLOR</code>.</p>
	 * 
	 * <p>Postscript syntax:  useFill? (string) hAlign x y showStr --, where: 
	 * 	<li>(x,y) is the location in user space where the text is drawn, with a possible adjustment made for center or 
	 * 	right alignment.</li>
	 * 	<li>hAlign is an integer indicating the desired horizontal alignment. A value of 0 centers the text about 
	 * 	(x,y), a negative value means the text will end at (x,y) (right-alignment), and a positive value means the 
	 * 	text will start at (x,y) (left-alignment).</li>
	 * 	<li>string is the text string to be rendered.</li>
	 *    <li>useFill? is an integer flag indicating whether the text/fill color (nonzero) or the stroke color (zero) 
	 * 	should be used to paint the text.</li>
	 * </ul></p>
	 * <p>IMPORTANT:  The Postscript fonts, by default, design their glyphs assuming a user space in which the y-axis 
	 * increases upward -- which is the default convention in the Postscript interpreter. If user space is transformed 
    * so that the y-axis is flipped, the text would appear upside down.</p>
	 * 
	 * @see PSDoc#unicodeToPostscriptText(String)
	 */
	private final static String SHOWSTRING = "showStr";

   /**
    * This prolog procedure paints a single line of "attributed" text that is left-, center-, or right-aligned about the
    * specified coordinates (x,y). It was specifically introduced to provide <b>PSDoc</b> support for a one-line text
	 * label in which font style, text color, underline on/off, and superscript/subscript state can vary on a character
	 * by character basis in the label string.
    * 
    * <p>An attributed text sequence is composed of one or more "text runs", where each run is a styled string defined
    * by a 5-tuple: <i>/fontFace UL SS textRGB (string)</i>, specifying: the composite Postscript font face for the run;
    * whether the run should be underlined (UL!=0) or not (UL==0); whether the run is superscripted (SS>0), subscripted
    * (SS<0) or normal text (SS==0); the text color as a packedRGB integer; and the string itself. Before invoking
    * the prolog procedure, the text runs are pre-loaded into an array. The number of elements loaded equals
    * 5*N, where N is the number of different text runs comprising the attributed text label.</p>
    * 
    * <p>Postscript syntax:  <b>x y hAlign fontsz ARR showTextRuns --</b>, where: 
    * <ul>
    *    <li>(x,y) is the location in user space where the text is drawn, with a possible adjustment made for center or 
    *    right alignment.</li>
    *    <li>hAlign is an integer indicating the desired horizontal alignment. A value of 0 centers the text about 
    *    (x,y), a negative value means the text will end at (x,y) (right-alignment), and a positive value means the 
    *    text will start at (x,y) (left-alignment).</li>
    *    <li>fontsz is the font size in milli-inches.</li>
    *    <li>ARR is the array containing the sequence of individual text runs in the attributed text. As described 
    *    above, each run is defined by a 5-tuple in the array.</li>
    * </ul></p>
    */
   private final static String SHOWTEXTRUNS = "showTextRuns";

   /**
    * This prolog procedure paints a block of attributed text intended to fit in a WxH rectangle with a bottom-left 
    * corner at (0,0).
    * 
    * <p>{@link #renderTextInBox} parses the text content into an array T of attributed text run subsequences that
    * have no whitespace and thus should not be broken across a text line (if possible). Each run subsequence is an 
    * array of 5*N tuples, where N is the number of text runs in the subsequence. See {@link #SHOWTEXTRUNS} for more 
    * information about the attributed text runs. Any linefeed ('\n') in the text ontent is interpreted as a hard 
    * linebreak, and is represented in the array by a Postscript null object.</p>
    * 
    * <p>The prolog procedure passes the array of "unbreakable" run subsequences to a helper procedure that lays out the
    * subsequences in one or more text lines while respecting the rectangle's width W. Consecutive subsequences are
    * concatenated into one longer subsequence until the measured width of the subsequence would exceed W -- or a null
    * subsequence is encountered. Then a new line is started. If a single run subsequence in T is longer than W, then
    * it must be broken across two or more text lines.</p>
    * 
    * <p>The layout procedure returns an array of "text lines", each line represented by a text run subsequence that
    * should be shorter than the text block width W. Each run subsequence is rendered by the {@link #SHOWTEXTRUNS}
    * prolog procedure.</p>
    * 
    * <p>LIMITATIONS: The procedure may not accurately reproduce the text layout as seen on screen in Figure Composer.
    * The font used in the Postscript output will typically not match the screen font exactly (<b>PSDoc</b> does not do
    * font embedding), and the estimations of ascent and descent will be off somewhat. In addition, the wrapping of
    * text in the block may not match the screen output either, again because of slight differences in font metrics.</p>
    * 
    * <p>Postscript syntax:  F T R HA VA L W H showTextRunsInBox --, where:
    * <ul>
    *    <li>F is the font size in user space units.</li>
    *    <li>T is the array of attributed text run subsequences, as described above.</li>
    *    <li>R, HA, VA, L, W, and H are as described for the {@link #SHOWTEXTRUNS} procedure.</li>
    * </ul>
    * </p>
    */
   private final static String SHOWTEXTRUNSINBOX = "showTextRunsInBox";

	/**
	 * This prolog procedure prepares a composite font that handles all characters supported by <code>PSDoc</code>. The 
    * supported character set is culled from the built-in Postscript encodings known as "StandardEncoding" (the default) 
    * and "ISOLatin1Encoding", as well as the custom encoding for the Symbol font. 
	 * 
	 * <p>The procedure takes three name objects, representing the names of the base font using the StandardEncoding, 
	 * that same font using the ISOLatin1Encoding, and the name to use for the composite font. The composite font 
	 * created by the method has the StandardEncoding base font in slot 0, the ISOLatin1Encoding version in slot 1, and 
	 * the Symbol font in slot 2. The composite font uses the escape mapping algorithm (FMapType = 3) to specify the 
	 * font to use for subsequent characters in a text string. The escape character is 127, which is not used in any 
	 * of the character encodings.</p>
	 * 
	 * <p><code>PSDoc</code> renders all text using the composite fonts created by this procedure rather than the atomic 
    * base font; text strings supplied to the <code>SHOWSTRING</code> procedure are prepared in the format expected when 
    * the current font is a composite font of the form described here.</p>
	 * 
	 * <p>Postscript syntax:  /fontC /fontISO /font makeCompositeFont --, where the three arguments on the stack are the 
	 * font names as described above.  Be sure that a forward slash precedes each font name!</p>
	 * 
	 * @see PSDoc#unicodeToPostscriptText(String)
	 */
	private final static String MAKECOMPFONT = "makeCompositeFont";

	/**
    * This prolog procedure fills the current path with a linear axial gradient pattern representing a "color map" as
    * defined by an array of "key frames" and corresponding "key colors". All supported color maps in FC are defined by 
    * key frame/color arrays, with piecewise linear interpolation of the R/G/B color components between key frames.
    * 
    * <p>Color varies linearly along the straight line segment connecting endpoints (x0,y0) and (x1,y1), and extends
    * indefinitely perpendicular to the line segment. In addition, the first color in the key color array applies to all 
    * points in the filled path that are "before" (x0,y0), while the last color applies to points "after" (x1,y1); in 
    * other words, the gradient is NOT cyclic.</p>
    * 
    * <p>By convention, <b>PSDoc</b> sets the current stroke color as the current color in the graphics state. This 
    * procedure may be invoked to temporarily install a gradient pattern as the current color and use it to fill the
    * current path. To restore the stroke color after the fill is completed, ALWAYS bracket an invocation of this
    * procedure with a "gsave-grestore" pair.</p>
    * 
    * <p>Postscript syntax: <i>coords keyFrames keyColors cmapFill --</i>, where:
    * <ul>
    * <li><i>coords</i> is an array [x0 y0 x1 y1] defining the endpoints of the gradient's axis. Points along the line
    * map to a normalized parameter T which, in turn, selects a color from the defined color gradient. The points are in 
    * user space coordinates.</li>
    * <li><i>keyFrames</i> is an array [0 k1 k2 ... kN 1], 0 < k1 < k2 < .. < kN < 1, defining the color map's key 
    * frames, where the computed color should exactly match the corresponding key color. Note that the first key frame
    * is always 0 and the last is always 1.</li>
    * <li><i>keyColors</i> is an array [C(0) .. C(N+1)], where each element C(i) is a 3-element array defining the key
    * color [r g b] at key frame k(i). The color components r, g, and b must all lie in [0..1].</li>
    * </ul>
    * </p>
	 */
	private final static String CMAPFILL = "cmapFill";
	
	/**
	 * This prolog procedure implements an 8-bit lookup table for a "color map" as defined by an array of "key frames"
	 * and corresponding "key colors". All supported color maps in FC are defined by key frame/color arrays, with 
	 * piecewise linear interpolation of the R/G/B color components between key frames. This method takes the key frames
	 * and colors as arguments, along with an integer index N in [0..255], and computes the RGB color corresponding to
	 * that index. It is currently used only to render indexed-color images in a <b>PSDoc</b> instance.
	 * 
	 * <p>Postscript syntax: <i>N rgb0 keyFrames keyColors cmapLUT r g b</i>, where:
    * <ul>
    * <li><i>N</i> is an integer index into the color map LUT. It must lie in [0..255].</li>
    * <li><i>rgb0</i> is a substitute color for index 0. It may be null, in which case lookup table color at index 0 is 
    * returned. Otherwise, it must be a 3-element array [r g b], where the color components all lie in [0..1].</li>
    * <li><i>keyFrames</i> is an array [0 k1 k2 ... kN 1], 0 < k1 < k2 < .. < kN < 1, defining the color map's key 
    * frames, where the computed color should exactly match the corresponding key color. Note that the first key frame
    * is always 0 and the last is always 1.</li>
    * <li><i>keyColors</i> is an array [C(0) .. C(N+1)], where each element C(i) is a 3-element array defining the key
    * color [r g b] at key frame k(i). The color components r, g, and b must all lie in [0..1].</li>
    * </ul>
    * The procedure pushes onto the operand stack the red, green and blue components of the LUT color corresponding to 
    * index N. If N==0 and <i>rgb0 != null</i>, then it pushes the 3 elements of that array onto the stack.
    * </p>
	 */
	private final static String CMAPLUT = "cmapLUT";

	/**
	 * The dash-gap pattern representing a solid stroke. Can use this as a defined constant rather than passing a 
	 * new empty integer array.
	 */
	public final static int[] SOLIDLINE = new int[0];

	/**
	 * A partial representation of a "graphics state" in the Postscript interpreter. It maintains only a small subset 
	 * of the actual graphics state maintained in the interpreter. Its main purpose is to keep track of the current 
	 * state of the various draw/text styles that can be inherited in the <em>DataNav</em> element hierarchy:  text/fill 
	 * color, stroke color, stroke width, stroke endcap style, stroke join style, stroke dash-gap pattern, the "stroking 
	 * enabled" flag, font face name, and font size. This helps minimize how often we need to change graphics state 
	 * attributes via calls to "setcolor", "setlinewidth", "selectfont", etc.
	 * 
	 * <p>While Postscript does not support transparency, FypML does allow a fully transparent color (alpha = 0) for the
	 * stroke and text/fill color attributes -- primarily to support hollow symbols and shapes. This graphics state 
	 * object maintains flags indicating whether the current text/fill and stroke colors are transparent. Drawing methods
	 * will check these flags and adjust their behavior accordingly. An alternative means of achieving a transparent
	 * stroke is to set the stroke width to zero.</p>
	 * 
	 * @author sruffner
	 */
	private class GraphicsState
	{
		/**
		 * The font face name for the currently selected font in this <code>GraphicsState</code> (e.g., 
       * "Helvetica-Italic"). Note that font usage is restricted to the set of 32 Latin font faces that are part of the 
       * PS Level 2 "Standard 35" font set.
		 * 
		 * @see	PSDoc#isRecognizedFontFace(String)
		 */
		String fontName;

		/**
		 * The current font size in user units. By convention in <code>PSDoc</code>, user units are always milli-inches.  
		 */
		double fontSize;

		/**
		 * The current text/fill color in this <code>GraphicsState</code>, as a packed RGB integer (0x00RRGGBB).
		 */
		int textFillColor;

		/** True if text/fill color is opaque; else transparent. In latter case, {@link #textFillColor} is meaningless. */
      boolean isOpaqueTextFill;
      
		/**
		 * The current stroke color in this <code>GraphicsState</code>, as a packed RGB integer (0x00RRGGBB). By 
       * convention, this is always set as the current color in the Postscript interpreter's graphics state. When 
       * rendering text or filling the current path, it is temporarily supplanted by the current text/fill color, which 
       * is stored in a prolog-defined variable.
		 */
		int strokeColor;

      /** 
       * True if stroke color is opaque; else transparent. In latter case, {@link #strokeColor} is meaningless and
       * stroking is disabled.
       */
      boolean isOpaqueStroke;
      
		/**
		 * The current line or stroke width for this <code>GraphicsState</code>, in milli-inches. In <code>PSDoc</code>, 
       * it is assumed that one user unit ALWAYS equal 0.001 in. If zero, then stroking is DISABLED (in <i>DataNav</i> 
       * a zero line width does NOT correspond to the thinnest possible line, as it does in Postscript).
		 */
		double lineWidth;

		/** 
		 * The current endcap style used when stroking the endpoints of an open path or dash segments. Possible values are
		 * those expected by the PS command <i>setlinecap</i>: 0 (butt-ended), 1 (round projection with diameter = current 
		 * line width), and 2 (square projection extending beyond butt end by 1/2 the current line width.
		 */
		int linecap;
		
      /** 
       * The current style used to join adjacent, non-colinear segments of a path or to joint the endpoints of a closed
       * path. Possible values are those expected by the PS command <i>setlinejoin</i>: 0 (mitered join), 1 (rounded 
       * join), and 2 (beveled join). By default, mitered joins are converted to beveled joins whenever the ratio of
       * miter length to line width exceeds 10 (the default miter limit is Postscript).
       */
		int linejoin;
		
		/**
		 * The current dash pattern applied when a path is stroked. This is an alternating series of dash lengths and 
		 * gap lengths that can be up to 11 elements long. Dash and gap lengths are expressed in user units, which are 
		 * assumed to be milli-in in <code>PSDoc</code>. Initially set to an empty array, which corresponds to a solid 
       * stroke.
		 */
		int[] dashPattern;

		/**
		 * The current offset, in user units, into the stroke dash pattern. Initially 0. Ignored if dash pattern 
		 * corresponds to a solid stroke.
		 */
		int dashOffset;

		/**
		 * Construct a <code>GraphicsState</code> representing the default "startup" state of the Postscript interpreter 
       * IAW the Postscript Language Reference, with some changes made by <code>PSDoc</code> as noted.
		 * <ul>
		 * 	<li>The current font: Initially undefined. Font face name is empty and font size is 0.001in.</li>
		 * 	<li>The current color is black. Both the stroke and text/fill color are set to black.</li>
		 * 	<li>The current linewidth is 1. This will initially be 1 point = 1/72 in. However, <code>PSDoc</code> 
       *    ALWAYS inserts an initial "scale" command at page-level such that a user unit = 0.001 in.</li>
       *    <li>Strokes are butt-ended with mitered joins. The miter limit is initialized to 5 by <code>PSDoc</code>
       *    and is never changed. All joints narrower than ~23deg will be beveled rather than mitered.</li>
		 *    <li>The stroke dash pattern is empty -- corresponding to a solid line.</li>
		 * </ul>
		 */
		GraphicsState()
		{
			this.fontName = "";
			this.fontSize = 1; 
			this.textFillColor = 0;
			this.isOpaqueTextFill = true;
			this.strokeColor = 0;
         this.isOpaqueStroke = true;
			this.lineWidth = 1;
			this.linecap = 0;
			this.linejoin = 0;
			this.dashPattern = SOLIDLINE;
			this.dashOffset = 0;
		}

		/**
		 * Construct a copy of the specified <code>GraphicsState</code>. This is useful whenever we need to push the 
       * current <code>GraphicsState</code> object onto the graphics state stack prior to making changes to the 
		 * current state.
		 * 
		 * @param src The graphics state to be copied.
		 */
		GraphicsState(GraphicsState src)
		{
			this.fontName = src.fontName;
			this.fontSize = src.fontSize;
			this.textFillColor = src.textFillColor;
			this.isOpaqueTextFill = src.isOpaqueTextFill;
			this.strokeColor = src.strokeColor;
			this.isOpaqueStroke = src.isOpaqueStroke;
			this.lineWidth = src.lineWidth;
			this.linecap = src.linecap;
			this.linejoin = src.linejoin;
			this.dashOffset = src.dashOffset;
			if(src.dashPattern.length == 0)
				this.dashPattern = SOLIDLINE;
			else
			{
				this.dashPattern = new int[src.dashPattern.length];
            System.arraycopy(src.dashPattern, 0, this.dashPattern, 0, src.dashPattern.length);
			}
		}

		/**
		 * Change the face name and/or size of the current font installed in this <code>GraphicsState</code>, and prepare 
       * the Postscript language command that effects this change within the Postscript interpreter.
		 * 
		 * <p>If the font face changes, <code>PSDoc</code> does not select the specified font itself as the current font. 
       * Rather, it creates a composite font that can render any character in the character set supported by 
       * <code>PSDoc</code>. All composite fonts used in a particular <code>PSDoc</code> instance are defined in the 
       * document setup or page setup section of the generated Postscript program. By convention, they are named 
       * "/fontC", where "/font" is the name of the base font. This method merely composes the command to select the 
       * appropriate composite font and scale it to the specified size.</p>
		 * 
		 * @param face The desired font face. MUST be one of the standard font faces recognized by <code>PSDoc</code>. If 
       * it is a <code>null</code> or empty string, no changes are made to this <code>GraphicsState</code>, and an empty 
       * string is returned.
		 * @param size The desired size of the font in thousandth-inches.
		 * @return The command which will update the Postscript interpreter's graphics state appropriately. Will be empty 
       * string if no change was necessary.
		 * @throws IllegalArgumentException if the specified font face name is not recognized.
		 * @see PSDoc#isRecognizedFontFace(String)
		 */
		String changeFont(String face, double size) throws IllegalArgumentException
		{
			if( face == null || face.isEmpty()) return( "" );

			if( !isRecognizedFontFace(face) )
				throw new IllegalArgumentException( "Unsupported PS font name" );

			// we must update the font if the current font is undefined, if a new font face is specified, or if a 
			// different font size is specified
			String cmd = "";
			if( (size != fontSize) || !fontName.equals(face) )
			{
				if( !fontName.equals(face) )
				{
					// change the font face and make sure it is included in the list of fonts used in the PSDoc.
					fontName = face;
					fontsUsed.put( fontName, null );
				}
				fontSize = size;

				// by convention, PSDoc creates a composite font named "/fontC" for each supported Latin PS font "/font" 
				// that's used in the document.  The composite font is defined during document setup or page setup.  Here 
				// we merely select it as the current font at the specified size.
				cmd += "/" + fontName + "C " + Utilities.toString(fontSize,7,3) + " selectfont";
			}
			return( cmd );
		}

		/** Stroking is disabled if the current line width is 0 or the stroke color is transparent. */
		boolean isStrokingDisabled() { return(lineWidth == 0 || !isOpaqueStroke); }
		
		/**
		 * Change the current stroke properties (line width, line cap and join styles, dash-gap pattern and offset) 
		 * installed in this <code>GraphicsState</code>, and prepare the Postscript language command that effects this
		 * change within the Postscript interpreter.
		 * 
		 * @param w The new line width in thousandth-inches. If less than or equal to zero, stroking is disabled -- since 
       * zero stroke width is truly zero in DataNav PS (in standard PS a zero linewidth corresponds to the thinnest 
       * line that can be drawn by the PS device).
       * @param cap The new line endcap style. If not 0, 1, or 2, 0 (butt-ended) is assumed.
       * @param join The new line join style. If not 0, 1, or 2, 0 (mitered join) is assumed.
		 * @param pattern The new dash pattern. A <code>null</code>, empty, or single-element array indicates a solid, 
       * unbroken stroke. Otherwise, the array elements are interpreted as alternating dash and gap lengths in 0.001in. 
       * The array is copied internally as is, up to a length of <code>PSDoc.MAX_DASHPATTERNSIZE</code> elements.
		 * @param offset The new dash offset, an offset into the dash pattern in milli-inches.
		 * @return The command which will update the Postscript interpreter's graphics state appropriately. Will be an
		 * empty string if no change was necessary.
		 */
		String changeStrokeProperties(double w, int cap, int join, int[] pattern, int offset)
		{
			// handle changes in stroke width 
			String cmd = "";
         if(w < 0) w = 0;
			if(w != lineWidth)
			{
            boolean wasStrokingDisabled = (lineWidth == 0) || !isOpaqueStroke;
            lineWidth = w;
            boolean isStrokingDisabled = (lineWidth == 0) || !isOpaqueStroke;
            if(isStrokingDisabled && !wasStrokingDisabled) 
               cmd += "0 " + ENABLESTROKE + " 0 setlinewidth ";
            else if(wasStrokingDisabled && !isStrokingDisabled)
               cmd += "1 " + ENABLESTROKE + " " + Utilities.toString(lineWidth,7,3) + " setlinewidth ";
            else if(!isStrokingDisabled)
               cmd += Utilities.toString(lineWidth,7,3) + " setlinewidth ";
			}

			// handle changes in stroke endcap and join styles
         if(cap < 0 || cap > 2) cap = 0;
         if(cap != linecap)
         {
            linecap = cap;
            cmd += linecap + " setlinecap ";
         }
         if(join < 0 || join > 2) join = 0;
         if(join != linejoin)
         {
            linejoin = join;
            cmd += linejoin + " setlinejoin ";
         }
			
			// handle changes in stroke dash pattern 
         if(pattern == null || pattern.length < 2)
         {
            if(dashPattern != SOLIDLINE)
            {
               dashPattern = SOLIDLINE;
               dashOffset = 0;
               cmd += "[] 0 setdash ";
            }
         }
         else 
         {
            boolean identical = (dashOffset == offset && dashPattern.length == pattern.length);
            if(identical)
            {
               for(int i=0; i<dashPattern.length; i++) if(dashPattern[i] != pattern[i]) 
               {
                  identical = false;
                  break; 
               }
            }

            if(!identical)
            {
               dashOffset = offset;
               int n = pattern.length;
               if(n > MAX_DASHPATTERNSIZE) n = MAX_DASHPATTERNSIZE;
               if(dashPattern.length != n) dashPattern = new int[n];
               double sum = 0;
               for(int i=0; i<n; i++) 
               {
                  dashPattern[i] = Math.max(pattern[i], 0);
                  sum += dashPattern[i];
               } 
               if(sum == 0)
               {
                  // bad pattern -- all elements were zero.  Replace with solid line.
                  dashPattern = SOLIDLINE;
                  dashOffset = 0;
                  cmd += "[] 0 setdash";
               }
               else
                  cmd += "[" + Utilities.toString(dashPattern) + "] " + Utilities.toString(dashOffset,7,3) + " setdash";
            }
         }

			return(cmd);
		}

      /**
       * Prepare two Postscript language command strings: the first changes the stroke properties in this current 
       * graphics state to reflect the stroke specified by the {@link PSTransformable} argument, while the second undoes
       * any changes to restore the stroke properties of this graphics state. <b>NOTE that this graphics state object is
       * NOT altered by this method.</b>
       * 
       * <p>This method was introduced to support {@link PSDoc#renderStemmedAdornments}, so that the stems can be
       * stroked differently from the adornments. Because <i>DataNav</i> PS includes a custom state variable that
       * enables or disables the standard PS stroke operator, it is not sufficient to just use the 'gsave-grestore'
       * pair to preserve and restore the stroking properties.</p>
       * 
       * <p>If any changes are made in the current stroke properties, the command string that makes the changes will
       * start with 'gsave', while the command string that restores the original stroke will start with 'grestore' and,
       * if necessary, invoke the {@link PSDoc#ENABLESTROKE} to restore that custom variable that enables or disables
       * stroking. Of course, if the enable state is unchanged, the second command string is simply 'grestore'.</p>
       * 
       * @param pst A Postscript-transformable object.
       * @return A two-element string array. The first element is the command which would update the Postscript 
       * interpreter's graphics state appropriately, while the second element is the command which restores the original
       * stroking state. Both will be empty strings if no changes were necessary.
       */
      String[] prepareStrokeChangeAndRestoreCommands(PSTransformable pst)
      {
         int rgb = pst.getPSStrokeColor();
         boolean opaque = !pst.isPSNoStroke();
         double w = pst.getPSStrokeWidth();
         int cap = pst.getPSStrokeEndcap();
         int join = pst.getPSStrokeJoin();
         int[] pattern = pst.getPSStrokeDashPattern();
         int offset = pst.getPSStrokeDashOffset();
         
         StringBuilder sb = new StringBuilder();
         boolean wasStrokingDisabled = (lineWidth == 0) || !isOpaqueStroke;
         boolean isStrokingDisabled = wasStrokingDisabled;
         
         // handle change in stroke color
         if(strokeColor != rgb)
            sb.append(getRGBColorString(rgb)).append(isGray(strokeColor) ? " setgray " : " setrgbcolor ");

         // handle changes in stroke width or stroke opacity. Special case: Zero line width or transparent stroke will
         // disable stroking.
         if(w < 0) w = 0;
         if(w != lineWidth || isOpaqueStroke != opaque)
         {
            wasStrokingDisabled = (lineWidth == 0) || !isOpaqueStroke;
            isStrokingDisabled = (w == 0) || !opaque;
            if(isStrokingDisabled && !wasStrokingDisabled) 
               sb.append("0 ").append(ENABLESTROKE).append(" 0 setlinewidth ");
            else if(!isStrokingDisabled)
            {
               if(wasStrokingDisabled) sb.append("1 ").append(ENABLESTROKE).append(" ");
               sb.append(Utilities.toString(w,7,3)).append(" setlinewidth ");
            }
         }
         
         // handle changes in stroke endcap and join styles
         if(cap < 0 || cap > 2) cap = 0;
         if(cap != linecap) sb.append(cap).append(" setlinecap ");

         if(join < 0 || join > 2) join = 0;
         if(join != linejoin) sb.append(join).append(" setlinejoin ");
         
         // handle changes in stroke dash pattern 
         if(pattern == null || pattern.length < 2)
         {
            if(dashPattern != SOLIDLINE) sb.append("[] 0 setdash ");
         }
         else 
         {
            boolean identical = (dashOffset == offset && dashPattern.length == pattern.length);
            if(identical)
            {
               for(int i=0; i<dashPattern.length; i++) if(dashPattern[i] != pattern[i]) 
               {
                  identical = false;
                  break; 
               }
            }

            if(!identical)
            {
               int n = pattern.length;
               if(n > MAX_DASHPATTERNSIZE) n = MAX_DASHPATTERNSIZE;
               double sum = 0;
               for(int i=0; i<n; i++) sum += Math.max(pattern[i], 0);
               
               // if all elements are non-positive, then assume a solid line.
               if(sum == 0) sb.append("[] 0 setdash ");
               else
               {
                  sb.append("[").append(Utilities.toString(pattern)).append("] ");
                  sb.append(Utilities.toString(offset,7,3)).append(" setdash ");
               }
            }
         }

         // prepare the two command strings
         String[] out = new String[] { "", ""};
         if(sb.length() > 0)
         {
            out[0] = "gsave " + sb;
            out[1] = "grestore";
            if(wasStrokingDisabled != isStrokingDisabled)
               out[1] += ((wasStrokingDisabled) ? " 0 " : " 1 ") + ENABLESTROKE;
         }
         return(out);
      }

		/**
		 * Change the current stroke color and text/fill color installed in this <code>GraphicsState</code>, make the 
       * specified stroke color the current color, and prepare the Postscript language command that effects these 
       * changes within the Postscript interpreter. The method assumes that the current color in the graphics state is 
       * the stroke color defined when the method was invoked.
		 * 
		 * @param rgbStroke The desired stroke color as a packed RGB integer (0x00RRGGBB).
       * @param isOpaqueStroke True if desired stroke color is opaque; false if it is fully transparent. No graphics 
       * stroking operations are performed when stroke color is transparent.
		 * @param rgbFill The desired text/fill color as a packed RGB integer (0x00RRGGBB).
		 * @param isOpaqueFill True if desired text/fill color is opaque; false if it is fully transparent. No graphics
		 * fills are performed when the text/fill color is transparent.
		 * @return The command which will update the Postscript interpreter's graphics state appropriately. Will be 
		 * empty string if no change was necessary.
		 */
		String changeColors(int rgbStroke, boolean isOpaqueStroke, int rgbFill, boolean isOpaqueFill)
		{
			String cmd = "";
			if( strokeColor != rgbStroke )
			{
				strokeColor = rgbStroke;
				cmd += getRGBColorString(strokeColor) + (isGray(strokeColor) ? " setgray" : " setrgbcolor");
			}
			if(this.isOpaqueStroke != isOpaqueStroke)
			{
            boolean wasStrokingDisabled = (lineWidth == 0) || !this.isOpaqueStroke;
            this.isOpaqueStroke = isOpaqueStroke;
            boolean isStrokingDisabled = (lineWidth == 0) || !this.isOpaqueStroke;
				if(isStrokingDisabled != wasStrokingDisabled)
				{
					if(isStrokingDisabled)
						cmd += "0 " + ENABLESTROKE + " 0 setlinewidth ";
					else
						cmd += "1 " + ENABLESTROKE + " " + Utilities.toString(lineWidth,7,3) + " setlinewidth ";
				}
			}
			if( textFillColor != rgbFill )
			{
				textFillColor = rgbFill;
				if(!cmd.isEmpty()) cmd += " ";
				cmd += getRGBColorString(textFillColor) + (isGray(textFillColor) ? " 1 " : " 3 ") + SETFILLCOLOR;
			}
			
			this.isOpaqueTextFill = isOpaqueFill;
			return( cmd );
		}
	}


	/**
	 * Contains the face names of all Postscript fonts actually used to render text in this <code>PSDoc</code>. The face 
    * names are the keys of the map; the values are <code>null</code>. With this scheme it is easy to avoid duplicating 
    * a face name in the map when we accumulate fonts over multiple pages in a document.
	 */
	private final HashMap<String, String> fontsUsed = new HashMap<>();

	/** The number of printed pages in this <code>PSDoc</code>. */
	private int nPages = 0;

	/** Flag set when a new printed page is started. Prevents starting a new page before the previous one is done. */
	private boolean pageStarted = false;

	/** The page layout for each page generated by this <code>PSDoc</code>. */
	private final PageFormat pageLayout;

	/** Flag set when the <code>PSDoc</code> has been completed and is ready to be streamed to a file or printer. */
	private boolean done = false;

	/**
	 * Is this an encapsulated <code>PSDoc</code> (EPS)? If so, only a single printed page can be prepared. A second 
    * call to startPage() will throw an exception.
	 */
	private final boolean isEPS;

	/**
	 * The main body of the Postscript program. Postscript language commands are appended to this buffer by many 
	 * <code>PSDoc</code> methods. 
	 */
	private final StringBuffer mainBuf;

	/**
	 * The graphics state stack. As the main body of the program is "built", each time the "gsave" command is appended 
	 * to the program to save the graphics state in the Postscript interpreter, we push the corresponding 
    * <code>GraphicsState</code> object onto this stack, then pop one off the stack each time a "grestore" command is 
    * appended to the program buffer.
	 */
	private final Stack<GraphicsState> graphicsStack;

	/**
	 * A partial representation of the current graphics state in the <code>PSDoc</code>.
	 */
	private GraphicsState currentGraphics;

	/**
	 * The current indent level. 
	 */
	private int currentIndent = 0;


	/**
	 * Constructs an empty <code>PSDoc</code> that will generate a normal or encapsulated Postscript file. Our internal 
	 * representation of the graphics state is initialized to reflect the Postscript interpreter's default state. The 
    * bounding box is initialized to the printable rectangle defined by the page layout.
	 * 
	 * @param isEPS If <code>true</code>, this <code>PSDoc</code> will prepare an Encapsulated Postscript document. Only 
    * one page is allowed in this format. Otherwise a normal, possibly multi-page PS document will be generated.
	 * @param pgFmt The page layout applied to each page generated by this <code>PSDoc</code>.
	 */
	private PSDoc(boolean isEPS, PageFormat pgFmt)
	{
		this.isEPS = isEPS;
      pageLayout = pgFmt;
		mainBuf = new StringBuffer(500);
		graphicsStack = new Stack<>();

		// init our graphics state to reflect the Postscript interpreter's defaults
		currentGraphics = new GraphicsState(); 

      // init the bounding box to the page layout's printable rectangle
      double left = pageLayout.getImageableX();
      double bot = pageLayout.getHeight() - pageLayout.getImageableY() - pageLayout.getImageableHeight();
      boundBox = new Rectangle2D.Double(left, bot, pageLayout.getImageableWidth(), pageLayout.getImageableHeight());
      
		// the Common procset is included in the prolog of all Postscript files generated by PSDoc
		procSetsUsed = new HashMap<>();
		procSetsUsed.put(PROCSET_COMMON, null);
	}

	/**
	 * Create a single-page Postscript language program that renders the specified Postscript transformable graphic.
	 * 
	 * @param pst The graphic object that is to be rendered in Postscript on a single page.
	 * @throws UnsupportedOperationException if the page description could not be generated for any reason.
	 */
	private void createPage(PSTransformable pst) throws UnsupportedOperationException
	{
		pst.toPostscript(this);
		endPage();
		done = true;
	}

   /**
    * Rectangle bounding all marks rendered in this <code>PSDoc</code>, in default Postscript coordinates. Because 
    * y-axis increases upward in PS (and <em>DataNav</em>) conventions, this <code>Rectangle2D</code>'s "top left" 
    * corner is really the bottom-left.
    */
   private Rectangle2D boundBox;

   /**
    * Set the rectangle bounding all marks rendered in this <code>PSDoc</code>, in default Postscript coordinates. 
    * Because the y-axis increases upward in PS (and <em>DataNav</em>) conventions, the rectangle's "top left" corner 
    * is really the bottom-left.
    * 
    * <p>The bounding box is reported in the DSC header comment "%%BoundingBox" and is most important in an EPS file, 
    * since applications that import and/or embed the file may rely on the bounding box information for scaling and 
    * placement purposes. If this method is never called, <code>PSDoc</code> will assume the bounding box is the same 
    * as the printable rectangle defined by its page layout.</p>
    * 
    * @param r The new bounding rectangle. A <code>null</code> value is ignored.
    */
   public void setBoundingBox(Rectangle2D r) { if(r != null) boundBox = r; }
   
	/**
	 * Begin the Postscript language description of a printed page.
	 * 
    * <p>The default Postscript user space for a page places the origins at the physical page's very bottom-left corner, 
    * with x-axis increasing rightward, y-axis increasing upward, and user units in points (1/72in). <em>DataNav</em> 
    * convention is similar except that units are always milli-inches. Also, a figure is always positioned WRT the 
    * bottom-left corner of the printable rectangle as defined by the page layout.</p>
    * 
    * <p>This method transforms the default Postscript user space to the page-level coordinate system assumed for a 
    * <em>DataNav</em> figure. First, user space is scaled so that units are milli-inches. Then, based on the margins 
    * and dimensions of the page's printable rectangle, the origin is moved so that it lies at the bottom-left corner 
    * of that rectangle, and the clipping path is set to the printable rectangle -- so nothing can be drawn outside the 
    * page margins. In landscape orientation, user space must be rotated and translated appropriately.</p>
	 * 
	 * <p>The miter limit is explicitly set to 5 by this method. While the PS Language Reference states that the default 
    * is 10, we choose to set it explicitly in case different interpreters (eg, Adobe Illustrator) have different 
    * defaults. A mitre limit of 5, corresponding to a minimum mitred corner angle of 23deg, is sufficient for the 
    * purposes of <code>PSDoc</code> (eg, none of the adornments have mitred corners that are &lt; 23deg!).</p>
	 * 
	 * <p>All graphics methods invoked between this method and a subsequent matching call to endPage() will render 
	 * graphics to the same printed page.</p>
	 * 
	 * @see PSDoc#endPage()
	 * @param pst The Postscript-transformable object that will be rendered on the new page.
	 * @throws UnsupportedOperationException if the graphics state stack is full, or if this is the second page of an 
	 * Encapsulated Postscript (EPS) document.
	 */
	public void startPage(PSTransformable pst) throws UnsupportedOperationException
	{
		if( graphicsStack.size() == MAX_GSTATE_DEPTH )
			throw new UnsupportedOperationException( GSOVFL_EXCP );
		if( isEPS && nPages > 0 )
			throw new UnsupportedOperationException( "Encapsulated PS document can only contain ONE page!" );

		// make sure we're done with a previous page, if any, before starting this one
		endPage();
		appendLine( "" );
		++nPages;
		pageStarted = true;

		// update the store of fonts used in document to include fonts used on this page
      Map<String, String> pgFonts = new HashMap<>();
		pst.getAllPSFontFacesUsed(pgFonts, true);
      Set<String> fontFacesOnPage = pgFonts.keySet();
		for(String face : fontFacesOnPage) fontsUsed.put(face, null);

		// prepare DSC page header
		appendLine( "%%Page: " + nPages + " " + nPages );
		appendLine( "% " + pst.getPSComment() );
		String ori = "Portrait";
		if(pageLayout.getOrientation()==PageFormat.LANDSCAPE || pageLayout.getOrientation()==PageFormat.REVERSE_LANDSCAPE)
		   ori = "Landscape";
		appendLine( "%%PageOrientation: " + ori );

		// list font resources used on page.  five fonts per line, and we'll be safely under the line length limit.
      if(!fontFacesOnPage.isEmpty())
      {
         int i = 0;
         StringBuilder line = new StringBuilder("%%PageResources: font ");
         for(String face : fontFacesOnPage)
         {
            line.append(face).append(" ");
            if(i>0 && ((i%5) == 0))
            {
               appendLine(line.toString());
               line = new StringBuilder("%%+ font ");
            }
            ++i;
         }
         if(line.length() > "%%+ font ".length()) appendLine(line.toString());
      }

		// page setup:
		// DSC comments to include font resources not included in document setup
		appendLine( "%%BeginPageSetup" );
		for(String face : fontFacesOnPage) if(!isBasicFont(face))
		{
			appendLine( "%%IncludeResource: font " + face );
		}

		// page is sandwiched in a "save-restore" pair so we can recover VM used while preparing the page
		appendLine( "/pgSave save def" );
		GraphicsState copy = new GraphicsState( currentGraphics );
		graphicsStack.push( currentGraphics );
		currentGraphics = copy;

		// convert user space units to thousandth-inches; 72 pts per 1000 milli-inches. If in landscape mode, we need to
      // rotate user space 90 deg CCW so that x-axis lies along "long" edge of page. But, as a result, the x-axis is now
	   // at the top of the landscape-oriented page, so we must translate down by the oriented page height (the page 
		// width in portrait mode!) to put the origin back at the bottom-left corner of the landscape page! 
		String cmd = "0.072 0.072 scale";
		if(pageLayout.getOrientation() != PageFormat.PORTRAIT) 
		   cmd = String.format("90 rotate 0 %d translate 0.072 0.072 scale", (int) -pageLayout.getHeight());
		appendLine(cmd); 

		// create all composite fonts that will be used to render text on the page
		for(String face : fontFacesOnPage)
		{
			cmd = "/" + face + "C /" + face + "ISO /" + face + " " + MAKECOMPFONT;
			appendLine(cmd);
		}

		// set default miter limit to 5. We set it explicitly in case different interpreters have different defaults.
		appendLine( "5 setmiterlimit" );
		appendLine( "%%EndPageSetup" );

		// update graphics state to reflect properties of the page element
		updateCurrentGraphicsState( pst );

		// establish the page's imageable rectangle as the current clipping viewport. The default PS origin is moved to 
		// the bottom left corner of the imageable rectangle. Unfortunately, PageFormat gives us the TL corner of the 
      // imageable rectangle in points (1/72in) WRT TL corner of the oriented page, with the y-axis increasing downward.
      // Thus, the y-coord of imageable rectangle in PS coords is (pageH-imageableH-yImageable). All calcs are in 
      // milli-in because we've already scaled user space above.
		final double PT_TO_MILLI_IN = 1000.0 / 72.0;
		double w = pageLayout.getImageableWidth() * PT_TO_MILLI_IN;
		double h = pageLayout.getImageableHeight() * PT_TO_MILLI_IN;
		double x = pageLayout.getImageableX() * PT_TO_MILLI_IN;
		double y = pageLayout.getImageableY() * PT_TO_MILLI_IN;
		y = pageLayout.getHeight() * PT_TO_MILLI_IN  - h - y;
		setViewport(new Point2D.Double(x, y), w, h, 0, true);
	}

	/**
	 * Finish the current page and issue a Postscript "showpage" command, transmitting the page contents to the current 
	 * output device -- "printing" it. In a correctly constructed <code>PSDoc</code>, this method essentially returns the 
    * Postscript interpreter to the state it was in prior to the most recent call to <code>startPage()</code>, which 
    * started the definition of the current page.
	 * 
	 * @see PSDoc#startPage(PSTransformable)
	 * @throws UnsupportedOperationException if the graphics state stack is empty, probably an indication that this 
	 * method was invoked without a matching call to <code>startPage()</code>.
	 */
	public void endPage() throws UnsupportedOperationException
	{
		if( pageStarted )
		{
			if(graphicsStack.isEmpty())
				throw new UnsupportedOperationException( GSUNFL_EXCP );

			pageStarted = false;
			appendLine( "pgSave restore" );
			currentGraphics = graphicsStack.pop();
			appendLine( "showpage" );
			appendLine( "" );
		}
	}

	/**
	 * Return a copy of the page layout applied to each page built by this <code>PSDoc<c/ode>. The page layout is 
    * specified at construction time and cannot be changed.
	 * 
	 * @return The page layout for this <code>PSDoc</code>.
	 */
	public PageFormat getPageFormat()
	{
		return((PageFormat) pageLayout.clone());
	}

	/**
	 * Mark the beginning of the Postscript code fragment that will render an element in a <em>DataNav</em> document 
	 * hierarchy. Since most <em>DataNav</em> elements can specify their own graphics styles, this method pushes the 
	 * current graphics state onto the graphics state stack and then updates it to reflect the graphics style defined 
	 * on the specified element. For readability purposes, the indent level is incremented and a newline is appended to 
	 * the main body of the Postscript program.
	 * 
	 * <p>Each invocation of this method must be matched with a later call to endElement(); otherwise, the graphics 
	 * state stack will be corrupted and the document will not print correctly, if at all.</p>
	 * 
	 * <p>It is implicitly assumed that the "element" is rendered on the current page of the <code>PSDoc</code>. 
	 * @param element The object to be rendered next into this <code>PSDoc</code>.
	 * @throws UnsupportedOperationException if the graphics state stack is full, or there's no current page context.
    * @see PSDoc#endElement()
	 */
	public void startElement(PSTransformable element) throws UnsupportedOperationException 
	{
	   startElement(element, element, false);
	}

	/**
	 * Same as {@link #startElement}, except that the graphics state is updated IAW a different element, and the
	 * element comment may be optionally omitted.
	 * @param element The object to be rendered next into this <code>PSDoc</code>.
	 * @param elState A different object (could be the same one) defining how the graphics state should be configured.
	 * @param omitComment If true, the comment line identifying element is omitted from the PS document.
	 * @throws UnsupportedOperationException if the graphics state stack is full, or there's no current page context.
	 */
	public void startElement(PSTransformable element, PSTransformable elState, boolean omitComment) 
	      throws UnsupportedOperationException
	{
      if(!pageStarted) throw new UnsupportedOperationException( NOPAGE_EXCP );

      appendLine( "" );
      incrementIndent();

      if(!omitComment) appendLine( "% " + element.getPSComment() );

      saveGraphicsState();
      updateCurrentGraphicsState( elState );
	}
	
	/**
	 * Marks the end of a Postscript code fragment, initiated by a matching call to <code>startElement()</code>, that 
    * renders a <code>PSTransformable</code> element in a <em>DataNav</em> document. This method restores the graphics 
    * state to what it was prior to starting the element's definition, and it decrements the indent level.
	 * 
	 * @throws UnsupportedOperationException if the graphics state stack is empty, probably an indication that this 
	 * method was invoked without a matching call to <code>startElement()</code>.
	 */
	public void endElement()
	{
		restoreGraphicsState();
		decrementIndent();
		appendLine( "" );
	}

	/**
	 * Increment the current indent level for the main body of the Postscript program generated by this 
    * <code>PSDoc</code>. Since the indent level is automatically incremented each time a new element is started, use 
    * this method and <code>decrementIndent()</code> only to adjust the indent level within the definition of a given 
    * element.
	 */
	public void incrementIndent()
	{
		++currentIndent;
	}

	/** 
	 * Decrement the current indent level for the main body of the Postscript program generated by this 
    * <code>PSDoc</code>.
	 * 
	 * @see PSDoc#incrementIndent()
	 */
	public void decrementIndent()
	{
		--currentIndent;
	}

	/**
	 * Appends the specified comment string as a separate line (at the current indent level) in the main body of the 
	 * Postscript program generated by this <code>PSDoc</code>. 
	 * 
	 * @param comment The comment string. It need not begin with the Postscript comment delimiter '%', since the 
	 * method will prepend that delimiter anyway. If <code>null</code> or empty string, method does nothing.
	 */
	public void addComment(String comment)
	{
		if(comment != null && !comment.isEmpty())
			appendLine( "% " + comment );
	}

	/**
	 * Insert an empty line at the current position in the main body of the Postscript program generated by this 
    * <code>PSDoc</code>. Use this method to improve the readability of the Postscript program.
	 */
	public void newLine()
	{
		appendLine( "" );
	}

	/**
	 * Save the current graphics state by pushing it onto the graphics state stack. This is accomplished by appending a
	 * Postscript "gsave" command to the program buffer. A partial internal representation of the graphics state is 
	 * also saved -- so that we can track changes in the graphics state as the Postscript program is built.
	 * 
	 * <p>To maintain the integrity of the graphics state stack, a call to this method should always be matched by a 
	 * subsequent call to <code>restoreGraphicsState()</code>.</p>
	 * 
	 * @throws UnsupportedOperationException if the graphics state stack is full.
	 */
	void saveGraphicsState() throws UnsupportedOperationException
	{
		if( graphicsStack.size() == MAX_GSTATE_DEPTH )
			throw new UnsupportedOperationException( GSOVFL_EXCP );

		appendLine( "gsave" );
		GraphicsState copy = new GraphicsState( currentGraphics );
		graphicsStack.push( currentGraphics );
		currentGraphics = copy;
	}

	/**
	 * Restore the current graphics state by popping it off the graphics state stack. This is accomplished by appending 
	 * a Postscript "grestore" command to the program buffer. 
	 * 
	 * <p>Since <code>PSDoc</code> uses several prolog variables to maintain additional <em>DataNav</em>-specific 
    * graphics state info, this method must also explicitly issue commands that restore the state of these prolog 
    * variables. The "grestore" command only restores the native graphics state of the PS interpreter.</p>
	 * 
	 * @throws UnsupportedOperationException if the graphics state stack is empty.
    * @see PSDoc#saveGraphicsState()
	 */
	void restoreGraphicsState() throws UnsupportedOperationException
	{
		if(graphicsStack.isEmpty())
			throw new UnsupportedOperationException( GSUNFL_EXCP );

		// remember the old text/fill color before restoring
		int oldC = currentGraphics.textFillColor;

		// was stroking disabled in the old graphics state?
      boolean wasStrokingDisabled = (currentGraphics.lineWidth == 0);

		// revert to previous graphics state
		currentGraphics = graphicsStack.pop();
		String cmd = "grestore";

		// PSDoc maintains the current text/fill color -- which is not part of the interpreter's graphics state -- 
		// in a prolog variable. When we restore to a previous graphics state, we have to manually restore this prolog 
		// variable to its previous value! 
		int c = currentGraphics.textFillColor;
		if(c != oldC) cmd += " " + getRGBColorString(c) + (isGray(c) ? " 1 " : " 3 ") + SETFILLCOLOR;

		// after restoring, enable or disable stroking if necessary.
      boolean strokingDisabled = (currentGraphics.lineWidth == 0);
      if(wasStrokingDisabled != strokingDisabled)
         cmd += ((strokingDisabled) ? " 0 " : " 1 ") + ENABLESTROKE;

		// effect the necessary changes in the Postscript interpreter
		appendLine(cmd);
	}

	/**
	 * Save a snapshot of the interpreter's VM, including the graphics state, by issuing the PS "save" command. Since 
	 * "save" also saves the graphics state, the method must also save <code>PSDoc</code>'s partial internal 
    * representation of the graphics state, <code>PSDoc.GraphicsState</code>, by pushing it onto a stack -- so that 
    * this internal representation stays in synch with the PS interpreter's actual graphics state.
	 * 
	 * <p>To maintain the integrity of the graphics state stack and the interpreter VM, a call to this method must always 
	 * be matched by a subsequent call to <code>restoreVMState()</code>.</p>
	 * 
	 * @throws UnsupportedOperationException if the graphics state stack is full.
	 */
	private void saveVMState() throws UnsupportedOperationException
	{
		if(graphicsStack.size() == MAX_GSTATE_DEPTH)
			throw new UnsupportedOperationException( GSOVFL_EXCP );

		appendLine( "save" );
		GraphicsState copy = new GraphicsState( currentGraphics );
		graphicsStack.push( currentGraphics );
		currentGraphics = copy;
	}

	/**
	 * Restore the last saved snapshot of the interpreter's VM, including graphics state, by issuing the PS "restore" 
	 * command. The method also restores <code>PSDoc</code>'s partial representation of the graphics state by popping it 
    * off the graphics state stack. 
	 * 
	 * <p>Since the "restore" command restores a VM snapshot, the special prolog variables we use for <em>DataNav</em>-
	 * specific graphics state information are also restored. Therefore, it is unnecessary and incorrect to issue the 
	 * commands which restore these prolog variables -- as is done in restoreGraphicsState().</p>
	 * 
	 * @throws UnsupportedOperationException if the graphics state stack is empty.
    * @see PSDoc#saveVMState()
	 */
	private void restoreVMState() throws UnsupportedOperationException
	{
		if(graphicsStack.isEmpty())
			throw new UnsupportedOperationException( GSUNFL_EXCP );

		currentGraphics = graphicsStack.pop();
		appendLine( "restore" );
	}

	/**
	 * Paint the specified text at the specified location, using the current font and text/fill color. Adjust text 
	 * starting position IAW the desired horizontal and vertical alignment. Text is rendered on a horizontal baseline 
	 * from left to right. <i>If the current text/fill color is transparent, no action is taken.</i>
	 * 
	 * <p>This method ultimately uses the Postscript "show" procedure to paint the text. <b>PSDoc</b> is designed to
    * support text strings that contain characters available via the built-in StandardEncoding and ISOLatin1Encoding 
    * schemes, as well as characters from the custom Symbol character set. To do so, the current font is set to a 
    * composite font (Level 2 feature) that includes three base fonts:
	 * <ul>
	 * 	<li>index 0: Desired base font using the default StandardEncoding.</li>
	 * 	<li>index 1: Desired base font using the ISOLatin1Encoding.</li>
	 * 	<li>index 2: Symbol font using its own custom encoding.</li>
	 * </ul>
	 * <p>See the Postscript Language Reference for the details on the available character sets. Since the text string 
	 * argument is encoded as 16-bit Unicode, <b>PSDoc</b> transforms it into a form that's ready for showing with 
    * this composite font.  See {@link #unicodeToPostscriptText}.</p>
	 * 
	 * <p>To vertically center the text about the specified y-coord, it pushes the baseline down by 1/3 the current font 
	 * size. To align the "top" of the text with the specified y-coord, it pushes the baseline down by 2/3 the font 
	 * size. These "rules of thumb" work reasonably well for typical Latin fonts, and the aligned text looks best if 
	 * the characters are similarly sized (eg, all capitals or all digits).</p>
	 * 
	 * <p>As of FC v5.4.0, this method supports rendering "attributed text", in which font style, text color, underline
	 * on/off, and superscript/subscript state can vary on a character-by-character basis within the text. In FC, 
	 * attributed text is encoded in a plain text string in a prescribed manner. For details, see the helper method
	 * {@link #parseAttributedText}
	 * 
	 * <p>IMPORTANT:  The Postscript fonts, by default, design their glyphs assuming a user space in which the y-axis 
	 * increases upward -- which is the default convention in the Postscript interpreter. If the y-axis happens to be 
    * inverted in the user space in which the text is rendered, the text will appear upsided down.</p>
	 * 
	 * @param text The text to be painted.
	 * @param x The x-coord of text starting position in user space.
	 * @param y The y-coord of text starting position in user space.
	 * @param hAlign Desired horizontal alignment.
	 * @param vAlign Desired vertical alignment.
	 * @throws UnsupportedOperationException if graphics state stack overflows or if there's no current page context.
	 */
	public void renderText(String text, double x, double y, TextAlign hAlign, TextAlign vAlign)
		throws UnsupportedOperationException
	{
		// all rendering occurs in the context of a printed page
		if( !pageStarted ) throw new UnsupportedOperationException( NOPAGE_EXCP );

		// if text string is empty or current text color is transparent, then nothing is rendered.
		if((text==null) || text.isEmpty() || !currentGraphics.isOpaqueTextFill) return;
		
		List<String> tokens = parseAttributedText(text);
		if(tokens.size() == 1)  // plain text
		{
	      // the showStr prolog procedure requires one open spot on the graphics state stack
	      if( graphicsStack.size() == MAX_GSTATE_DEPTH ) throw new UnsupportedOperationException( GSOVFL_EXCP );

	      // adjust vertical pos of text based on vertical alignment.  the default is bottom alignment, for which no adj is 
	      // made.  for top and center alignment, the rule of thumb is to push down the baseline by 67% and 33% of the 
	      // font size.  this works reasonably well for typical Latin fonts.
	      if(vAlign != TextAlign.TRAILING)
	      {
	         double adj = currentGraphics.fontSize / 3.0;
	         if(vAlign == TextAlign.LEADING) adj *= 2.0;
	         y -= adj;
	      }

	      // invoke prolog procedure which paints the text string: useFill? str hAlign x y showStr --.  This procedure 
	      // handles horizontal alignment, since that adjustment requires font info to compute string width.
	      includeFunctionInProlog(SHOWSTRING);
	      int ha = 1;
	      if(hAlign == TextAlign.CENTERED) ha = 0;
	      else if(hAlign == TextAlign.TRAILING) ha = -1;
	      String cmd = String.format("1 (%s) %d %s %s %s", unicodeToPostscriptText(text), ha,
	            Utilities.toString(x,7,3), Utilities.toString(y,7,3), SHOWSTRING);
	      appendLine( cmd );
		}
		else  // attributed text
		{
	      // ensure there's enough room on the graphics state stack. Need two for the SHOWTEXTRUNS and one for the VM
	      // save state so we can recover virtual memory allocated to DATA0 below.
	      if(graphicsStack.size() > MAX_GSTATE_DEPTH-3) throw new UnsupportedOperationException(GSOVFL_EXCP);

	      // convert the Unicode text for each text run into Postscript-compatible text with enclosing (). Also, check
	      // to see if any text run contains superscript or subscript characters?
	      boolean usesSuperscript = false;
	      boolean usesSubscript = false;
	      for(int i=0; i<tokens.size(); i+=5)
	      {
	         tokens.set(i+4, String.format("(%s)", unicodeToPostscriptText(tokens.get(i+4))));
	         if("1".equals(tokens.get(i+2))) usesSuperscript = true;
	         else if("-1".equals(tokens.get(i+2))) usesSubscript = true;
	      }
	      
	      // adjust vertical pos of text based on vertical alignment. The default is bottom alignment, for which no adj 
	      // is made. For top and center alignment, the rule of thumb is to push down the baseline by 67% and 33% of the 
	      // font size. This works reasonably well for typical Latin fonts, but it's more complicated if the attributed
	      // text includes superscript and/or subscript characters. If S is the nominal font size, super/subscript chars
	      // are rendered at a font size of 0.58*S, superscript character baseline is 0.4*S above normal baseline, and 
	      // subscript character baseline is at 0.33*S below normal baseline...
	      if(vAlign != TextAlign.TRAILING)
	      {
	         double scale;
	         if(vAlign == TextAlign.LEADING)
	            scale = usesSuperscript ? (0.4 + 2.0 * 0.58 / 3.0) : (2.0/3.0);
	         else
	         {
	            scale = 1.0/3.0;
	            if(usesSuperscript)
	               scale = (0.4 + 2.0 * 0.58 / 3.0) / 2.0;
	            if(usesSubscript) 
	               scale -= 1.0/6.0;
	         }
	         y -= scale * currentGraphics.fontSize;
	      }

	      // mark start of code fragment with a comment for better readability
	      addComment("renderAttributedText");

	      // populate DATA0 array with the tokens. It will be processed by the prolog procedure that renders the attributed
	      // text as a sequence of text runs on the same baseline. We save the VM state first so we can recover the memory 
	      // allocated afterwards.
	      saveVMState();
	      loadArray(DATA0, tokens, false);
	      
	      includeFunctionInProlog(SHOWTEXTRUNS);
	      int ha = 1;
	      if(hAlign == TextAlign.CENTERED) ha = 0;
	      else if(hAlign == TextAlign.TRAILING) ha = -1;
	      String cmd = String.format("%s %s %d %s %s %s", Utilities.toString(x,7,3), Utilities.toString(y,7,3), ha,
	            Utilities.toString(currentGraphics.fontSize, 7, 3), DATA0, SHOWTEXTRUNS);
	      appendLine(cmd);

	      // recover the allocated array and mark end of code fragment with a comment
	      loadArray(DATA0, null, false);
	      restoreVMState();
	      addComment("END renderAttributedText");
		   
		}
	}

	/**
	 * Same as {@link #renderText(String, double, double, TextAlign, TextAlign)}, except that string may be rendered in a 
    * different color than what is defined in the current graphics state.
	 * 
	 * @param text The text to be painted.
	 * @param x The x-coord of text starting position in user space.
	 * @param y The y-coord of text starting position in user space.
	 * @param hAlign Desired horizontal alignment.
	 * @param vAlign Desired vertical alignment.
	 * @param fillC The desired text color (alpha component ignored). If null, opaque black is assumed
	 * @throws UnsupportedOperationException if graphics state stack overflows or if there's no current page context.
	 */
	public void renderText( String text, double x, double y, TextAlign hAlign, TextAlign vAlign, Color fillC)
		throws UnsupportedOperationException
	{
		// remember old text color
		int oldTextRGB = currentGraphics.textFillColor;
		boolean oldTextOpaque = currentGraphics.isOpaqueTextFill;
		
		// change text color temporarily
		int rgb = (fillC != null) ? (0x00FFFFFF & fillC.getRGB()) : 0;
		String cmd = currentGraphics.changeColors(currentGraphics.strokeColor, currentGraphics.isOpaqueStroke, rgb, true);
		if(!cmd.isEmpty()) appendLine(cmd);

		// draw the text
		renderText(text, x, y, hAlign, vAlign);

		// change back to original text color; if indeed we had to change it
		if(!cmd.isEmpty())
			appendLine(currentGraphics.changeColors(currentGraphics.strokeColor, currentGraphics.isOpaqueStroke, 
			      oldTextRGB, oldTextOpaque));
	}

   /**
    * Same as {@link #renderText(String, double, double, TextAlign, TextAlign)}, except that string may be rotated
    * about the specified location and may have a different font size than what is set in the current graphics state.
    * The method ensures that the graphics state is restored upon return.
    * 
    * @param text The text to be painted.
    * @param x The x-coord of text starting position in user space.
    * @param y The y-coord of text starting position in user space.
    * @param ha Desired horizontal alignment.
    * @param va Desired vertical alignment.
    * @param rot Desired rotation about the text starting position, in degrees. Since user space is always configured 
    * such that the y-axis increases upward, a positive angle yields a counter-clockwise rotation.
    * @param fontSz Desired font size in milli-inches.
    * @throws UnsupportedOperationException if graphics state stack overflows or if there's no current page context.
    */
	public void renderText(String text, double x, double y, TextAlign ha, TextAlign va, double rot, double fontSz)
	{
	   // if no rotation and font size matches the current font size, no change are needed in graphic state.
	   if(rot == 0 && fontSz == currentGraphics.fontSize)
	   {
	      renderText(text, x, y, ha, va);
	      return;
	   }
	   
	   saveGraphicsState();
	   String cmd = currentGraphics.changeFont(currentGraphics.fontName, fontSz);
      if(!cmd.isEmpty()) appendLine(cmd);
	   translateAndRotate(x, y, rot);
	   renderText(text, 0, 0, ha, va);
	   restoreGraphicsState();
	}
	
	/**
	 * Helper method for {@link #renderText}. If the specified string is a <i>FypML</i> attributed text sequence, this
	 * method parses it and returns a sequence of string tokens in preparation for rendering via a custom prolog
	 * procedure.
	 * 
	 * <p>In <i>FypML</i>, <i>attributed text</i> is a character sequence in which font style, underline state, 
	 * super/subscript state, and text color can vary from one character to the next. Font family and size apply 
	 * uniformly across the character sequence. The "attributed text" is encoded succinctly as:
    * <pre>     S[|N1:codes1,N2:acodes2,...] </pre>
    * where S is a sequence of characters (with no leading or trailing whitespace), <i>0 <= N1 < N2 < ... < len(S)</i> 
    * are indices into the character sequence at which a change in one or more of the supported text attributes occurs, 
    * and <i>codesN</i> is a short string defining the attribute changes applied from index N to the end of the sequence
    * (or the next attribute change).</p>
    * <p>The notion of a default text color and font style are key to encoding the attributed text as succinctly as
    * possible. Attribute <b>changes</b> are encoded as follows:
    * <ul>
    * <li>Text color: If changing to a color other than the default text color, that color is specified as a 6-digit or
    * 8-digit (AARRGGBB) hexadecimal string. If changing from another color BACK to the default, the single '-' is
    * included. If the default color applies at the start of the string, no color code is needed at N=0. <b>NOTE:
    * Translucent text color is NOT supported by PSDoc.</b></li>
    * <li>Font style: If font style changes, a single character is included: 'w' for bold, 'i' for italic, 'I' for 
    * bolditalic, and 'p' for plain. Again, if the default font style applies at the start of the string, no font
    * style code is needed at N=0.</li>
    * <li>Underline state: "U" turns underlining on and "u" turns it off. If underlining is off at the start of the 
    * string, no underline code is needed at N=0.</li>
    * <li>Superscript/subscript state: "S" indicates superscript, "s" indicates subscript, and "n" normal text. Again, 
    * if neither superscript nor subscript apply at the start of the string, no code is needed at N=0.</li>
    * </ul>
    * Observe that, if the default font style and text color apply to the entire string S, and no underline, subscript
    * or superscript is used, then the attributed text is simply "S"!
    * </p>
    * 
    * <p>This method divides the attributed text into two or more like-styled "text runs", and each such run is
    * represented by an ordered sequence of 5 tokens:
    * <ol>
    * <li>The Postscript font literal, eg: "/Helvetica-BoldObliqueC".</li>
    * <li>Underline flag: "1" if it the text run is underlined, "0" if not.</li>
    * <li>Superscript/subscript state: "1" for superscript, "-1" for subscript, and "0" for normal text.</li>
    * <li>Text color: A decimal integer string indicating the packed RGB text color for the text run.</li>
    * <li>The sequence of Unicode characters comprising the text run. This still has to be converted to 
    * Postscript-compatible text ({@link #unicodeToPostscriptText}}</li>
    * </ol>
    * </p>
    * 
    * <p>This method was introduced to provide <b>PSDoc</b>-support for rendering attibuted text in <i>FypML</i>
    * <b>label</b>, <b>textbox</b>, and other elements.</p>
    * 
	 * @param s A character sequence.
	 * @return The token list. If it contains a single token, then <b>s</b> is not an attributed text sequence or is
	 * invalidly formatted, and the single token should be rendered as "plain" text. Otherwise, it will contain N*5
	 * tokens, where N is the number of like-styled text runs comprising the attributed text.
	 */
	private List<String> parseAttributedText(String s)
	{
	   List<String> tokens = new ArrayList<>();
	   int idx = s.lastIndexOf('|');
      String text = s;
      String[] attrRuns = new String[0];
      if((idx > 0) && (idx < s.length()-1))
      {
         text = s.substring(0, idx);
         attrRuns = s.substring(idx+1).split(",");
      }
      boolean ok = (attrRuns.length > 0);
      if(ok)
      {
         // from the current graphics state, get current font style and text color. UL and super/sub off initially.
         PSFont psFont = getBasePSFont(currentGraphics.fontName);
         FontStyle currFS = FontStyle.getFontStyle(
               isBold(psFont, currentGraphics.fontName), isItalic(psFont, currentGraphics.fontName));
         int currUL = 0;
         int currSS = 0;
         Color currTextC = new Color(currentGraphics.textFillColor);

         // parse attributed text into sequence of like-styled runs, with 5 tokens (font, UL, superscript state, text
         // color, and the actual text string) per run.
         int prevStartIdx = -1;
         for(String attrRun : attrRuns)
         {
            // number of ':' separators should be exactly 1
            String[] parts = attrRun.split(":");
            if(parts.length != 2)
            {
               ok = false;
               break;
            }

            // get starting text position for next text run; abort if not an integer, if position is beyond the end
            // of the character sequence, or if text runs are not in ascending order by starting position.
            int start = -1;
            try { start = Integer.parseInt(parts[0]); }
				catch(NumberFormatException ignored) {}
            if((start >= s.length()) || (start <= prevStartIdx))
            {
               ok = false;
               break;
            }

            // now that we have ending index for the previous text run, prepare its defining tokens. Handle case
            // when first run starts at beginning of char sequence.
            if(start > 0)
            {
               String segment = text.substring((prevStartIdx == -1) ? 0 : prevStartIdx, start);
               prevStartIdx = start;

               tokens.add("/" + getStandardFontFace(psFont, currFS.isBold(), currFS.isItalic()) + "C");
               tokens.add(Integer.toString(currUL));
               tokens.add(Integer.toString(currSS));
               tokens.add(Integer.toString(0x00FFFFFF & currTextC.getRGB()));
               tokens.add(segment);
            } else
               prevStartIdx = 0;

            // update the current values of the changeable attributes IAW the attribute codes for the next run...
            String run = parts[1];
            if(!run.isEmpty())
            {
               // text color, if specified, is ALWAYS first. Abort if invalid. Replace translucent color with opaque as
               // we don't support translucency.
               if(UnicodeSubset.HEXDIGITS.contains(run.charAt(0)))
               {
                  boolean hasAlpha = (run.length() >= 8) && UnicodeSubset.HEXDIGITS.containsAll(run.substring(0, 8));
                  currTextC = BkgFill.colorFromHexString(run.substring(hasAlpha ? 2 : 0, hasAlpha ? 8 : 6));
               } else if((run.charAt(0) == '-') && (start > 0))
                  currTextC = new Color(currentGraphics.textFillColor);   // restore default text color

               if(run.contains("w")) currFS = FontStyle.BOLD;
               else if(run.contains("i")) currFS = FontStyle.ITALIC;
               else if(run.contains("I")) currFS = FontStyle.BOLDITALIC;
               else if(run.contains("p")) currFS = FontStyle.PLAIN;

               if(run.contains("U"))
                  currUL = 1;
               else if(run.contains("u"))
                  currUL = 0;

               if(run.contains("S")) currSS = 1;
               else if(run.contains("s")) currSS = -1;
               else if(run.contains("n")) currSS = 0;
            }
         }
         
         // prepare the defining tokens for the last run
         if(ok)
         {
            tokens.add("/" + getStandardFontFace(psFont, currFS.isBold(), currFS.isItalic()) + "C");
            tokens.add(Integer.toString(currUL));
            tokens.add(Integer.toString(currSS));
            tokens.add(Integer.toString(0x00FFFFFF & currTextC.getRGB()));
            tokens.add(text.substring(prevStartIdx)); 
         }
      }

      if(!ok)
      {
         tokens.clear();
         tokens.add(text);
      }
      return(tokens);
	}

	/**
	 * Render a "paragraph" of text within a rectangular region located at the current origin and with the width and
	 * height specified. 
	 * 
	 * <p>Text lines are regularly spaced by the line height argument, L. The total text block height is A + D + L*(N-1),
	 * where N is the number of text lines, while A and D are the estimated font ascent and descent. The block is aligned
	 * with the top, bottom, or center of the rectangular bounding box, depending on the V alignment argument. Each line
	 * within the block is aligned along the left or right edge, or centered in the bounding box, depending on the H
	 * alignment argument.</p>
    * 
    * <p>The text content -- whether plain text or <i>FypML</i> "attributed text" -- is parsed into a list of attributed
    * text run subsequences with intervening space and linefeed ('\n') characters. A text run subsequence is an array of
    * 5N elements, where N is the number of different text runs comprising the subsequence. Each individual text run is
    * represented by a 5-tuple as <b>[font UL SS rgb (string)]</b>, where <b>font</b> is the composite font in which
    * the string should be rendered; <b>UL</b> is nonzero if string should be underlined and 0 otherwise; <b>SS</b> is
    * nonzero if string should be superscript (SS > 0) or subscript (SS < 0); and <b>rgb</b> is the text color as a
    * packed RGB hexadecimal integer (0x00RRGGBB). For example, the subsequence <b>[/Times-RomanC 1 0 0 (underlined) 
    * /Times-RomanC 0 0 0 (:)]</b> represents the string "underlined:" rendered in black in Times font, with the word
    * underlined but not the colon.</p>
    * 
    * <p>The subsequence tokens are loaded into a Postscript array and passed to a prolog procedure responsible for
    * measuring token widths, laying out the tokens on one or more text lines, and rendering the text lines from top to
    * bottom. The subsequence tokens come in one of three varieties:
    * <ul>
    * <li>Each linefeed character ('\n') is represented by a null token. Essentially, this is a signal to the prolog
    * procedure to introduce a new line in the laid out text block.</li>
    * <li>A singleton text run containing one or more consecutive spaces: <b>[font UL SS rgb ( )]</b>.</li>
    * <li>A 5N element array defining a subsequence that is not broken by spaces or linefeeds. The prolog procedure will
    * not break such a subsequences across text line boundaries -- unless its measured width exceeds the specified width
    * of the text block.</li>
    * </ul>
	 * 
	 * <p><b>NOTE</b>: This method may not accurately reproduce the on-screen layout of the text block, due to 
	 * differences between the screen font and the font used in the Postscript program generated by <b>PSDoc</b>.
	 * Since the screen and PS fonts aren't identical, font metrics like ascent and descent and string width calculations
	 * will be different, resulting in discrepancies between the on-screen and PS rendered output.</p>
	 * 
	 * <p><b>NOTE2</b>: The Postscript procedures that estimate the current font ascent and descent require that user
	 * space be unrotated WRT Postscript device space. Thus, this method requires the angle by which the text block is
	 * rotated WRT the device space. The Postscript procedures temporarily rotate user space so that its X/Y axes are
	 * parallel to the X/Y axes of device space before calculating font ascent and descent.</p>
	 * 
	 * <p><b>NOTE3</b>: If the text content is not <i>FypML</i> attributed text, it is still parsed in the manner 
	 * described. Each plain text token T is converted to an attributed text run [font 0 0 textRGB (T)], where the font
	 * and text color will be the same for all tokens. We do this instead of creating different prolog procedures for
	 * plain text vs attributed text.</p>
	 * 
	 * @param content The text content. If null or empty string, the method has no effect.
	 * @param w The width of the text bounding box, in user space units. If non-positive, the method has no effect.
	 * @param h The height of the text bounding box, in user space units. If non-positive, the method has no effect.
	 * @param lh The text line height, specified as a fraction of the current font size.
	 * @param rot Rotation of text block WRT Postscript device space, in degrees. See NOTE2 above.
	 * @param ha The horizontal alignment of text block WRT bounding box. If null, block is aligned along left edge.
	 * @param va The vertical alignment of text block WRT bounding box. If null, assume block is centered vertically.
	 */
	public void renderTextInBox(String content, double w, double h, double lh, double rot, TextAlign ha, 
	      TextAlign va) throws UnsupportedOperationException
	{
      // all rendering occurs in the context of a printed page
      if(!pageStarted) throw new UnsupportedOperationException(NOPAGE_EXCP);

      // do-nothing scenarios. NOTE that no marks are made if the current text/fill color is transparent!
      if(content == null || content.isEmpty() || w <= 0 || h <= 0 || !currentGraphics.isOpaqueTextFill) return;

      // whether or not text content is attributed text, we parse it into a list of attributed text run subsequences.
      // In the plain text case, every subsequence will consist of a single text run and the attributes are the same
      // for every such run...
      List<List<String>> subsequences = new ArrayList<>();
      

      List<String> runs = parseAttributedText(content);
      if(runs.isEmpty())
         return;
      else if(runs.size() == 1)
      {
         // CASE 1: Plain text. Parse into whitespace-separated tokens. Each linefeed is replaced by a null, each space
         // by an 5-tuple [fontC 0 0 rgb ( )], and each text token by a 5-tuple [fontC 0 0 rgb (string)]. 
         content = runs.get(0);
         
         // since this is plain text, every attributed text run will have the same font and text color IAW
         // the current graphics state. No underlining or super/subscript.
         List<String> runAttrs = new ArrayList<>();
         runAttrs.add(String.format("/%sC", currentGraphics.fontName));
         runAttrs.add("0");
         runAttrs.add("0");
         runAttrs.add(Integer.toString(0x00FFFFFF & currentGraphics.textFillColor));

         // parse text box content into whitespace-separated attributed text run subsequence tokens. Each linefeed is
         // replaced by a null.
         StringTokenizer tokenizer = new StringTokenizer(content, "\n ", true);
         while(tokenizer.hasMoreTokens())
         {
            String token = tokenizer.nextToken();
            if("\n".equals(token))
               subsequences.add(null);
            else if(" ".equals(token))
            {
               List<String> run = new ArrayList<>(runAttrs);
               run.add("( )");
               subsequences.add(run);
            }
            else
            {
               List<String> run = new ArrayList<>(runAttrs);
               run.add(String.format("(%s)", unicodeToPostscriptText(token)));
               subsequences.add(run);
            }
         }
      }
      else
      {
         // CASE 2: Attributed text content.
         // we need to break the complete attributed run sequence into subsequences of runs that may not be broken up.
         // Each linefeed character ('\n') or space (' ') found ends the current subsequence. A linefeed is replaced by
         // a null subsequence, and the space by a single-character subsequence.
         List<String> currSubsequence = new ArrayList<>();
         for(int i=0; i<runs.size(); i+=5)
         {
            String s = runs.get(i+4);  // the original Unicode text for the run
            
            StringTokenizer tokenizer = new StringTokenizer(s, "\n ", true);
            while(tokenizer.hasMoreTokens())
            {
               String token = tokenizer.nextToken();
               if("\n".equals(token) || " ".equals(token))
               {
                  if(!currSubsequence.isEmpty())
                  {
                     subsequences.add(currSubsequence);
                     currSubsequence = new ArrayList<>();
                  }
                  if("\n".equals(token))
                     subsequences.add(null);
                  else
                  {
                     // for a space, add a single-space subsequence
                     for(int k=0; k<4; k++) currSubsequence.add(runs.get(i+k));
                     currSubsequence.add("( )");
                     subsequences.add(currSubsequence);
                     currSubsequence = new ArrayList<>();
                  }
               }
               else if(!token.isEmpty())
               {
                  for(int k=0; k<4; k++) currSubsequence.add(runs.get(i+k));
                  currSubsequence.add(String.format("(%s)", unicodeToPostscriptText(token)));
               }
            }
         }
         if(!currSubsequence.isEmpty()) subsequences.add(currSubsequence);
      }
      
      // merge consecutive spaces when they're text attributes match (just to minimize # of tokens
      int iSub = 1;
      while(iSub < subsequences.size())
      {
         List<String> prev = subsequences.get(iSub-1);
         List<String> curr = subsequences.get(iSub);
         boolean merge = (prev != null) && (prev.size() == 5) && prev.get(4).endsWith(" )");
         merge = merge && (curr != null) && (curr.size() == 5) && curr.get(4).endsWith(" )");
         for(int i=0; merge && (i<4); i++) merge = prev.get(i).equals(curr.get(i));
         
         if(merge)
         {
            String blanks = prev.remove(4);
            prev.add(String.format("%s )", blanks.substring(0,blanks.length()-1)));
            subsequences.remove(iSub);
         }
         else ++iSub;
      }

      // mark start of code fragment with a comment for better readability
      addComment("renderTextInBox");

      // populate DATA0 array with the tokens. It will be processed by the prolog procedure that does the layout calcs 
      // and renders the text block. We save the VM state first so we can recover the memory allocated afterwards.
      saveVMState();
      loadArray(DATA0, subsequences);
      
      includeFunctionInProlog(SHOWTEXTRUNSINBOX);
      
      // % F T R HA VA L W H showTextRunsInBox
      String cmd = Utilities.toString(currentGraphics.fontSize, 7, 3) + " " + DATA0 + " " +
            Utilities.toString(rot, 7, 1) + " " +
            ((ha == TextAlign.LEADING) ? "1" : (ha == TextAlign.TRAILING ? "-1" : "0")) + " " +
            ((va == TextAlign.LEADING) ? "1" : (va == TextAlign.TRAILING ? "-1" : "0")) + " " +
            Utilities.toString(currentGraphics.fontSize * lh, 7, 3) + " " +
            Utilities.toString(w, 7, 3) + " " + Utilities.toString(h, 7, 3) + " " +
            SHOWTEXTRUNSINBOX;
      appendLine(cmd);

      // recover the allocated array and mark end of code fragment with a comment
      loadArray(DATA0, (List<List<String>>) null);
      restoreVMState();
      addComment("END renderTextInBox");
	}
	
	/**
	 * Draw and stroke a line segment between the specified points in user space, using the current color and line 
	 * width. Any current path defined prior to this call is ignored; afterwards, the current path is empty. If either 
	 * endpoint is not well-defined, the method has no effect.
	 * 
	 * @param from Starting point for the line segment.
	 * @param to Ending point for the line segment.
	 * @throws UnsupportedOperationException if there's no current page context.
	 */
	public void renderLine(Point2D from, Point2D to) throws UnsupportedOperationException
	{
		if( from==null || to==null || !(Utilities.isWellDefined(from) && Utilities.isWellDefined(to)) )
			return;

		// all rendering occurs in the context of a printed page
		if( !pageStarted ) throw new UnsupportedOperationException( NOPAGE_EXCP );

		// draw and stroke the line segment
		includeFunctionInProlog( DO_LINE );
		appendLine( Utilities.toString(to,7,3) + " " + Utilities.toString(from,7,3) + " " + DO_LINE );
	}

	/**
	 * Draw and stroke a polyline connecting the specified array of points in user space, using the current color and  
	 * line width. If a valid symbol type and size are specified, then the defined symbol is rendered individually at 
	 * each point in the polyline. The symbols are rendered on top of the polyline, so that the polyline does not appear 
	 * inside the adornments. Any current path defined prior to this call is lost; afterwards, the current path is empty. 
	 * 
	 * <p>"Lettered symbols": If a symbol text string is supplied, the given text is drawn horizontally and vertically 
	 * centered at each well-defined point, using the current font. The text will be drawn using the current stroke 
	 * color rather than the current text/fill color -- since it would be obscured by the filling of closed symbols!</p>
	 * 
	 * <p>The polyline is stroked IAW the stroke properties as defined in the current graphics state. If a 
	 * <code>PSTransformable</code> object is supplied for the symbol, the method will use it to define the graphics 
	 * state in which the symbols are rendered. Otherwise, both polyline and symbols are rendered IAW attributes from the 
	 * current graphics state.</p>
	 * 
	 * <p>One or more points in the provided array may be ill-defined. Such undefined points are treated as gaps in the 
	 * polyline. Thus, instead of a single unbroken polyline, the method will render two or more shorter polylines.  
	 * Symbols, of course, are only rendered at well-defined points.</p>
	 * 
	 * @param points The array of points in user space to be connected by the polyline.
	 * @param symbol The type of symbol (if any) rendered at each well-defined point. If <code>null</code> or not a 
	 * recognized <em>DataNav</em> symbol shape, no symbols are rendered.
	 * @param symSize Size of a square box bounding the symbols, in thousandth-inches. If negative or zero, no symbols 
    * are rendered.
	 * @param symbolInfo Defines an alternate graphics state in which symbols are rendered. If <code>null</code>, 
	 * symbols are rendered IAW the current graphics state.
	 * @param symbolText A text string to be drawn at each well-defined point, horizontally and vertically centered.
	 * Ignored if <code>null</code> or empty string.
	 * @param noLine If <code>true</code>, the polyline itself is not rendered, but any symbols will be.
	 * @throws UnsupportedOperationException if graphics state stack overflows or if there's no current page context.
	 */
	public void renderPolyline(Point2D[] points, Marker symbol, double symSize, PSTransformable symbolInfo, 
		String symbolText, boolean noLine) throws UnsupportedOperationException
	{
		// find the name of the prolog procedure that renders the specified adornment, if there is one
		String adornProc = getAdornmentPrologProc( symbol );
      
      // do we render adornments at all? This is a complicated check, because we have to check for transparent fill and
		// stroke colors.
      boolean doAdorn = (adornProc != null); 
      boolean opaqStrk = (symbolInfo == null) ? currentGraphics.isOpaqueStroke : !symbolInfo.isPSNoStroke();
      boolean opaqFill = (symbolInfo == null) ? currentGraphics.isOpaqueTextFill : !symbolInfo.isPSNoFill();
      boolean fillSym = symbol != null && symbol.isClosed() && opaqFill;
      boolean doLabel = (symbolText != null && (!symbolText.isEmpty()) && opaqStrk);
      if(doAdorn) doAdorn = ((symSize > 0) && (opaqStrk || fillSym)) || doLabel;
      
		// abort if there's nothing to render!
		if(points == null || points.length == 0 || ((points.length==1 || noLine) && !doAdorn)) 
			return;

		// all rendering occurs in the context of a printed page
		if( !pageStarted ) throw new UnsupportedOperationException( NOPAGE_EXCP );

		// make sure we have enough room on the graphics state stack.  We need one space for the "save" op issued prior 
		// to loading the points array, and another if the symbol is closed.  If symbols are rendered in a different 
		// graphics state, we don't need to "gsave-grestore" because after drawing the symbols we're done, and the 
		// original graphics state is restored when the original "save" op is undone!
		int nStackSaves = 1;
		if(doAdorn && symbol.isClosed()) ++nStackSaves;
		if( graphicsStack.size() + nStackSaves > MAX_GSTATE_DEPTH ) 
			throw new UnsupportedOperationException( GSOVFL_EXCP );

		// mark start of code fragment with a comment
		addComment( "renderPolyline" );

		// we need to load the polyline's defining points into the prolog's DATA0 array. To recover the VM consumed by 
		// this array, we encompass everything in a "save"-"restore" pair.  Any ill-defined points are set to "null" in 
		// the DATA0 array.
		saveVMState();
		loadArray( DATA0, points );

		// if polyline is rendered, invoke the appropriate prolog procedure:  "n polyLine". 
		if(!noLine)
		{
			includeFunctionInProlog(POLYLINE);  
			appendLine(points.length + " " + POLYLINE );
		}

		// if there's a symbol to render, do so at each well-defined point in the polyline by invoking the polyAdorn 
		// prolog procedure: "(string) vAdj fillCode n size /adornProcLit polyAdorn"
		if(doAdorn)
		{
			includeFunctionInProlog(adornProc);
			includeFunctionInProlog(POLYADORN);

			// if symbol-specific graphics state info is provided, modify the current graphics state accordingly.  
			if(symbolInfo != null) 
				updateCurrentGraphicsState(symbolInfo);
			
			// write out command to invoke the POLYADORN proc
			String cmd = "(";
			if(doLabel) cmd += unicodeToPostscriptText(symbolText);
			cmd += ") " + Utilities.toString(-currentGraphics.fontSize / 3.0, 7, 3) + " ";
			int fillCode = fillSym ? 1 : 0;
			cmd += fillCode + " " + points.length + " " +
				Utilities.toString(symSize,7,3) + " /" + adornProc + " " + POLYADORN;
			appendLine( cmd );
		}

		// clear the DATA0 array and "restore" to recover VM allocated to the array.  We restore our internal copy of 
		// the graphics state as well, which will be in synch both with the PS interpreter's own graphics state and the 
		// special prolog variables we use to maintain additional graphics state
		loadArray( DATA0, (Point2D[]) null );
		restoreVMState();


		// mark end of code fragment with a comment 
		addComment( "END renderPolyline" );
	}

	/**
	 * Paint a rectangle in user space. The rectangle is stroked IAW the current stroke color and line width and filled
	 * with the color specified (rather than the current text/fill color), or left unfilled.
	 * 
	 * @param botLeft Bottom-left corner of the rectangle in user space. If ill-defined, method has no effect.
	 * @param w Width of the rectangle. If non-positive, method has no effect.
	 * @param h Height of the rectangle. If non-positive, method has no effect.
	 * @param fillC The RGB color with which rectangle is filled (alpha component is ignored). <b>If null, the rectangle
    * is not filled.</b>
	 */
	public void renderRect(Point2D botLeft, double w, double h, Color fillC) throws UnsupportedOperationException
	{
	   if( w <= 0 || h <= 0 || !Utilities.isWellDefined(botLeft) ) return;

      // remember old text/fill color
      int oldFillRGB = currentGraphics.textFillColor;
      boolean oldFillOpaque = currentGraphics.isOpaqueTextFill;
      
      // change fill color temporarily 
      String cmd = currentGraphics.changeColors(currentGraphics.strokeColor, currentGraphics.isOpaqueStroke, 
            (fillC != null) ? (0x00FFFFFF & fillC.getRGB()) : 0, fillC != null);
      if(!cmd.isEmpty()) appendLine(cmd);

      // now we can stroke and fill rect using current graphics state properties
      renderRect(botLeft, w, h, currentGraphics.lineWidth, currentGraphics.lineWidth > 0, (fillC != null));

      // change back to original fill color. Note that the only thing changing could be the fill color's opaque flag,
      // which does not cause anything to be written to the PS document!
      cmd = currentGraphics.changeColors(currentGraphics.strokeColor, currentGraphics.isOpaqueStroke, 
               oldFillRGB, oldFillOpaque);
      if(!cmd.isEmpty()) appendLine(cmd);
	}
	
	/**
	 * Paint a rectangle in user space. This method provides a mechanism for overriding the current stroke color, 
	 * stroke width, and fill color.
	 * 
	 * @param r The rectangle in user space. If null or otherwise ill-defined, no action is taken.
	 * @param strkW The desired stroke width (in user units = 0.001in). If non-positive, the rectangle is not stroked.
	 * @param strkC The stroke color (alpha component ignored). If null, the rectangle is not stroked.
	 * @param fillC The fill color (alpha component ignored. If null, the rectangle is not filled.
	 */
	public void renderRect(Rectangle2D r, double strkW, Color strkC, Color fillC) throws UnsupportedOperationException
	{
	   if(r==null || (fillC==null && (strkW==0 || strkC==null))) return;
	   if(!Utilities.isWellDefined(new double[] {r.getX(), r.getY(), r.getWidth(), r.getHeight()})) return;
	   
	   Point2D botLeft = new Point2D.Double(r.getX(), r.getY());
	   double w = r.getWidth();
	   double h = r.getHeight();
	   if(w <= 0 || h <= 0) return;
	   
	   if(strkW <= 0) {strkW = 0; strkC = null; }
      
      // change colors temporarily
	   int oldFillRGB = currentGraphics.textFillColor;
	   boolean oldFillOpaque = currentGraphics.isOpaqueTextFill;
	   int oldStrkRGB = currentGraphics.strokeColor;
	   boolean oldStrkOpaque = currentGraphics.isOpaqueStroke;
      String cmd = currentGraphics.changeColors(
            (strkC != null) ? (0x00FFFFFF & strkC.getRGB()) : 0, strkC != null, 
            (fillC != null) ? (0x00FFFFFF & fillC.getRGB()) : 0, fillC != null);
      if(!cmd.isEmpty()) appendLine(cmd);
      
      // now we can stroke and/or fill rect using current graphics state properties
      renderRect(botLeft, w, h, strkW, (strkC != null), (fillC != null));

      // change back to original fill and stroke colors
      cmd = currentGraphics.changeColors(oldStrkRGB, oldStrkOpaque, oldFillRGB, oldFillOpaque);
      if(!cmd.isEmpty()) appendLine(cmd);
	}
	
   /**
    * Fill a rectangle in user space with the specified color. The rectangle is NOT stroked.
    * 
    * @param botLeft Bottom-left corner of the rectangle in user space. If ill-defined, method has no effect.
    * @param w Width of the rectangle. If non-positive, method has no effect.
    * @param h Height of the rectangle. If non-positive, method has no effect.
    * @param fillC The RGB color with which rectangle is filled (alpha component is ignored). <b>If null, no
    * action is taken.</b>
    */
   public void fillRect(Point2D botLeft, double w, double h, Color fillC) throws UnsupportedOperationException
   {
      if( w <= 0 || h <= 0 || fillC==null || !Utilities.isWellDefined(botLeft) ) return;

      // remember old text/fill color
      int oldFillRGB = currentGraphics.textFillColor;
      boolean oldFillOpaque = currentGraphics.isOpaqueTextFill;
      
      // change fill color temporarily 
      String cmd = currentGraphics.changeColors(currentGraphics.strokeColor, currentGraphics.isOpaqueStroke, 
            (0x00FFFFFF & fillC.getRGB()), true);
      if(!cmd.isEmpty()) appendLine(cmd);

      // now fill (but don't stroke) the rect using current graphics state properties
      renderRect(botLeft, w, h, currentGraphics.lineWidth, false, true);

      // change back to original fill color. Note that the only thing changing could be the fill color's opaque flag,
      // which does not cause anything to be written to the PS document!
      cmd = currentGraphics.changeColors(currentGraphics.strokeColor, currentGraphics.isOpaqueStroke, 
               oldFillRGB, oldFillOpaque);
      if(!cmd.isEmpty()) appendLine(cmd);
   }
   
	/**
	 * Draw a rectangle in user space. The rectangle is optionally stroked using the current stroke color and the 
	 * specified border width (rather than the current stroke width), and it is optionally filled using the current 
	 * text/fill color.  
	 * 
	 * <p>If either dimension of the rectangle is negative or zero, or if the bottom-left corner is ill-defined, then 
    * the method has no effect.  Any current path defined prior to this call is ignored; afterwards, the current path 
    * is empty -- UNLESS the rectangle is neither stroked nor filled.</p>
	 * 
	 * @param botLeft Bottom-left corner of the rectangle in user space.
	 * @param w Width of the rectangle.
	 * @param h Height of the rectangle.
	 * @param borderW Desired line width (in user units == 0.001in) for stroking the rectangle's outline.
	 * @param stroked <code>True</code> if rectangle's outline should be stroked in the current stroke color.
	 * @param filled <code>True</code> if rectangle should be filled with the current text/fill color.
	 * @throws UnsupportedOperationException if graphics state stack overflows or if there's no current page context.
	 */
	public void renderRect(Point2D botLeft, double w, double h, double borderW, boolean stroked, boolean filled) 
		throws UnsupportedOperationException
	{
		if(w <= 0 || h <= 0 || !Utilities.isWellDefined(botLeft)) return;

		// if rect is neither stroked nor filled, there's nothing to render
		if(stroked) stroked = currentGraphics.isOpaqueStroke && borderW > 0;
		if(filled) filled = currentGraphics.isOpaqueTextFill;
		if(!(stroked || filled)) return;
		
		// all rendering occurs in the context of a printed page
		if(!pageStarted) throw new UnsupportedOperationException( NOPAGE_EXCP );

		// we need one extra space on graphics state stack if the rectangle is filled
		if(filled && (graphicsStack.size() == MAX_GSTATE_DEPTH)) throw new UnsupportedOperationException(GSOVFL_EXCP);

		// set the current path to the specified rectangle in current user space coords
		includeFunctionInProlog(DO_RECT);
		appendLine(Utilities.toString(h,7,3) + " " + Utilities.toString(w,7,3) + " " + 
						Utilities.toString(botLeft,7,3) + " " + DO_RECT);

		// fill it if requested. We embed this in a gsave-grestore pair to preserve the path and restore the current color
		// to the stroke color in the graphics state.
		if(filled)
		{
			String cmd = "gsave " + USEFILLCOLOR + " fill grestore";
			if(!stroked) cmd += " newpath";
			appendLine(cmd);
		}

		// stroke it if requested 
		if(stroked)
		{
			String cmd = "";
			// if specified border width is not the same as the current line width, make it so 
			boolean changedLineW = false;
			if(borderW != currentGraphics.lineWidth)
			{
				cmd += Utilities.toString(borderW, 7, 3) + " setlinewidth ";
				changedLineW = true;
			}

			cmd += "stroke";

			// restore current line width if we temporarily changed it
			if(changedLineW) cmd += " " + Utilities.toString(currentGraphics.lineWidth, 7, 3) + " setlinewidth";

			appendLine(cmd);
		}
	}

   /**
    * Render a rectangle at the origin in user space. The rectangle's sides are parallel to the X and Y axes in user
    * space. It is optionally stroked using the current stroke color and the specified border width (rather than the 
    * current stroke width), and it is painted IAW with the background fill pattern specified.
    * 
    * <p>If either dimension of the rectangle is negative or zero, or if the rectangle is neither stroked nor filled,
    * then the method has no effect. Any current path defined prior to this call is ignored.</p>
    * 
    * @param w Width of the rectangle.
    * @param h Height of the rectangle.
    * @param borderW Desired line width (in user units == 0.001in) for stroking the rectangle's outline.
    * @param stroked True if rectangle's outline should be stroked in the current stroke color.
    * @param bf The background fill pattern. Could be a transparent color, in which case the rectangle is not filled. 
    * <i>Note that a solid but translucent background fill will be rendered as opaque, since Postscript does not support
    * translucent color.</i>
    * @throws UnsupportedOperationException if graphics state stack overflows or if there's no current page context.
    */
   public void renderRect(double w, double h, double borderW, boolean stroked, BkgFill bf) 
      throws UnsupportedOperationException
   {
      if(w <= 0 || h <= 0) return;

      // if rect is neither stroked nor filled, there's nothing to render
      if(stroked) stroked = currentGraphics.isOpaqueStroke && (borderW > 0);
      if(bf.isTransparent() && !stroked) return;
      
      // all rendering occurs in the context of a printed page
      if(!pageStarted) throw new UnsupportedOperationException(NOPAGE_EXCP);

      // we need one extra space on graphics state stack if the rectangle is filled
      if((!bf.isTransparent()) && (graphicsStack.size() == MAX_GSTATE_DEPTH)) 
         throw new UnsupportedOperationException(GSOVFL_EXCP);

      // set the current path to the specified rectangle in current user space coords
      includeFunctionInProlog(DO_RECT);
      appendLine( Utilities.toString(h,7,3) + " " + Utilities.toString(w,7,3) + " 0 0 " + DO_RECT);

      // fill the rectangle unless the fill is transparent. We embed this in a gsave-grestore pair to preserve the path 
      // and restore the current color to the stroke color in the graphics state.
      if(!bf.isTransparent())
      {
         String c1 = getRGBColorString(bf.getColor1().getRGB() & 0x00FFFFFF, true);
         String c2 = getRGBColorString(bf.getColor2().getRGB() & 0x00FFFFFF, true);
         StringBuilder sb = new StringBuilder();
         sb.append("gsave ");
         if(bf.getFillType() == BkgFill.Type.SOLID)
            sb.append(c1).append(" setrgbcolor");
         else
         {
            // gradient type (2=axial, 3=gradient) + gradient coords [x0 y0 x1 y1] or [x0 y0 0 x1 y1 r1].
            if(bf.getFillType() == BkgFill.Type.AXIAL)
            {
               Point2D[] pts = bf.getAxialEndpoints(w, h);
               sb.append("2 [").append(Utilities.toString(pts[0], 7, 3)).append(" ");
               sb.append(Utilities.toString(pts[1], 7, 3)).append("]");
            }
            else
            {
               double x = bf.getFocusX() * w / 100.0;
               double y = bf.getFocusY() * h / 100.0;
               sb.append("3 [");
               sb.append(Utilities.toString(x,7,3)).append(" ").append(Utilities.toString(y,7,3)).append(" 0 ");
               x = w / 2.0;
               y = h / 2.0;
               sb.append(Utilities.toString(x,7, 3)).append(" ").append(Utilities.toString(y,7,3)).append(" ");
               sb.append(Utilities.toString(Math.sqrt(x*x + y*y),7,3)).append("]");
            }
            
            // the two color stops
            sb.append(" [").append(c1).append("] [").append(c2).append("] ");
            sb.append(SETGRADFILL);
         }
         sb.append(" fill grestore");
         if(!stroked) sb.append(" newpath");
         appendLine(sb.toString());
      }

      // stroke it if requested 
      if(stroked)
      {
         String cmd = "";
         // if specified border width is not the same as the current line width, make it so 
         boolean changedLineW = false;
         if(borderW != currentGraphics.lineWidth)
         {
            cmd += Utilities.toString(borderW, 7, 3) + " setlinewidth ";
            changedLineW = true;
         }

         cmd += "stroke";

         // restore current line width if we temporarily changed it
         if(changedLineW)
         {
            cmd += " " + Utilities.toString(currentGraphics.lineWidth, 7, 3) + " setlinewidth";
         }

         appendLine(cmd);
      }
   }

	/**
	 * The same as {@link #renderPolygons(List, boolean)}, except that the polygons are filled with the specified color
	 * rather than the current text/fill color.
	 * @param vertices A list of points in the current user space that define one or more polygons to be rendered.
	 * @param fillC The RGB color with which polygons are to be filled (alpha component is ignored), instead of the 
	 * current text/fill color. <b>If null, the polygons are NOT filled at all.</b>
	 * @throws UnsupportedOperationException if graphics state stack overflows or if there's no current page context.
	 */
	public void renderPolygons(List<Point2D> vertices, Color fillC) throws UnsupportedOperationException
	{
	     // if no vertices are provided, or if there's just one vertex, there's nothing to render!
      if( vertices == null || vertices.size() < 2 ) 
         return;

      // remember old text/fill color
      int oldFillRGB = currentGraphics.textFillColor;
      boolean oldFillOpaque = currentGraphics.isOpaqueTextFill;
      
      // change fill color temporarily 
      int fillRGB = (fillC != null) ? (0x00FFFFFF & fillC.getRGB()) : 0;
      String cmd = currentGraphics.changeColors(currentGraphics.strokeColor, currentGraphics.isOpaqueStroke, 
            fillRGB, (fillC != null));
      if(!cmd.isEmpty()) appendLine(cmd);

      // now we can stroke and fill polygons using current graphics state properties
      renderPolygons(vertices, (fillC != null));

      // change back to original fill color. Note that the only thing changing could be the fill color's opaque flag,
      // which does not cause anything to be written to the PS document!
      cmd = currentGraphics.changeColors(currentGraphics.strokeColor, currentGraphics.isOpaqueStroke, 
               oldFillRGB, oldFillOpaque);
      if(!cmd.isEmpty()) appendLine(cmd);
	}
	
	/**
	 * Render a series of polygons defined by the specified list of vertices. The polygons are stroked with the current 
	 * stroke properties, and optionally filled using the current text/fill color. Any current path defined prior to 
	 * this call is lost; afterwards, the current path is empty. 
	 * 
	 * <p>The definition of each distinct polygon in the vertex array -- including the last polygon -- MUST end with a 
	 * null vertex. The polygons are drawn into the current path in the order they are defined in the vertex array. Then 
	 * the "poly-polygon" path is stroked and (optionally) filled. This may lead to unexpected effects if the polygons 
	 * overlap -- this method is really intended for non-overlapping polygons.</p>
	 * 
	 * @param vertices A list of points in the current user space that define one or more polygons to be rendered.
	 * @param filled If true, the polygons are filled with the current text/fill color before they are stroked.
	 * @throws UnsupportedOperationException if graphics state stack overflows or if there's no current page context.
	 */
	public void renderPolygons(List<Point2D> vertices, boolean filled) throws UnsupportedOperationException
	{
	   renderPolygons(vertices, filled, true);
	}

   /**
    * Render a series of polygons defined by the specified list of vertices. The polygons are optionally stroked with 
    * the current stroke properties, and optionally filled using the current text/fill color. Any current path defined 
    * prior to this call is lost; afterwards, the current path is empty. 
    * 
    * <p>The definition of each distinct polygon in the vertex array -- including the last polygon -- MUST end with a 
    * null vertex. The polygons are drawn into the current path in the order they are defined in the vertex array. Then 
    * the "poly-polygon" path is stroked and (optionally) filled. This may lead to unexpected effects if the polygons 
    * overlap -- this method is really intended for non-overlapping polygons.</p>
    * 
    * @param vertices A list of points in the current user space that define one or more polygons to be rendered.
    * @param filled If true, the polygons are filled with the current text/fill color before they are stroked.
    * @param stroked If true, the polygons are stroked IAW the current stroke properties.
    * @throws UnsupportedOperationException if graphics state stack overflows or if there's no current page context.
    */
   public void renderPolygons(List<Point2D> vertices, boolean filled, boolean stroked) throws UnsupportedOperationException
   {
      // if no vertices are provided, or if there's just one vertex, there's nothing to render!
      if( vertices == null || vertices.size() < 2 ) 
         return;

      // nothing to render if polygons are neither stroked nor filled
      if(filled) filled = currentGraphics.isOpaqueTextFill;
      if(stroked) stroked = currentGraphics.lineWidth > 0 && currentGraphics.isOpaqueStroke;
      if(!(stroked || filled)) return;
      
      // all rendering occurs in the context of a printed page
      if( !pageStarted ) throw new UnsupportedOperationException( NOPAGE_EXCP );

      // temporarily disable stroking if requested (fill-only use case)
      boolean strokeDisabled = false;
      if(currentGraphics.lineWidth > 0 && currentGraphics.isOpaqueStroke && !stroked)
      {
         strokeDisabled = true;
         appendLine("0 " + ENABLESTROKE);
      }
      
      // make sure we have enough room on the graphics state stack.  we need one space for the "save" op issued prior 
      // to loading the vertex array, and another if we're filling the polygons
      int nStackSaves = filled ? 2 : 1;
      if( graphicsStack.size() + nStackSaves > MAX_GSTATE_DEPTH )
         throw new UnsupportedOperationException( GSOVFL_EXCP );

      // mark start of code fragment with a comment
      addComment("renderPolygons");

      // we need to load the polygon vertices into the prolog's DATA0 array. to recover the VM consumed by this array, 
      // we encompass everything in a "save"-"restore" pair.  any ill-defined points are set to "null" in the DATA0 array.
      Point2D[] vertexArray = new Point2D[vertices.size()];
      for(int i=0; i<vertexArray.length; i++) vertexArray[i] = vertices.get(i);
      
      saveVMState();
      loadArray(DATA0, vertexArray);

      // invoke the prolog procedure which renders the polyline:  "fillCode n polygons", where fillCode = 0 if the 
      // polygons are not to be filled, or 1 to fill them w/ the current text/fill color
      includeFunctionInProlog(POLYGONS);
      String cmd = filled ? "1 " : "0 ";
      cmd += vertexArray.length + " " + POLYGONS;
      appendLine( cmd );

      // clear the DATA0 array and "restore" to recover VM allocated to the array
      loadArray(DATA0, (Point2D[])null);
      restoreVMState();

      // reenable stroke if it was temporarily disabled
      if(strokeDisabled)
         appendLine("1 " + ENABLESTROKE);
      
      // mark end of code fragment with a comment 
      addComment("END renderPolygons");
   }

   /**
    * Render a series of concentric pie wedges or radial sections defined by the specified list of vertices. The wedges 
    * are stroked with the current stroke properties, and optionally filled with the current text/fill color. Any 
    * current path defined prior to this call is lost; afterwards, the current path is empty. 
    * 
    * <p>The vertex list must contain an even number of entries. Each pair of vertices defines a single arc; the arc 
    * endpoints are specified in (x,y) "painting" coordinates. The method will convert each vertex to polar coordinates 
    * (r, theta). It is ASSUMED that each pair of arc endpoints will have the same radial component r -- the radial 
    * component of the first endpoint is used for the second endpoint as well. If either endpoint is ill-defined, that 
    * pair of vertices is simply ignored.</p>
    * 
    * <p>If the supplied baseline radius is zero, a pie wedge is drawn for each well-defined arc: the arc itself is 
    * drawn, and two lines connect the arc's endpoints to the origin. If the baseline radius is nonzero, a radial 
    * section (think: a piece of donut) is drawn: the defined arc, another arc at the baseline radius spanning the same 
    * range in theta, and two radial line segments connecting the endpoints of the two arcs.</p>
    * 
    * @param origin The common center for the circular wedges.
    * @param vertices A list of (x,y) points in the current user space that are the vertices of arcs bounding the 
    * wedges or radial sections to be rendered -- as described above. <strong>The list will be altered by this 
    * method! Its contents should be considered indeterminate upon return.</strong>
    * @param baseRad Radius (distance from specified origin) of a "baseline" arc that is paired with each arc defined 
    * in the vertex list. If zero, then a pie wedge is rendered for each well-defined arc, else a radial section -- as 
    * described above.
    * @param filled If true, the wedges or radial sections are filled with the current text/fill color before they are 
    * stroked.
    * @see PSDoc#POLYWEDGES
    * @throws UnsupportedOperationException if graphics state stack overflows or if there's no current page context.
    */
	public void renderConcentricWedges(Point2D origin, List<Point2D> vertices, double baseRad, boolean filled)
	      throws UnsupportedOperationException
	{
      // if origin is ill-defined, or if no vertices are provided, or if there's just one, there's nothing to render!
      if(!Utilities.isWellDefined(origin) || vertices == null || vertices.size() < 2)
         return;

      // nothing to render if wedges/sections are neither stroked nor filled
      if(filled) filled = currentGraphics.isOpaqueTextFill;
      boolean stroked = currentGraphics.lineWidth > 0 && currentGraphics.isOpaqueStroke;
      if(!(stroked || filled)) return;
      
      // if vertex list has odd number of points, go ahead and remove the last one!
      if(vertices.size() % 2 != 0) vertices.remove(vertices.size()-1);
      
      // all rendering occurs in the context of a printed page
      if( !pageStarted ) throw new UnsupportedOperationException( NOPAGE_EXCP );

      // make sure we have enough room on the graphics state stack.  we need one space for the "save" op issued prior 
      // to loading the vertex array, and another if we're filling the polygons
      int nStackSaves = filled ? 2 : 1;
      if( graphicsStack.size() + nStackSaves > MAX_GSTATE_DEPTH )
         throw new UnsupportedOperationException( GSOVFL_EXCP );

      // process vertex list
      Point2D[] arc = new Point2D[2];
      int i = 0;
      while(i < vertices.size())
      {
         arc[0] = vertices.get(i);
         arc[1] = vertices.get(i+1);
         if(!Utilities.isWellDefined(arc))
         {
            vertices.remove(i);
            vertices.remove(i);
            continue;
         }
         
         if(baseRad == 0) 
         {
            double r = origin.distance(arc[0]);
            double theta = Math.toDegrees(Math.atan2(arc[0].getY()-origin.getY(), arc[0].getX()-origin.getX()));
            arc[0].setLocation(r, theta);
            theta = Math.toDegrees(Math.atan2(arc[1].getY()-origin.getY(), arc[1].getX()-origin.getX()));
            arc[1].setLocation(r, theta);
            vertices.add(i+2, null);      // POLYWEDGES requires a null between each set of vertices
            i += 3;
         }
         else
         {
            // Radial section case. Have to add vertices for arc at baseline radius. First pair must define 
            // inner arc drawn in one direction, and second must define outer arc drawn in opposite direction!
            double r = origin.distance(arc[0]);
            double theta0 = Math.toDegrees(Math.atan2(arc[0].getY()-origin.getY(), arc[0].getX()-origin.getX()));
            double theta1 = Math.toDegrees(Math.atan2(arc[1].getY()-origin.getY(), arc[1].getX()-origin.getX()));
            // if(theta0 >= theta1) { double d = theta0; theta0 = theta1; theta1 = d; }  THIS CAUSED PROBLEMS.
            if(r <= baseRad)
            {
               arc[0].setLocation(r, theta0);
               arc[1].setLocation(r, theta1);
               vertices.add(i+2, new Point2D.Double(baseRad, theta1));
               vertices.add(i+3, new Point2D.Double(baseRad, theta0));
            }
            else
            {
               vertices.add(i, new Point2D.Double(baseRad, theta0));
               vertices.add(i+1, new Point2D.Double(baseRad, theta1));
               arc[0].setLocation(r, theta1);
               arc[1].setLocation(r, theta0);
            }
            vertices.add(i+4,null);  // POLYWEDGES requires null between each set of vertices
            i += 5;
         }
      }
      
      Point2D[] vertexArray = new Point2D[vertices.size()];
      for(i=0; i<vertexArray.length; i++) vertexArray[i] = vertices.get(i);
      
      // mark start of code fragment with a comment
      addComment( "renderConcentricWedges" );

      // we need to load the wedge vertices into the prolog's DATA0 array. to recover the VM consumed by this array, we 
      // encompass everything in a "save"-"restore" pair.  any ill-defined points are set to "null" in the DATA0 array.
      saveVMState();
      loadArray( DATA0, vertexArray );

      // invoke the prolog procedure which renders the wedges:  "fillCode n x0 y0 polyWedges", where fillCode=0 if the 
      // wedges are not filled, or 1 if they are filled with the current text/fill color
      includeFunctionInProlog(POLYWEDGES);
      String cmd = filled ? "1 " : "0 ";
      cmd += vertexArray.length + " " + Utilities.toString(origin, 7, 3) + " " + POLYWEDGES;
      appendLine( cmd );

      // clear the DATA0 array and "restore" to recover VM allocated to the array
      loadArray( DATA0, (Point2D[])null );
      restoreVMState();

      // mark end of code fragment with a comment 
      addComment( "END renderConcentricWedges" );
	}
	
   /**
    * The same as {@link #renderConcentricWedges(Point2D, List, double, boolean)}, except that the wedges are filled 
    * with the specified color rather than the current text/fill color.
    * 
    * @param origin The common center for the circular wedges.
    * @param vertices A list of (x,y) points in the current user space that are the vertices of arcs bounding the 
    * wedges or radial sections to be rendered -- as described above. <b>The list will be altered by this 
    * method! Its contents should be considered indeterminate upon return.</b>
    * @param baseRad Radius (distance from specified origin) of a "baseline" arc that is paired with each arc defined 
    * in the vertex list. If zero, then a pie wedge is rendered for each well-defined arc, else a radial section.
    * @param fillC The RGB color with which wedges are to be filled (alpha component is ignored), instead of the current
    * text/fill color. <b>If null, the wedges are NOT filled at all.</b>
    * @throws UnsupportedOperationException if graphics state stack overflows or if there's no current page context.
    */
   public void renderConcentricWedges(Point2D origin, List<Point2D> vertices, double baseRad, Color fillC)
         throws UnsupportedOperationException
   {
      // if no vertices are provided, or if there's just one vertex, there's nothing to render!
      if(vertices == null || vertices.size() < 2) 
         return;

       // remember old text/fill color
       int oldFillRGB = currentGraphics.textFillColor;
       boolean oldFillOpaque = currentGraphics.isOpaqueTextFill;
       
       // change fill color temporarily 
       int fillRGB = (fillC != null) ? (0x00FFFFFF & fillC.getRGB()) : 0;
       String cmd = currentGraphics.changeColors(currentGraphics.strokeColor, currentGraphics.isOpaqueStroke, 
             fillRGB, (fillC != null));
       if(!cmd.isEmpty()) appendLine(cmd);
   
       // now we can stroke and fill polygons using current graphics state properties
       renderConcentricWedges(origin, vertices, baseRad, (fillC != null));
   
       // change back to original fill color. Note that the only thing changing could be the fill color's opaque flag,
       // which does not cause anything to be written to the PS document!
       cmd = currentGraphics.changeColors(currentGraphics.strokeColor, currentGraphics.isOpaqueStroke, 
                oldFillRGB, oldFillOpaque);
       if(!cmd.isEmpty()) appendLine(cmd);
   }
   
   /**
    * A variation of {@link #renderConcentricWedges(Point2D, List, double, Color)} in which the radial section vertices
    * are already in polar coordinate form.
    * 
    * <p>Each pair of polar coordinates in the vertex array -- {(theta0, r0), (theta1, r1)}, r0 < r1 -- define the
    * arc(s) bounding one pie wedge or radial section. All wedges and sections share the origin specified. The angular
    * coordinates are in degrees CCS and each radial coordinate is specified as a distance from the origin, in 
    * "painting coordinate units" (milli-inches). If r0 == 0, a pie wedge is rendered; else a radial section.</p>
    * @param origin The common center for the circular wedges
    * @param vertices A list of vertices defining the wedges or radial sections to be rendered, in the form described.
    * <b>The list will be altered by this method! Its contents should be considered indeterminate upon return.</b>
    * @param fillC The RGB color with which wedges are to be filled (alpha component is ignored), instead of the current
    * text/fill color. <b>If null, the wedges are NOT filled at all.</b>
    * @throws UnsupportedOperationException if graphics state stack overflows or if there's no current page context.
    */
   public void renderConcentricWedges(Point2D origin, List<Point2D> vertices, Color fillC)
   {
		// if origin is ill-defined, or if no vertices are provided, or if there's just one, there's nothing to render!
      if(!Utilities.isWellDefined(origin) || vertices == null || vertices.size() < 2)
         return;

      // nothing to render if wedges/sections are neither stroked nor filled
      boolean stroked = currentGraphics.lineWidth > 0 && currentGraphics.isOpaqueStroke;
      if((fillC == null) && !stroked) return;

		// remember old text/fill color
		int oldFillRGB = currentGraphics.textFillColor;
		boolean oldFillOpaque = currentGraphics.isOpaqueTextFill;
       
		// change fill color temporarily
		int fillRGB = (fillC != null) ? (0x00FFFFFF & fillC.getRGB()) : 0;
		String cmd = currentGraphics.changeColors(currentGraphics.strokeColor, currentGraphics.isOpaqueStroke,
				fillRGB, (fillC != null));
		if(!cmd.isEmpty()) appendLine(cmd);
   
		// if vertex list has odd number of points, go ahead and remove the last one!
		if(vertices.size() % 2 != 0) vertices.remove(vertices.size()-1);
       
		// all rendering occurs in the context of a printed page
		if( !pageStarted ) throw new UnsupportedOperationException( NOPAGE_EXCP );

		// make sure we have enough room on the graphics state stack.  we need one space for the "save" op issued prior
		// to loading the vertex array, and another if we're filling the radial sections/wedges
		int nStackSaves = (fillC != null) ? 2 : 1;
		if( graphicsStack.size() + nStackSaves > MAX_GSTATE_DEPTH )
			throw new UnsupportedOperationException( GSOVFL_EXCP );

		// process vertex list
		Point2D[] arc = new Point2D[2];
		int i = 0;
		while(i < vertices.size())
		{
			arc[0] = vertices.get(i);
			arc[1] = vertices.get(i+1);
			if(!Utilities.isWellDefined(arc))
			{
				vertices.remove(i);
				vertices.remove(i);
				continue;
			}

			double theta0 = arc[0].getX();
			double r0 = arc[0].getY();
			double theta1 = arc[1].getX();
			double r1 = arc[1].getY();

			if(r0 < 0.001)
			{
				// pie wedge: 2 vertices (r, theta0) and (r, theta1), followed by a null separator
				arc[0].setLocation(r1, theta0);
				arc[1].setLocation(r1, theta1);
				vertices.add(i+2, null);
				i += 3;
			}
			else
			{
				// radial section: 4 vertices followed by a null separator. First pair must define inner arc of section
				// drawn in one direction (r0, theta0) -> (r0, theta1), while second pair defines the outer arc drawn in
				// the opposite direction.
				arc[0].setLocation(r0, theta0);
				arc[1].setLocation(r0, theta1);
				vertices.add(i+2, new Point2D.Double(r1, theta1));
				vertices.add(i+3, new Point2D.Double(r1, theta0));
				vertices.add(i+4, null);
				i += 5;
			}
		}

		Point2D[] vertexArray = new Point2D[vertices.size()];
		for(i=0; i<vertexArray.length; i++) vertexArray[i] = vertices.get(i);

		// mark start of code fragment with a comment
		addComment( "renderConcentricWedges" );

		// we need to load the wedge vertices into the prolog's DATA0 array. to recover the VM consumed by this array, we
		// encompass everything in a "save"-"restore" pair. Any ill-defined points are set to "null" in the DATA0 array.
		saveVMState();
		loadArray( DATA0, vertexArray );

		// invoke the prolog procedure which renders the wedges:  "fillCode n x0 y0 polyWedges", where fillCode=0 if the
		// wedges are not filled, or 1 if they are filled with the current text/fill color
		includeFunctionInProlog(POLYWEDGES);
		cmd = (fillC != null) ? "1 " : "0 ";
		cmd += vertexArray.length + " " + Utilities.toString(origin, 7, 3) + " " + POLYWEDGES;
		appendLine( cmd );

		// clear the DATA0 array and "restore" to recover VM allocated to the array
		loadArray( DATA0, (Point2D[])null );
		restoreVMState();

		// mark end of code fragment with a comment
		addComment( "END renderConcentricWedges" );


		// change back to original fill color. Note that the only thing changing could be the fill color's opaque flag,
		// which does not cause anything to be written to the PS document!
		cmd = currentGraphics.changeColors(currentGraphics.strokeColor, currentGraphics.isOpaqueStroke,
				 oldFillRGB, oldFillOpaque);
		if(!cmd.isEmpty()) appendLine(cmd);
   }
   
   /**
    * Render a mesh of 4-sided polygons.
    * 
    * <p>There is no restriction placed on the total number N of mesh polygons, but Postscript interpreters may not be
    * able to handle very large meshes. When N exceeds 2500, the mesh is rendered in chunks of 2500 each.</p>
    * 
    * <p>The polygons are filled and stroked individually, in the order listed in the function arguments. All are 
    * stroked IAW the current stroking style in the graphics state. However, the method offers four different ways to
    * fill the polygons, depending on the nature of the <i>fillInfo</i> argument:
    * <ul>
    * <li>If <i>fillInfo==null</i>, then the mesh is not filled ("wire frame").</li>
    * <li>If <i>fillInfo</i> is an empty list, then all mesh polygons are filled with the fill color in the current
    * graphics state.</li>
    * <li>If <i>fillInfo</i> contains exactly N numbers, then the K-th number in the list is the fill color for the
    * K-th mesh polygon, encoded as a packed RGB integer 0x00RRGGBB.</li>
    * <li>Otherwise, the size of <i>fillInfo</i> must lie in 2N..4N and the color lookup table argument must be 
    * non-null. In this scenario, each polygon is filled either with a solid color or a linear gradient fill IAW the 
    * specified lookup table (color map + direction). Which it is depends on the sequence of numbers in <i>fillInfo</i>.
    * A solid fill color is represented by a sequence of 2 numbers in <i>fillInfo</i>: [NaN, 0x00RRGGBB]; the "NaN" 
    * distinguishes between a solid and a gradient fill, and the second entry is the packed RGB integer representation 
    * of the fill color. An axial gradient fill is represented by a sequence of 4 well-defined numbers in 
    * <i>fillInfo</i>, [x0 y0 x1 y1], specifying the user space coordinates for the endpoints of the axial gradient. 
    * These endpoints, along with the specified color lookup table, define the axial gradient shading pattern with which
    * the corresponding mesh polygon is filled.</li>
    * </ul>
    * </p>
    * 
    * @param n The number N of 4-sided mesh polygons to render. 
    * @param vertices Mesh polygon vertices. All vertices must be well-defined. If null or if list size is not 4*N, no 
    * action is taken.
    * @param fillInfo The per-polygon fill information, as detailed above.
    * @param colorLUT The color lookup table to be used to define a linear axial gradient fill, as described above. If 
    * <i>fillInfo</i> has between 2N and 4N entries, then this argument cannot be null!
    */
   public void renderMesh(int n, List<Point2D> vertices, List<Number> fillInfo, ColorLUT colorLUT)
   {
      // check arguments
      if(n <= 0 || vertices==null || vertices.size() != 4*n) return;
      int fillCode = 0;
      if(fillInfo != null)
      {
         int sz = fillInfo.size();
         fillCode = (sz==0) ? 1 : ((sz==n) ? 2 : 3);
         
         // for the most complex case, we have to scan fillInfo to ensure the correct number of entries are supplied
         if(fillCode == 3)
         {
            if(colorLUT==null || sz < 2*n || sz > 4*n) return;
            int nConsumed = 0;
            for(int i=0; i<n && nConsumed < fillInfo.size(); i++)
            {
               if(Utilities.isWellDefined(fillInfo.get(nConsumed).doubleValue())) nConsumed += 4;
               else nConsumed +=2;
            }
            if(nConsumed != fillInfo.size()) return;
         }
      }
      
      // all rendering occurs in the context of a printed page
      if(!pageStarted) throw new UnsupportedOperationException(NOPAGE_EXCP);

      // make sure we have enough room on the graphics state stack. We need one to restore VM state to recover memory
      // used by the data arrays. We need another if we fill the polygons.
      int nStackSaves = fillCode > 0 ? 2 : 1;
      if(graphicsStack.size() + nStackSaves > MAX_GSTATE_DEPTH)
         throw new UnsupportedOperationException(GSOVFL_EXCP);

      // mark start of code fragment with a comment
      addComment("renderMesh");
      includeFunctionInProlog(MESH);  // CMAPFILL is automatically included here

      // prepare the 'keyFrames' and 'keyColors' arguments for the CMAPFILL procedure. If we're not doing axial
      // gradient fills, then these are both null.
      String cmdPrefix = "null null " + fillCode + " ";
      if(fillCode == 3)
      {
         float[] keyFrames = colorLUT.getKeyFrames();
         Color[] keyColors = colorLUT.getKeyColors();
         StringBuilder sb = new StringBuilder();
         sb.append("[");
         for(int i=0; i<keyFrames.length; i++)
         {
            sb.append(Utilities.toString(keyFrames[i], 4, 4));
            if(i < keyFrames.length-1) sb.append(" ");
         }
         sb.append("] [");
         float[] rgb = new float[] {0f, 0f, 0f};
         for(int i=0; i<keyColors.length; i++)
         {
            keyColors[i].getRGBColorComponents(rgb);
            sb.append("[").append(Utilities.toString(rgb, 4, 4)).append("]");
            if(i < keyColors.length-1) sb.append(" ");
         }
         sb.append("] ").append(fillCode).append(" ");
         cmdPrefix = sb.toString();
      }
      
      // we render the mesh in chunks of 2500 polygons each.
      // NOTE: Have to be careful loading fill info for fill codes 2 & 3. PackedRGB colors must be treated as integers,
      // not doubles!
      Point2D[] pts = null;
      int[] rgbAr = null;
      List<String> fill3 = new ArrayList<>(100);
      int nDone = 0;
      int nFillDone = 0;  // needed when fillInfo is variable in size (fillCode == 3)
      while(nDone < n)
      {
         int nChunk = n - nDone;
         if(nChunk > 2500) nChunk = 2500;
         
         // prepare the data arrays for this chunk
         if(pts == null || pts.length != nChunk*4) pts = new Point2D[nChunk*4];
         for(int i=0; i<nChunk*4; i++) pts[i] = vertices.get(nDone*4 + i);
         
         if(fillCode == 2)
         {
            if(rgbAr == null || rgbAr.length != nChunk) rgbAr = new int[nChunk];
            for(int i=0; i<nChunk; i++) rgbAr[i] = fillInfo.get(nDone+i).intValue();
         }
         else if(fillCode == 3)
         {
            fill3.clear();
            int nConsumed = 0;
            for(int i=0; i<nChunk; i++)
            {
               if(Utilities.isWellDefined(fillInfo.get(nFillDone+nConsumed).doubleValue())) 
               {
                  for(int j=0; j<4; j++) 
                  {
                     double d = fillInfo.get(nFillDone+nConsumed+j).doubleValue();
                     fill3.add(Utilities.isWellDefined(d) ? Utilities.toString(d, 7, 3) : "null");
                  }
                  nConsumed += 4;
               }
               else
               {
                  fill3.add("null");
                  fill3.add(Integer.toString(fillInfo.get(nFillDone+nConsumed+1).intValue()));
                  nConsumed += 2;
               }
            }
            nFillDone += nConsumed;
         }

         // save VM state to recover memory for data arrays, then load the arrays
         saveVMState();
         loadArray(DATA0, pts);
         if(rgbAr != null) loadArray(DATA1, rgbAr);
         else if(!fill3.isEmpty()) loadArray(DATA1, fill3, false);

         // invoke the procedure that renders the mesh
         String cmd = cmdPrefix + " " + nChunk + " " + MESH;
         appendLine(cmd);
         
         // clear the data arrays and "restore" to recover VM allocated to them
         loadArray(DATA0, (Point2D[])null);
         if(fillCode > 1) loadArray(DATA1, (double[])null );
         restoreVMState();

         // prepare for the next chunk
         nDone += nChunk;
      }
      
      // mark end of code fragment with a comment 
      addComment("END renderMesh");
   }
   
	/**
	 * Draw and stroke a series of concentric circles with the specified radii, using the current stroke properties. The 
	 * circles are NOT filled. Any current path defined prior to this call is lost; after, the current path is empty. 
	 * 
	 * <p>The method is intended for rendering a relatively small number of concentric circles. It allocates an array 
	 * object to hold the radii, but it does not attempt to recover the memory consumed by the array after the operation 
	 * is complete.</p>
	 * 
	 * @param origin The common origin in user space for all the circles to be rendered.
	 * @param radii The set of radii at which concentric circles are to be rendered. Any radius less than or equal to 
	 * zero is ignored.
	 * @throws 	UnsupportedOperationException if there's no current page context.
	 */
	public void renderConcentricCircles(Point2D origin, double[] radii)
	{
		if(!Utilities.isWellDefined(origin) || radii == null || radii.length == 0)
			return;

		// nothing to render if circles are not stroked
		if(!(currentGraphics.isOpaqueStroke && currentGraphics.lineWidth > 0)) return;
		
		// all rendering occurs in the context of a printed page
		if( !pageStarted ) throw new UnsupportedOperationException( NOPAGE_EXCP );

		// process 50 circles at a time using the polyCircles prolog procedure
		includeFunctionInProlog(POLYCIRCLES);
		StringBuilder cmdBuf = new StringBuilder(200);
		int i=0;
		while( i < radii.length )
		{
			// prepare the polyCircles command to render the next 50 circles.  first we allocate an array on the operand 
			// stack to hold the next 50 valid radii.  we skip over radii that are <= 0. 
			cmdBuf.delete(0, cmdBuf.length());
			cmdBuf.append( "[ " );
			int j = 0;
			while( j<50 && i < radii.length ) 
			{
				if( radii[i] > 0 )
				{
					cmdBuf.append(Utilities.toString(radii[i], 7, 3)).append(" ");
					++j;
				}
				++i;
			}

			// if at least one circle was included, then finish the command and append it to the document
			if( j > 0 )
			{
				cmdBuf.append("] ").append(Utilities.toString(origin, 7, 3)).append(" ").append(POLYCIRCLES);
				appendLine( cmdBuf.toString() );
			}
		}
	}

   /**
    * Draw and stroke a series of concentric circular arcs with the specified endpoints and radii, using the current 
    * stroke properties. No arc is filled, even if it is a complete circle. Any current path defined prior to this call 
    * is lost; afterwards, the current path is empty. 
    * 
    * @param   origin The common origin in user space for all the arcs to be rendered.
    * @param   start The common starting angle for all arcs to be rendered, in degrees
    * @param   end The common ending angle for all arcs to be rendered. The ending angle should be larger than the 
    * starting angle. If the two angles are identical, nothing is rendered!
    * @param   radii The set of radii at which concentric arcs are to be rendered. Any radius less than or equal to 
    *    zero is ignored.
    * @throws  UnsupportedOperationException if graphics state stack overflows or if there's no current page context
    */
   public void renderConcentricArcs(Point2D origin, double start, double end, double[] radii)
      throws UnsupportedOperationException
   {
      // if null or empty arguments, there's nothing to render!
      if(!Utilities.isWellDefined(origin) || start == end || radii == null || radii.length == 0)
         return;

      // nothing to render if arcs are not stroked
      if(!(currentGraphics.isOpaqueStroke && currentGraphics.lineWidth > 0)) return;
      
      // all rendering occurs in the context of a printed page
      if( !pageStarted ) throw new UnsupportedOperationException( NOPAGE_EXCP );

      // make sure we have enough room on the graphics state stack. We need one space for the "save" op issued prior 
      // to loading the array objects that contain the arc endpoints and radii.
      if( graphicsStack.size() == MAX_GSTATE_DEPTH ) throw new UnsupportedOperationException( GSOVFL_EXCP );

      // mark start of code fragment with a comment for better readability
      addComment( "renderConcentricArcs" );

      // we need to load both the arc endpoints (which are two angles) and the arc radii into the prolog's DATA0 and 
      // DATA1 arrays. to recover the VM consumed by these arrays, we encompass everything in a "save"-"restore" pair. 
      // any ill-defined points are set to "null" in the points array.
      saveVMState();
      loadArray( DATA0, radii );

      // invoke the prolog procedure which renders the concentric arcs:  "n x0 y0 a0 a1 polyArcs"
      includeFunctionInProlog(POLYARCS);
      appendLine(radii.length + " " + Utilities.toString(origin,7,3) + " " +
         Utilities.toString(start,7,3) + " " + Utilities.toString(end,7,3)+ " " + POLYARCS );

      // clear the prolog variables that reference the allocated arrays and "restore" to recover the VM allocated
      loadArray( DATA0, (double[])null );
      restoreVMState();

      // mark end of code fragment with a comment 
      addComment( "END renderConcentricArcs" );
   }

	/**
	 * Draw a line with endpoint and midpoint adornments. The line segment and adornments are stroked IAW the current 
    * stroke properties, and any closed adornments are filled with the current text/fill color. However, while the line 
    * segment will be stroked IAW the current dash pattern in the graphics state, the adornments are always rendered 
    * with a solid stroke.
	 * 
	 * <p>If a <code>Marker.LINEUP</code> or <code>Marker.LINEDOWN</code> adornment appears at either endpoint, its 
	 * location and length may be adjusted IAW the current stroke width to ensure a nice join. Since the same stroking
	 * properties (except for dash pattern) are used for both line segment and adornments, we only have a problem when
	 * the endcap style is "butt-ended".... NOTE that we CANNOT, in general, include these adornments as part of the path 
	 * node that draws the line segment itself, because the adornments are always rendered with a solid stroke -- but not 
	 * so for the line segment.</p>
	 * 
	 * <p>The method will have no effect on the state of this <code>PSDoc</code> if the line's endpoints are ill-defined, 
    * or if the line has a length of zero.</p>
	 * 
	 * @param p0 Starting point (x0,y0) for the line; coords in thousandth-inches.
	 * @param p1 Ending point for (x1,y1) for the line; coords in thousandth-inches.
	 * @param noLine If true, the line itself is not rendered, but any adornments will be.
	 * @param p0Cap The cap adornment for the starting point.
	 * @param p0CapSize Size of a square box bounding the start cap adornment, in thousandth-inches.
	 * @param p1Cap The cap adornment for the ending point.
	 * @param p1CapSize Size of a square box bounding the end cap adornment, in thousandth-inches.
	 * @param midCap The cap adornment for the midpoint.
	 * @param midCapSize Size of a square box bounding the midpoint adornment in thousandth-inches.
	 * @throws UnsupportedOperationException if graphics state stack overflows or if there's no current page context.
	 */
	public void renderAdornedLine(Point2D p0, Point2D p1, boolean noLine, 
		Marker p0Cap, double p0CapSize, Marker p1Cap, double p1CapSize, Marker midCap, double midCapSize) 
		throws UnsupportedOperationException
	{
		// line is ill-defined, do nothing
		if(p1 == null || !Utilities.isWellDefined(p0) || !Utilities.isWellDefined(p0))
			return;

		// length of line is the distance between the endpoints; zero-length lines are not rendered
		double lineLength = p0.distance(p1);
		if( lineLength == 0.0 ) 
			return;

		// if line is hidden and there are no adornments, then there's nothing to do!
		boolean doP0Cap = p0CapSize > 0 && p0Cap != null;
		boolean doP1Cap = p1CapSize > 0 && p1Cap != null;
		boolean doMidCap = midCapSize > 0 && midCap != null;
		if( noLine && !(doP0Cap || doP1Cap || doMidCap) )
			return;

		// if adorned line is neither stroked nor filled, there's nothing to do!
		boolean fillP0 = doP0Cap && p0Cap.isClosed();
		boolean fillP1 = doP1Cap && p1Cap.isClosed();
		boolean fillMid = doMidCap && midCap.isClosed();
		boolean filled = currentGraphics.isOpaqueTextFill && (fillP0 || fillP1 || fillMid);
		boolean stroked = currentGraphics.isOpaqueStroke && currentGraphics.lineWidth > 0;
		if(!(stroked || filled)) return;
		
		// if the pen stroke is currently empty in the current graphics state, we don't draw the line
		if(!stroked) noLine = true;
		
		// all rendering occurs in the context of a printed page
		if( !pageStarted ) throw new UnsupportedOperationException( NOPAGE_EXCP );

		// calculate orientation of line
		double theta = Math.toDegrees( Math.atan2( p1.getY()-p0.getY(), p1.getX()-p0.getX() ) );

		// if there isn't enough room left on the graphics state stack, throw an exception.  We need to save graphics 
		// state b/c we change it here and need to restore it afterwards.  Two additional slots are needed if the left 
		// adornment is closed and not vertically symmetric (1 to rotate it, 1 to fill it); otherwise, one additional 
		// slot is needed if we fill any adornment.
		int nStackSaves = 1;
		if(fillP0 && !p0Cap.isVSymmetric()) nStackSaves += 2;
		else if(fillP0 || fillP1 || fillMid) nStackSaves += 1;
		if(graphicsStack.size() + nStackSaves > MAX_GSTATE_DEPTH)
			throw new UnsupportedOperationException( GSOVFL_EXCP );

		// mark start of code fragment with a comment
		addComment( "renderAdornedLine" );

		// we transform user space so that origin is at left endpoint and pos x-axis lies along line extending toward 
		// the right endpoint.  If this is already the case, then there's no need!
		boolean doTransform = p0.getX() != 0 || p0.getY() != 0 || theta != 0;

		// save graphics state b/c we make temporary changes to it here.  Transform user space only if necessary.
		String cmd = "gsave";
		if( doTransform )
			cmd += " " + Utilities.toString(p0,7,3) + " translate " + Utilities.toString(theta,7,3) + " rotate";
		appendLine( cmd );

		// render the line segment itself, unless it is hidden.  Given the user space transformation above, we simply 
		// stroke a line from (0,0) to (L,0), where L is the line's length
		if( !noLine )
		{
			cmd = "newpath 0 0 moveto " + Utilities.toString(lineLength,7,3) + " 0 lineto stroke";
			appendLine( cmd );
		}

		// if there are any adornments to render, do so. 
		if( doP0Cap || doMidCap || doP1Cap )
		{
			cmd = "";
			// if the current line stroke is not solid, make it so:  adornments are always stroked with a solid line
			if( currentGraphics.dashPattern != null && currentGraphics.dashPattern.length > 0 )
				cmd += "[] 0 setdash";

			double strokeW = currentGraphics.lineWidth;

			// left endpoint adornment
			if( doP0Cap )
			{
				// if it's a lineup or linedown AND the stroke endcap style is butt-ended, we adjust its horizontal pos by 
			   // +0.5 the current stroke width to get a nice join with the line segment. Also, if adornment is vertically 
			   // nonsymmetric, we must rotate it 180deg. All adornments are designed for the right endpoint of a line seg.
				double x = 0;
				if(currentGraphics.linecap == 0 && (p0Cap == Marker.LINEUP || p0Cap == Marker.LINEDOWN))
					x += 0.5*strokeW;
				cmd += doAdornment(p0Cap, p0CapSize, x, 0, !p0Cap.isVSymmetric() ? 180 : 0, null);
			}

			// midpoint adornment
			if( doMidCap )
				cmd += doAdornment(midCap, midCapSize, lineLength/2, 0, 0, null);

			// right endpoint adornment
			if( doP1Cap )
			{
				// if it's a lineup or linedown AND the stroke endcap style is butt-ended, we adjust its horizontal pos by 
			   // -0.5 the current stroke width to get a nice join with the line segment.
				double x = lineLength;
				if(currentGraphics.linecap == 0 && (p1Cap == Marker.LINEUP || p1Cap == Marker.LINEDOWN))
					x -= 0.5*strokeW;
				cmd += doAdornment(p1Cap, p1CapSize, x, 0, 0, null);
			}

			appendLine(cmd);
		}

		// restore graphics state
		appendLine( "grestore" );
		
		// mark end of code fragment with a comment
		addComment( "END renderAdornedLine" );

	}

	/**
	 * This method renders a one- or two-sided error bar for a <em>DataNav</em> data set. <em>DataNav</em> supports 
    * three error bar styles:
	 * <ul>
	 * 	<li><code>DataNavSchemaConstants.LBL_TWOSIDED_EBAR</code>, "+/-1": Error bar extends from -1STD to 
	 * 	+1STD about the nominal datum in either X or Y.</li>
	 * 	<li><code>DataNavSchemaConstants.LBL_PLUSONE_EBAR</code>, "+1"}: Error bar extends from the nominal 
	 * 	datum to +1STD in either X or Y.</li>
	 * 	<li><code>DataNavSchemaConstants.LBL_MINUSONE_EBAR</code>, "-1"}: Error bar extends from the nominal 
	 * 	datum to -1STD in either X or Y.</li>
	 * </ul>
	 * 
	 * <p>In Cartesian graphs, error bars are horizontal lines in X or vertical lines in Y, adorned with an endcap if 
	 * one is specified. In polar plots, the error bar in "theta" (x-coord) is a circular arc while the error bar in 
	 * "r" (y-coord) is a radial line. The <code>DataNavSchemaConstants.ADORN_LINEUP</code> and 
	 * <code>DataNavSchemaConstants.ADORN_LINEDOWN</code> endcaps are incorporated into the path that renders the error 
    * bar line/arc to get a nice join.</p>
	 * 
	 * <p>The method assumes that the desired stroke-dash pattern for the error bar lines/arcs has already been set by 
	 * the caller. However, by design, endcaps are always stroked with a solid line. When the current graphics state 
	 * includes a non-solid line style, the method temporarily sets the line style to solid, renders the endcaps, then 
	 * restores the original line style.</p>
	 * 
	 * <p>The method is rather specialized to the task of rendering an error bar. It exists primarily to hide the caller 
	 * from the low-level Postscript-language commands that actually do the work.</p>
	 *  
	 * @param isX If true, then other parameters define an error bar in the x-coordinate (or theta in the case of a polar
	 * plot). Else, an error bar in the y-coordinate (radial coord in polar case) is defined.
	 * @param eStyle If zero, then error bar is two-sided. If positive, it is +1-sided. Otherwise, it is -1-sided. 
	 * In the latter two cases, no end cap is rendered at the specified starting pt for the error bar, which should 
	 * be coincident with the datum's location.
	 * @param pStart The start point for the error bar line/arc. If bar is 2-sided or -1-sided, this should correspond 
    * to the point representing -1STD from the datum. For +1-sided bars, it must be coincident with the data point. 
    * Assumed to be in current user space coordinates.
	 * @param pEnd The end point for the error bar line/arc. If bar is 2-sided or +1-sided, this corresponds to the 
	 * point representing +1STD from the datum. If -1-sided, then it is must be coincident with the data point. Assumed 
    * to be in current user space coordinates.
	 * @param pOrigin If well-defined, it is assumed that the error bar is rendered in a polar context, and this point 
	 * is the polar origin in current user space coordinates. Set to <code>null</code> if error bar is rendered in a 
	 * Cartesian graph.
	 * @param endCap Type of adornment serving as an endcap for the error bar.
	 * @param endCapSz Endcap size in thousandth-inches.
	 */
	public void renderErrorBar(
		boolean isX, int eStyle, Point2D pStart, Point2D pEnd, Point2D pOrigin, Marker endCap, double endCapSz)
	{
		boolean isPolar = Utilities.isWellDefined(pOrigin);
		boolean isTheta = isX && isPolar;
		boolean isTwoSided = (eStyle == 0);
		boolean isPlusOne = (eStyle>0);
		boolean isMinusOne = (eStyle<0);

		// the lineup and linedown endcaps are not rendered via adornment proc; they are incorporated into the path that 
		// renders the error bar line/arc
		boolean isLineup = endCapSz > 0 && endCap == Marker.LINEUP;
		boolean isLinedn = endCapSz > 0 && endCap == Marker.LINEDOWN;
		boolean hasEndCaps = endCap != null && endCapSz > 0 && !(isLineup || isLinedn);

		double r = isPolar ? pOrigin.distance(pStart) : 0;
		Point2D p = new Point2D.Double();

		double r2 = r + (isLineup ? 0.5 : -0.5)*endCapSz;

		// if relevant, start path with a lineup or linedown endcap at first endpt
		String cmd = "newpath ";
		if( (isTwoSided||isMinusOne) && (isLineup || isLinedn) )
		{
			if( isX )
			{
				if( !isPolar )
					p.setLocation( pStart.getX(), pStart.getY() + (isLineup ? -0.5 : 0.5)*endCapSz );
				else
				{
					double theta = Math.atan2(pStart.getY()-pOrigin.getY(), pStart.getX()-pOrigin.getX());
					p.setLocation( pOrigin.getX() + r2*Math.cos(theta), pOrigin.getY() + r2*Math.sin(theta));
				}
			}
			else
			{
				if( !isPolar )
					p.setLocation( pStart.getX() + (isLineup ? -0.5 : 0.5)*endCapSz, pStart.getY() );
				else
				{
					double theta = Math.atan2(pStart.getY()-pOrigin.getY(), pStart.getX()-pOrigin.getX());
					theta += (isLineup ? 0.5 : -0.5)*Math.PI;
					double d = endCapSz/2;
					p.setLocation( pStart.getX() + d*Math.cos(theta), pStart.getY() + d*Math.sin(theta));
				}
			}
			cmd += Utilities.toString(p,7,3) + " moveto " + Utilities.toString(pStart,7,3)+ " lineto";
		}
		else
			cmd += Utilities.toString(pStart,7,3) + " moveto";

		// draw the error bar line segment or arc
		if( isTheta )
		{
			// the arc endpts are such that the arc should always be drawn CCW from start to end pt. Hence we use "arc".
			double angle0 = Math.atan2(pStart.getY()-pOrigin.getY(), pStart.getX()-pOrigin.getX());
			double angle1 = Math.atan2(pEnd.getY()-pOrigin.getY(), pEnd.getX()-pOrigin.getX());

			cmd += " " + Utilities.toString(pOrigin,7,3) + " " + Utilities.toString(r,7,3) + " " +
				Utilities.toString(Math.toDegrees(angle0),7,3) + " " + Utilities.toString(Math.toDegrees(angle1),7,3) + 
				" arc";
		}
		else
			cmd += " " + Utilities.toString(pEnd,7,3) + " lineto";

		// if relevant, finish path with a lineup or linedown endcap at the second endpt
		if( (isTwoSided||isPlusOne) && (isLineup || isLinedn) )
		{
			if( isX )
			{
				if( !isPolar )
					p.setLocation( pEnd.getX(), pEnd.getY() + (isLineup ? -0.5 : 0.5)*endCapSz );
				else
				{
					double theta = Math.atan2(pEnd.getY()-pOrigin.getY(), pEnd.getX()-pOrigin.getX());
					p.setLocation( pOrigin.getX() + r2*Math.cos(theta), pOrigin.getY() + r2*Math.sin(theta));
				}
			}
			else
			{
				if( !isPolar )
					p.setLocation( pEnd.getX() + (isLineup ? -0.5 : 0.5)*endCapSz, pEnd.getY() );
				else
				{
					double theta = Math.atan2(pEnd.getY()-pOrigin.getY(), pEnd.getX()-pOrigin.getX());
					theta += (isLineup ? 0.5 : -0.5)*Math.PI;
					double d = endCapSz/2;
					p.setLocation( pEnd.getX() + d*Math.cos(theta), pEnd.getY() + d*Math.sin(theta));
				}
			}
			cmd += " " + Utilities.toString(p,7,3) + " lineto";
		}

		// stroke the error bar line/arc
		cmd += " strokeEx";

		// render the error bar endcaps, if there are any.
		if(hasEndCaps)
		{
			// if current line style is NOT a solid line, we must temporarily change it to solid because endcaps should 
			// always be stroked with a solid line.  THIS IS A HACK!
			boolean restoreDash = false;
			int[] saveDashPattern = currentGraphics.dashPattern;
			int saveDashOffset = currentGraphics.dashOffset;
			int saveLC = currentGraphics.linecap;
			int saveLJ = currentGraphics.linejoin;
			double saveLW = currentGraphics.lineWidth;
			if( currentGraphics.dashPattern == null || currentGraphics.dashPattern.length > 0 )
			{
				String cmdDash = currentGraphics.changeStrokeProperties(saveLW, saveLC, saveLJ, SOLIDLINE, 0);
				if(!cmdDash.isEmpty())
				{
					restoreDash = true;
					cmd += " " + cmdDash;
				}
			}

			// do endcap at end of error bar line/arc, if relevant
			if( isTwoSided || isPlusOne )
			{
				double x = pEnd.getX();
				double y = pEnd.getY();
				double rot = (isTheta) ?
					Math.atan2(pEnd.getY()-pOrigin.getY(), pEnd.getX()-pOrigin.getX()) + Math.PI/2 :
					Math.atan2(pEnd.getY()-pStart.getY(), pEnd.getX()-pStart.getX());
				cmd += doAdornment(endCap, endCapSz, x, y, Math.toDegrees(rot), null);
			}

			// do endcap at start of error bar, if relevant
			if( isTwoSided || isMinusOne )
			{
				double x = pStart.getX();
				double y = pStart.getY();
				double rot = (isTheta) ?
					Math.atan2(pStart.getY()-pOrigin.getY(), pStart.getX()-pOrigin.getX()) + Math.PI/2 :
					Math.atan2(pEnd.getY()-pStart.getY(), pEnd.getX()-pStart.getX());
				if(!endCap.isVSymmetric()) rot += Math.PI;
				cmd += doAdornment(endCap, endCapSz, x, y, Math.toDegrees(rot), null);
			}

			// if we had to temporarily change the line style in the current graphics state, restore it now
			if( restoreDash )
			{
				cmd += " " + currentGraphics.changeStrokeProperties(saveLW, saveLC, saveLJ, saveDashPattern, saveDashOffset);
			}
		}

		appendLine( cmd );
	}

	/**
	 * Draw the specified adornment at each of the specified locations in user space. The adornments are stroked using 
	 * the current stroke properties, and any closed adornments are filled with the current text/fill color. Each 
	 * adornment is rendered, filled and stroked in the order that their center points appear in the locations array.
	 * 
	 * <p>If one or more adornments in the set need to be rotated, specify an array of rotation angles having the same 
	 * length as the locations array.</p>
	 * 
    * <p>If the adornment is zero size and has no text label, nothing is rendered. A zero-size adornment with a 
    * non-empty text label is still rendered -- only the text label is rendered, centered horizontally and vertically 
    * about the center point.</p>
    * 
	 * @param pts The (x,y) coordinates of all locations where an adornment should be drawn. If any given point is not
	 * well-defined, it is ignored.
	 * @param rot The rotations to be applied to each adornment about its center point. If <code>null</code>, none of 
	 * the adornments are rotated. Otherwise, the array provided MUST have the same length as the points array.
	 * @param cap The adornment type.
	 * @param capSize Size of square box enclosing adornment, in thousandth-inches.
	 * @param text A text string to be painted at each location, H- and V-centered. Text is painted using the current 
	 * stroke color rather than the current text/fill color.
	 * @throws UnsupportedOperationException if graphics state stack overflows or if there's no current page context.
	 */
	public void renderMultipleAdornments(Point2D[] pts, double[] rot, Marker cap, double capSize, String text)
	{
		// abort if no points specified or size of non-null rotation array is not the same as points array size
		if( pts == null || pts.length == 0 || (rot != null && (pts.length != rot.length)) )
			return;

      // if the current stroke color is transparent, then we don't draw the text string!
      if(!currentGraphics.isOpaqueStroke) text = null;
      
      // the adornments are not drawn if they're neither stroked nor filled
      boolean stroked = currentGraphics.isOpaqueStroke && currentGraphics.lineWidth > 0;
      boolean filled = (cap != null) && cap.isClosed() && currentGraphics.isOpaqueTextFill;
      
      // abort if nothing to render!
      if((!(stroked || filled)) && (text == null || text.isEmpty())) return;
      
		// find the name of the prolog procedure that renders the specified adornment; if there is none, or if the 
		// cap size is non-positive and there's no text, then draw nothing. 
		String adornProc = getAdornmentPrologProc( cap );
		if( adornProc == null  || (capSize <= 0 && (text == null || text.isEmpty())) ) return;

		// all rendering occurs in the context of a printed page
		if( !pageStarted ) throw new UnsupportedOperationException( NOPAGE_EXCP );

		// make sure we have enough room on the graphics state stack.  we need one space for the "save" op, and another 
		// for the polyAdorn proc IF the adornment is filled.  if the polyRotAdornProc is used instead, we require 2 
		// stack spots if adornment is not filled, 3 otherwise.
		int nStackSaves = filled ? 2 : 1;
		if( rot != null ) ++nStackSaves;
		if( graphicsStack.size() + nStackSaves > MAX_GSTATE_DEPTH ) 
			throw new UnsupportedOperationException( GSOVFL_EXCP );

		// mark start of code fragment with a comment
		addComment( "renderMultipleAdornments" );

		// we need to load the adornment locations into the prolog's DATA0 array, and the rotation angles (if specified), 
		// into the DATA1 array.  to recover the VM consumed by the arrays, we encompass everything in a "save"-"restore" 
		// pair.  any ill-defined points are set to "null" in the DATA0 array
		saveVMState();
		loadArray( DATA0, pts );
		if( rot != null ) loadArray( DATA1, rot );

		// invoke the prolog procedure which constructs a path rendering the specified adornment at the (well-defined) 
		// points that were just loaded, possibly with rotations:
		// 	"() 0 fillCode n size /adornProcLit [polyAdorn OR polyRotAdorn]"
		includeFunctionInProlog( adornProc );
		includeFunctionInProlog( (rot!=null) ? POLYROTADORN : POLYADORN );
		int fillCode = filled ? 1 : 0;
		String cmd = "() 0 ";
		if( text != null && !text.isEmpty())
			cmd = "(" + unicodeToPostscriptText(text) + ") " + Utilities.toString(-currentGraphics.fontSize/3.0,7,3) + " ";
		cmd += fillCode + " " + pts.length + " " + Utilities.toString(capSize,7,3) +
					" /" + adornProc + " " + ((rot!=null) ? POLYROTADORN : POLYADORN);
		appendLine( cmd );

		// clear the DATA0, DATA1 arrays and "restore" to recover VM allocated to the arrays
		loadArray( DATA0, (Point2D[])null );
		if( rot != null ) loadArray( DATA1, (double[])null );
		restoreVMState();

		// mark end of code fragment with a comment 
		addComment( "END renderMultipleAdornments" );
	}

	/**
	 * Draw the specified adornment at each of the specified locations in user space, optionally accompanied by a line
	 * segment -- aka "stem" -- drawn from the adornment center point to a second point. The adornment size and/or
	 * background fill may vary from location to location.
	 * 
	 * <p>This method was introduced to handle rendering of the 3D scatter/stem plot in <i>FypML</i>. To avoid occlusion
	 * issues, it is important that each stem is drawn with its corresponding adornment. It is assumed that the location
	 * list is ordered such that the "backmost" adornment-stem pair is drawn first, while the "frontmost" pair is drawn
	 * last.</p>
	 * 
	 * <p>Stems may be stroked differently from the adornments. The graphic styling of stems is specified by the second
	 * argument. The current graphics state determines how the adornments are stroked.</p>
	 * 
	 * @param n The number N of adornment-stem pairs to be drawn. If non-positive, no action is taken.
    * @param m The adornment type. If null, {@link Marker#CIRCLE} is assumed.
    * @param stem Object defining how the stem line segments should be stroked. If null, then stems are NOT drawn.
	 * @param coords List of locations P{(x,y)}, in user space in milli-inches. Cannot be null. If stems are NOT drawn,
	 * must contain exactly N points. Otherwise, it must have 2N points, where P(2*i) is the center point for the i-th
	 * adornment and P(2*i+1) is the other end point for its associated stem. If any given point is not well-defined, 
	 * then the corresponding adornment and/or stem is not drawn.
	 * @param sizes List of adornment sizes, in milli-inches. If sizes varies with location, must be length N; else, it
	 * must be length 1, and all adornments are drawn at the size specified in that single element. Note that a zero-size
	 * adornment is not drawn.
	 * @param backFills List of adornment background fills. Supports solid-color, axial gradient, or radial gradient
	 * fills. All colors opaque, since Postscript does not support translucent color. If fill varies with location, must 
	 * be length N; else, it must be length 1, and all adornments will have the background fill specified in that single 
	 * element. Of course, if the adornment is unclosed, this argument is ignored.
    * @throws UnsupportedOperationException if graphics state stack overflows or if there's no current page context.
    * @throws IllegalArgumentException if any argument violates the restrictions described above.
	 */
	public void renderStemmedAdornments(
	      int n, Marker m, PSTransformable stem, List<Point2D> coords, List<Double> sizes, List<BkgFill> backFills)
	{
	   if(n <= 0) return;
	   if(m==null) m = Marker.CIRCLE;
	   boolean doStems = (stem != null);
	   
	   // check for bad arguments.
	   boolean ok = (coords != null) && (sizes != null) && (backFills != null);
	   if(ok) ok = (coords.size() == (doStems ? 2*n : n));
	   if(ok) ok = (sizes.size() == n) || (sizes.size() == 1);
	   if(ok) ok = (backFills.size() == n) || (backFills.size() == 1);
	   if(!ok) throw new IllegalArgumentException();
	   
	   // prepare data array {(x,y)} containing locations at which adornments (and stems if applicable) are drawn
      Point2D[] pts = new Point2D[coords.size()];
      for(int i=0; i<coords.size(); i++) pts[i] = coords.get(i);
      
      // prepare data array containing the adornment sizes, unless all are drawn at the same size
      boolean sizeVaries = (n > 1) && (sizes.size() == n);
      double[] adornSizes = null;
      double fixedAdornSz = 0;
      if(sizeVaries)
      {
         adornSizes = new double[n];
         for(int i=0; i<n; i++)
         {
            Double dSz = sizes.get(i);
            double d = (dSz != null) ? dSz : 0;
            adornSizes[i] = (d < 0 || !Utilities.isWellDefined(d)) ? 0 : d;
         }
      }
      else
      {
         Double dSz = sizes.get(0);
         fixedAdornSz = (dSz != null) ? dSz : 0;
         if(fixedAdornSz < 0 || !Utilities.isWellDefined(fixedAdornSz)) fixedAdornSz = 0;
      }
      
      // if the background fill does not vary, prepare the fill specification applied to all adornments. When the fill
      // varies, the fill spec argument to POLYSTEMADORN is an empty array. Of course, if the adornment is not closed,
      // it is not filled, and the fill spec is irrelevant.
      // IMPORTANT: If the adornment size varies but the specified background fill stays the same, the PS fill spec
      // will vary if it is a gradient -- because that fill spec includes coordinate information that varies with the
      // adornment size!
      StringBuilder sb = new StringBuilder();
      boolean fillVaries = m.isClosed() && (n > 1) && (backFills.size() == n);
      if((!fillVaries) && sizeVaries)
      {
         BkgFill bf = backFills.get(0);
         fillVaries = (bf != null) && (bf.getFillType() != BkgFill.Type.SOLID);
      }
      if(fillVaries)
         sb.append("[]");
      else
      {
         BkgFill bf = backFills.get(0);
         if(bf == null || bf.isTransparent() || !m.isClosed()) sb.append("[0]");   // no fill
         else
         {
            String c1 = getRGBColorString(bf.getColor1().getRGB() & 0x00FFFFFF, true);
            String c2 = getRGBColorString(bf.getColor2().getRGB() & 0x00FFFFFF, true);
            if(bf.getFillType() == BkgFill.Type.SOLID)
               sb.append("[1 ").append(c1).append("]");
            else
            {
               // gradient type (2=axial, 3=gradient) + gradient coords [x0 y0 x1 y1] or [x0 y0 0 x1 y1 r1].
               sb.append("[");
               if(bf.getFillType() == BkgFill.Type.AXIAL)
               {
                  Point2D[] endPts = bf.getAxialEndpoints(fixedAdornSz, fixedAdornSz);
                  sb.append("2 [").append(Utilities.toString(endPts[0],7,3)).append(" ");
                  sb.append(Utilities.toString(endPts[1],7,3)).append("]");
               }
               else
               {
                  double fx = bf.getFocusX() * fixedAdornSz / 100.0;
                  double fy = bf.getFocusY() * fixedAdornSz / 100.0;
                  sb.append("3 [");
                  sb.append(Utilities.toString(fx,7,3)).append(" ").append(Utilities.toString(fy,7,3)).append(" 0 ");
                  fx = fixedAdornSz / 2.0;
                  fy = fixedAdornSz / 2.0;
                  sb.append(Utilities.toString(fx,7,3)).append(" ").append(Utilities.toString(fy,7,3)).append(" ");
                  sb.append(Utilities.toString(Math.sqrt(fx*fx + fy*fy),7,3)).append("]");
               }
               
               // the two color stops
               sb.append(" [").append(c1).append("] [").append(c2).append("]]");
            }
         }
      }
      String bfSpec = sb.toString();
      
      // prepare the two PS commands that convert graphics state from it current state to what it should be to draw 
      // stems. These are stored in a string array -- [(...) (...)] -- for passing to POLYSTEMADORN. Both strings will
      // be empty if stems are not drawn, or if there is no change in stroke state.
      String stemProc = "[() ()]";
      if(doStems)
      {
         String[] cmds = currentGraphics.prepareStrokeChangeAndRestoreCommands(stem);
         stemProc = "[(" + cmds[0] + ") (" + cmds[1] + ")]";
      }
      
      // find the name of the prolog procedure that renders the specified adornment; if there is none, draw nothing. 
      String adornProc = getAdornmentPrologProc(m);

      // all rendering occurs in the context of a printed page
      if(!pageStarted) throw new UnsupportedOperationException(NOPAGE_EXCP);

      // make sure we have enough room on the graphics state stack. We'll typically need 3 places on the stack.
      if(graphicsStack.size() + 3 > MAX_GSTATE_DEPTH) throw new UnsupportedOperationException(GSOVFL_EXCP);

      // mark start of code fragment with a comment
      addComment("renderStemmedAdornments");

      // we need to load the adornment locations into the prolog's DATA0 array, and possibly size data and background
      // fill specs into the DATA1 and DATA2 arrays. To recover the VM consumed by the array, we encompass everything in
      // a "save"-"restore" pair.
      saveVMState();
      loadArray(DATA0, pts);
      if(sizeVaries) loadArray(DATA1, adornSizes);
      if(fillVaries) loadBkgFillArray(DATA2, backFills, sizes);
      
      // invoke the POLYSTEMADORN prolog procedure
      sb.setLength(0);
      includeFunctionInProlog(adornProc);
      includeFunctionInProlog(POLYSTEMADORN);
      sb.append(stemProc).append(" ").append(doStems ? "1 " : "0 ").append(bfSpec).append(" ");
      sb.append(sizeVaries ? "-1" : Utilities.toString(fixedAdornSz,7,3)).append(" ");
      sb.append(n).append(" /").append(adornProc).append(" ").append(POLYSTEMADORN);
   
      appendLine(sb.toString());
   
      // clear the prolog data arrays that were loaded and "restore" to recover VM allocated to them
      loadArray(DATA0, (Point2D[])null);
      if(sizeVaries) loadArray(DATA1, (double[])null);
      if(fillVaries) loadBkgFillArray(DATA2, null, null);
      restoreVMState();

      // mark end of code fragment with a comment 
      addComment("END renderStemmedAdornments");
	}
	
   /**
    * Helper method for {@link #renderStemmedAdornments}. When the background fill applied to an adornment varies from
    * location to location, this method is called to allocate a Postscript array object referenced by the specified name
    * and load it with the background fill specifications to be applied in sequence.
    * 
    * <p>The background fill specification is an array that comes in one of 4 forms: 
    * <ul>
    * <li><i>[0]</i> : No fill (transparent).</li>
    * <li><i>[1 r g b]</i> : Fill with solid color (r,g,b), where each R/G/B component lies in [0..1].</li>
    * <li><i>[2 [x0 y0 x1 y1] c0 c1]</i> : Axial gradient fill. The gradient starts at color c0 at (x0,y0) and smoothly
    * transitions to color c1 at (x1,y1). Both colors are specified as a 3-element array [r g b], where each component
    * again lies in [0..1].</li>
    * <li>[3 [x0 y0 r0 x1 y1 r1] c0 c1]</i> : Radial gradient fill. Here (x0,y0) is the center of an inner circle of
    * radius r0 (which can be 0), while (x1, y1) is the center of an outer circle of radius r1. The gradient varies 
    * from color c0 along the circumference of the inner circle to color c1 along the outer circle.</li>
    * </ul>
    * Note that all coordinates for the gradient fills are calculated in user space with respect to an origin that is
    * ASSUMED to be located at the bottom-left corner of the adornment bounding box. This is why adornment size
    * information must be supplied to the method. Of course, if the background fill is not a gradient, the size
    * information is not needed.</p>
    * 
    * <p>There is no limit placed on the size of the array. If repeated array loads occur, the virtual memory 
    * available to the Postscript interpreter could be exhausted. Thus, it is a good idea to take a "save" snapshot 
    * prior to allocating the array, then once done with its contents, call this method with the same name but a null
    * list and issue a "restore" to recover the virtual memory that the array object (which is no longer accessible) had
    * occupied.</p>
    * 
    * <p>The array is allocated first, then it is populated 5 elements at a time using the "putInterval" command.</p>
    * 
    * @param name The name assigned to the Postscript array object allocated and loaded here.
    * @param adornBf The background fill list, as supplied to {@link #renderStemmedAdornments}. If null or empty, the
    * specified name is defined as a Postscript null object. This is done to recover VM previously allocated to the
    * literal. Otherwise it will contain 1 entry if the applied fill does not change, else N, where N is the number of
    * adornments rendered. Note that when the fill is a gradient but the adornment size changes, it is necessary to
    * specify a different fill spec for each adornment, as the geometry will vary with adornment size.
    * @param adornSz The adornment size list, as supplied to {@link #renderStemmedAdornments}. Will contain 1 entry if
    * the adornment size does not change, else N.
    */
   private void loadBkgFillArray(String name, List<BkgFill> adornBf, List<Double> adornSz)
   {
      final int PTS_PER_PUT = 5;         // when using putInterval cmd to fill a big array

      // if background fill list is null or empty, just set name to the null object  
      if(adornBf == null || adornBf.isEmpty())
      {
         appendLine( "/" + name + " null def" );
         return;
      }

      boolean sizeVaries = (adornSz.size() > 1);
      double sz = 0;
      if(!sizeVaries)
      {
         Double dblSz = adornSz.get(0);
         sz = (dblSz == null) ? 0 : dblSz;
         if(sz < 0 || !Utilities.isWellDefined(sz)) sz = 0;
      }
      
      boolean fillVaries = (adornBf.size() > 1);
      BkgFill bf = (!fillVaries) ? adornBf.get(0) : null;
      
      int n = Math.max(adornBf.size(), adornSz.size());

      // we prepare a sequence of commands in a string buffer, then dump the buffer when we're done
      StringBuilder sb = new StringBuilder( 200 );
      
      appendLine( "/" + name + " " + n + " array def" );

      // now populate using a series of "ar index [...] putinterval" commands
      for(int i=0; i<n; i+=PTS_PER_PUT)
      {
         sb.setLength(0);
         sb.append(name).append(" ").append(i).append(" [ ");
         int j=0;
         while(i+j < n && j < PTS_PER_PUT)
         {
            if(fillVaries) bf = adornBf.get(i+j);
            if(sizeVaries)
            {
               Double dblSz = adornSz.get(i+j);
               sz = (dblSz == null) ? 0 : dblSz;
               if(sz < 0 || !Utilities.isWellDefined(sz)) sz = 0;
            }
            
            if(bf == null || bf.isTransparent() || sz == 0) sb.append("[0] ");   // no fill
            else
            {
               String c1 = getRGBColorString(bf.getColor1().getRGB() & 0x00FFFFFF, true);
               String c2 = getRGBColorString(bf.getColor2().getRGB() & 0x00FFFFFF, true);
               if(bf.getFillType() == BkgFill.Type.SOLID)
                  sb.append("[1 ").append(c1).append("] ");
               else
               {
                  // gradient type (2=axial, 3=gradient) + gradient coords [x0 y0 x1 y1] or [x0 y0 0 x1 y1 r1].
                  sb.append("[");
                  if(bf.getFillType() == BkgFill.Type.AXIAL)
                  {
                     Point2D[] endPts = bf.getAxialEndpoints(sz, sz);
                     sb.append("2 [").append(Utilities.toString(endPts[0],7,3)).append(" ");
                     sb.append(Utilities.toString(endPts[1],7,3)).append("]");
                  }
                  else
                  {
                     double fx = bf.getFocusX() * sz / 100.0;
                     double fy = bf.getFocusY() * sz / 100.0;
                     sb.append("3 [");
                     sb.append(Utilities.toString(fx,7,3)).append(" ").append(Utilities.toString(fy,7,3)).append(" 0 ");
                     fx = sz / 2.0;
                     fy = sz / 2.0;
                     sb.append(Utilities.toString(fx,7,3)).append(" ").append(Utilities.toString(fy,7,3)).append(" ");
                     sb.append(Utilities.toString(Math.sqrt(fx*fx + fy*fy),7,3)).append("]");
                  }
                  
                  // the two color stops
                  sb.append(" [").append(c1).append("] [").append(c2).append("]] ");
               }
            }
            ++j;
         }
         sb.append( "] putinterval" );
         appendLine(sb.toString());
      }
   }

	
	/**
    * Draw the specified adornment at each of the specified locations in user space. The size and/or fill color of each
    * adornment may vary, but all adornments are stroked using the current stroke properties. The method does not
    * render any text with each adornment.
    * 
    * @param coord List of N points, {(x,y)}, where an adornment should be drawn. In milli-inches. If any given point is
    * not well-defined, it is ignored.
    * @param szBox The size of the adornment's bounding box at each corresponding location in the <i>coord</i> list. It
    * should have the same length N as the <i>coord</i> list, OR contain only a single element. In the latter case, all
    * adornments are drawn at the size given by that one element. Any ill-defined or negative value in the <i>szBox</i>
    * array is treated as zero.
    * @param fillRGB The fill color for the adornment at each corresponding location in the <i>coord</i> array. If null,
    * then all adornments are filled with current fill color. Otherwise, it must have the same length N as the 
    * <i>coord</i> list. Each color in the list is treated as opaque; any alpha component is ignored, since Postscript
    * does not support translucent color.
    * @param m The adornment type. If null, no action is taken.
    * @param doStroke If false, adornments are filled only, not stroked.
    * @throws UnsupportedOperationException if graphics state stack overflows or if there's no current page context.
	 */
	public void renderMultipleAdornments(List<Point2D> coord, List<Double> szBox, List<Color> fillRGB, Marker m, 
	      boolean doStroke)
	{
	   // abort if no coordinate list specified, no size specified or no adornment symbol was specified
	   if(m == null || coord == null || coord.isEmpty() || szBox == null || szBox.isEmpty()) return;
	   
	   // if the size and coordinate lists are the same length, then size varies at each location. Otherwise, size is
	   // constant and is set to the value in the first element of the szBox list.
	   boolean sizeVaries = szBox.size() == coord.size();
	   
	   // fill color varies if the fillRGB list is non-null. It must be the same size as the coordinate list
	   boolean fillVaries = fillRGB != null;
	   if(fillVaries && fillRGB.size() != coord.size()) return;
	   
	   // prepare data arrays
	   Point2D[] pts = new Point2D[coord.size()];
	   for(int i=0; i<coord.size(); i++) pts[i] = coord.get(i);
	   
	   double[] sizes = null;
	   double fixedSz = 0;
	   if(sizeVaries)
	   {
	      sizes = new double[szBox.size()];
	      for(int i=0; i<szBox.size(); i++)
	      {
	         Double dSz = szBox.get(i);
	         double d = (dSz != null) ? dSz : 0;
	         sizes[i] = (d < 0 || !Utilities.isWellDefined(d)) ? 0 : d;
	      }
	   }
	   else
	   {
	      Double dSz = szBox.get(0);
	      fixedSz = (dSz != null) ? dSz : 0;
	      if(fixedSz < 0 || !Utilities.isWellDefined(fixedSz)) return;
	   }
	   
      // we draw nothing if the current pen stroke is empty and there's nothing to fill
      boolean stroked = doStroke && !currentGraphics.isStrokingDisabled();
      
      boolean filled = m.isClosed() && (fillVaries || currentGraphics.isOpaqueTextFill);
      if(!(stroked || filled)) return;
      
      // find the name of the prolog procedure that renders the specified adornment; if there is none, draw nothing. 
      String adornProc = getAdornmentPrologProc(m);

      // all rendering occurs in the context of a printed page
      if(!pageStarted) throw new UnsupportedOperationException(NOPAGE_EXCP);

      // make sure we have enough room on the graphics state stack. We need one space for the "save" op, and another 
      // IF the adornment is filled.
      int nStackSaves = filled ? 2 : 1;
      if(graphicsStack.size() + nStackSaves > MAX_GSTATE_DEPTH) throw new UnsupportedOperationException(GSOVFL_EXCP);

      // mark start of code fragment with a comment
      addComment("renderMultipleAdornments");

      // disable stroking if requested.
      if((!doStroke) && !currentGraphics.isStrokingDisabled()) 
         appendLine("0 " + ENABLESTROKE + " 0 setlinewidth ");
      
      // we need to load the adornment locations into the prolog's DATA0 array. If the size varies, load the sizes into 
      // the DATA1 array. Finally, if the fill color varies, load the fill colors (as R,G,B triplets) into the the DATA2
      // array. To recover the VM consumed by the arrays, we encompass everything in a "save"-"restore" pair. Any 
      // ill-defined points are set to "null" in the DATA0 array.
      saveVMState();
      loadArray(DATA0, pts);
      if(sizes != null) loadArray(DATA1, sizes);
      if(fillRGB != null) loadColorArray(DATA2, fillRGB);
      
      // invoke the appropriate prolog proc based on whether symbol size and/or fill color varies.
      includeFunctionInProlog(adornProc);
      int fillCode = filled ? 1 : 0;
      StringBuilder sb = new StringBuilder();
      if(sizeVaries && fillVaries)
      {
         includeFunctionInProlog(POLYSIZEFILLADORN);
         sb.append(pts.length).append(" /").append(adornProc).append(" ");
         sb.append(POLYSIZEFILLADORN);
      }
      else if(sizeVaries)
      {
         includeFunctionInProlog(POLYSIZEADORN);
         sb.append(fillCode).append(" ").append(pts.length);
         sb.append(" /").append(adornProc).append(" ");
         sb.append(POLYSIZEADORN);
      }
      else if(fillVaries)
      {
         includeFunctionInProlog(POLYFILLADORN);
         sb.append(pts.length).append(" ").append(Utilities.toString(fixedSz,7,3));
         sb.append(" /").append(adornProc).append(" ");
         sb.append(POLYFILLADORN);
      }
      else
      {
         includeFunctionInProlog(POLYADORN);
         sb.append("() 0 ").append(fillCode).append(" ").append(pts.length);
         sb.append(" ").append(Utilities.toString(fixedSz,7,3)).append(" /").append(adornProc).append(" ");
         sb.append(POLYADORN);
      }
      appendLine(sb.toString());
      
      // clear the DATA0, DATA1, DATA2 arrays and "restore" to recover VM allocated to the arrays
      loadArray(DATA0, (Point2D[])null);
      if(sizes != null) loadArray(DATA1, (double[])null );
      if(fillRGB != null) loadColorArray(DATA2, null);
      restoreVMState();

      // re-enable stroking if we temporarily disabled it.
      if((!doStroke) && !currentGraphics.isStrokingDisabled()) 
         appendLine("1 " + ENABLESTROKE + " " + Utilities.toString(currentGraphics.lineWidth,7,3) + " setlinewidth ");

      // mark end of code fragment with a comment 
      addComment("END renderMultipleAdornments");
	}
	
	/**
	 * Prepares the Postscript command fragment that draws the specified adornment with the specified size and center 
	 * point, possibly rotated about that center point. If the adornment is closed, it is filled with the current 
	 * text/fill color; otherwise, it is not filled at all. Every adornment type is stroked IAW the current stroke
	 * properties defined in the graphics state. The adornment is not filled if the current fill color is transparent,
	 * and it is not stroked if the current pen stroke is empty (transparent or zero line width). 
	 * 
	 * <p>The command fragment returned is such that any current path existing when the fragment is executed will be 
	 * ignored, and the current path is empty after execution.  If the adornment type is unrecognized or the adornment 
	 * size is less than or equal to zero, then the method returns an empty command string.</p>
	 * 
    * <p>If the adornment is zero size and has no text label, nothing is rendered. A zero-size adornment with a 
    * non-empty text label is still rendered -- only the text label is rendered, centered horizontally and vertically 
    * about the center point.</p>
    * 
	 * @param cap The adornment type.
	 * @param capSize Size of square box enclosing adornment, in thousandth-inches.
	 * @param x,y Location of adornment's center point in user space, in thousandth-inches.
	 * @param rot Rotation angle in degrees CCW.
	 * @param text If this is a non-empty string, it is drawn centered horizontally and vertically about the center 
	 * point of the adornment. It is painted using the current stroke color rather than the text/fill color.
    * @return The PS command fragment which will render the adornment as specified. The fragment begins with a 
    * space character so that it can be appended to a preceding command fragment. Returns an empty string if the 
    * args and the current graphics state are such that no marks would be made.
	 * @throws 	UnsupportedOperationException if graphics state stack overflows or if there's no current page context.
	 */
	private String doAdornment(Marker cap, double capSize, double x, double y, double rot, String text)
		throws UnsupportedOperationException
	{
		// find the name of the prolog procedure that renders the specified adornment; if there is none, or if the 
		// cap size is zero and there's no text label to draw, then nothing is rendered. 
		String adornProc = getAdornmentPrologProc(cap);
		if(adornProc == null || (capSize <= 0 && (text == null || text.isEmpty()))) return("");
		
		// make sure we'll render something!
		boolean doFill = capSize > 0 && cap.isClosed() && currentGraphics.isOpaqueTextFill;
		boolean doStroke = capSize > 0 && currentGraphics.isOpaqueStroke && currentGraphics.lineWidth > 0;
		boolean doLabel = currentGraphics.isOpaqueStroke && text != null && !text.isEmpty();
		if(!(doFill || doStroke || doLabel)) return("");

		// all rendering occurs in the context of a printed page
		if( !pageStarted ) throw new UnsupportedOperationException( NOPAGE_EXCP );

		// if there isn't enough room left on the graphics state stack, throw an exception. We need to save graphics 
		// state if we rotate adornment, and again if we must fill it.
		int nStackSaves = (rot != 0) ? 1 : 0;
		if(doFill) ++nStackSaves;
		if( graphicsStack.size() + nStackSaves > MAX_GSTATE_DEPTH )
			throw new UnsupportedOperationException( "Graphics state stack overflowed" );

		// prepare the command string invoking prolog procedure: "(string) vAdj fillCode size /proc x y rot doAdornment"
		// we must precede the adornment proc name by a forward slash so that it is treated as a literal; else it would 
		// be executed immediately rather than pushed onto the operand stack. 
		includeFunctionInProlog( adornProc );
		includeFunctionInProlog(DO_ADORN);
		int fillCode = doFill ? 1 : 0;
		String cmd = " () 0 ";
		if(doLabel)
			cmd = " (" + unicodeToPostscriptText(text) + ") " + Utilities.toString(-currentGraphics.fontSize/3.0,7,3) + " ";
		cmd += fillCode + " " + Utilities.toString(capSize,7,3) + " /" + adornProc + " " + 
			Utilities.toString(x,7,3) + " " + Utilities.toString(y,7,3) + " " + Utilities.toString(rot,7,3) + " " + 
		   DO_ADORN;
		return( cmd );
	}

	/**
	 * Render one of the supported <em>DataNav</em> adornment shapes with the specified size and center point, possibly 
	 * rotated about that center point. If the adornment is closed, it is filled with the current text/fill color; 
	 * otherwise, it is not filled at all. Every adornment type is stroked IAW the current stroke properties defined in
	 * the graphics state. If a non-empty text string is specified, it is drawn centered vertically and horizontally 
	 * about the adornment's center point, after the adornment has been filled and stroked. The string is painted using 
	 * the current stroke color rather than the current text/fill color.
	 * 
    * <p>If the adornment is zero size and has no text label, nothing is rendered. A zero-size adornment with a 
    * non-empty text label is still rendered -- only the text label is rendered, centered horizontally and vertically 
    * about the center point. If the current pen stroke is zero width or transparent, the adornment is not stroked. If
    * the pen stroke is transparent, the text string is not drawn. If the current text/fill color is transparent, the 
    * adornment is not filled.</p>
    * 
	 * @param cap The adornment type.
	 * @param capSize Size of square box enclosing adornment, in thousandth-inches.
	 * @param x,y Location of adornment's center point in user space, in thousandth-inches.
	 * @param rot Rotation angle in degrees CCW.
	 * @param text A text string to be painted at adornment's center point. Ignored if null or empty.
	 * @throws UnsupportedOperationException if graphics state stack overflows or if there's no current page context.
	 */
	public void renderAdornment(Marker cap, double capSize, double x, double y, double rot, String text)
	{
		String cmd = doAdornment(cap, capSize, x, y, rot, text);
		if(!cmd.isEmpty())
			appendLine( cmd );
	}

   /**
    * Render one of the supported <i>DataNav</i> adornment shapes with the specified dimensions and center point, 
    * possibly rotated about that center point. If the adornment is closed, it is filled IAW the background fill 
    * specified. The shape is stroked IAW the current stroke properties defined in the graphics state. If a non-empty 
    * text string is specified, it is drawn centered vertically and horizontally about the adornment's center point, 
    * after the adornment has been filled and stroked. The string is painted using the current text/fill color.
    * 
    * <p>If the adornment has zero width or height and has no text label, nothing is rendered. A zero-size adornment 
    * with a non-empty text label is still rendered -- only the text label is rendered, centered horizontally and 
    * vertically about the center point. If the current pen stroke is zero width or transparent, the adornment is not 
    * stroked. If the current text/fill color is transparent, the text string is not drawn. If the specified background 
    * fill is transparent, the adornment is not filled.</p>
    * 
    * <p><i>Unlike {@link #renderAdornment(Marker, double, double, double, double, String)}, this method supports 
    * filling a closed shape's interior with an axial or radial gradient, and it supports different scaling in the 
    * horizontal and vertial dimensions.</p>
    * 
    * @param m The adornment type.
    * @param x X-coordinate of adornment's center point in user space, in thousandth-inches.
    * @param y Y-coordinate of adornment's center point in user space, in thousandth-inches.
    * @param w Width of adornment in user space, in thousandth-inches.
    * @param h Height of adornment in user space, in thousandth-inches.
    * @param rot Rotation angle in degrees CCW.
    * @param text A text string to be painted at adornment's center point. Ignored if null or empty.
    * @param bf Background fill with which interior of a closed shape is painted. If null, shape will not be filled. 
    * <i><b>NOTE:</b> The {@link BkgFill} object supports a translucent color for a solid background fill, but PS does
    * not support translucent color. The alpha component of any color is ignored.</i>
    * @throws UnsupportedOperationException if graphics state stack overflows or if there's no current page context.
    */
	public void renderAdornmentEx(Marker m, double x, double y, double w, double h, double rot, String text, BkgFill bf)
	{
      // find the name of the prolog procedure that renders the specified adornment; stop if invalid.
      String adornProc = getAdornmentPrologProc(m);
      if(adornProc == null) return;
      
      // make sure we'll render something!
      boolean doFill = w > 0 && h > 0 && m.isClosed() && bf != null && !bf.isTransparent();
      boolean doStroke = w > 0 && h > 0 && currentGraphics.isOpaqueStroke && currentGraphics.lineWidth > 0;
      boolean doLabel = currentGraphics.isOpaqueTextFill && text != null && !text.isEmpty();
      if(!(doFill || doStroke || doLabel)) return;

      // the gradient fills require a user space with the origin at the bottom-left corner of the adornment -- so (x,y)
      // must equal (w/2, h/2). If the specified (x,y) location does not satisfy this requirement, then we must include
      // an additional translation to make it so.
      boolean doTrans = doFill && (bf.getFillType() != BkgFill.Type.SOLID) && (x != w/2 || y != h/2);
      
      // all rendering occurs in the context of a printed page
      if( !pageStarted ) throw new UnsupportedOperationException( NOPAGE_EXCP );

      // if there isn't enough room left on the graphics state stack, throw an exception. We need to save graphics 
      // state when we fill it or when we draw a text label. Any rotate, translate and differential scaling operations
      // are undone by their inverse operation.
      int nStackSaves = (doFill || doLabel) ? 1 : 0;
      if(doTrans) nStackSaves++;
      if(graphicsStack.size() + nStackSaves > MAX_GSTATE_DEPTH)
         throw new UnsupportedOperationException( "Graphics state stack overflowed" );

      // prepare the command string invoking prolog procedure: "(str) vAdj fillSpec /proc w h x y rot adornEx". If an
      // extra translation is required, that is included, along with a bracking gsave-grestore pair.
      includeFunctionInProlog(adornProc);
      includeFunctionInProlog(DO_ADORNEX);
      StringBuilder sb = new StringBuilder();
      if(doTrans)
      {
         sb.append("gsave ");
         sb.append(Utilities.toString(x-w/2,7,3)).append(" ").append(Utilities.toString(y-h/2,7,3)).append(" translate ");
         x = w/2;
         y = h/2;
      }
      
      if(doLabel)
      {
         sb.append("(").append(unicodeToPostscriptText(text)).append(") ");
         sb.append(Utilities.toString(-currentGraphics.fontSize/3.0,7,3)).append(" ");
      }
      else
         sb.append("() 0 ");
      if(doFill)
      {
         String c1 = getRGBColorString(bf.getColor1().getRGB() & 0x00FFFFFF, true);
         String c2 = getRGBColorString(bf.getColor2().getRGB() & 0x00FFFFFF, true);
         if(bf.getFillType() == BkgFill.Type.SOLID)
            sb.append("[1 ").append(c1).append("] ");
         else
         {
            // gradient type (2=axial, 3=radial) + gradient coords [x0 y0 x1 y1] or [x0 y0 0 x1 y1 r1].
            sb.append("[");
            if(bf.getFillType() == BkgFill.Type.AXIAL)
            {
               Point2D[] pts = bf.getAxialEndpoints(w, h);
               sb.append("2 [").append(Utilities.toString(pts[0],7,3)).append(" ");
               sb.append(Utilities.toString(pts[1],7,3)).append("]");
            }
            else
            {
               double fx = bf.getFocusX() * w / 100.0;
               double fy = bf.getFocusY() * h / 100.0;
               sb.append("3 [");
               sb.append(Utilities.toString(fx,7,3)).append(" ").append(Utilities.toString(fy,7,3)).append(" 0 ");
               fx = w / 2.0;
               fy = h / 2.0;
               sb.append(Utilities.toString(fx,7,3)).append(" ").append(Utilities.toString(fy,7,3)).append(" ");
               sb.append(Utilities.toString(Math.sqrt(fx*fx + fy*fy),7,3)).append("]");
            }
            
            // the two color stops
            sb.append(" [").append(c1).append("] [").append(c2).append("]] ");
         }
      }
      else
         sb.append("[0] ");
      sb.append("/").append(adornProc).append(" ");
      sb.append(Utilities.toString(w,7,3)).append(" ").append(Utilities.toString(h,7,3)).append(" ");
      sb.append(Utilities.toString(x,7,3)).append(" ").append(Utilities.toString(y,7,3)).append(" ");
      sb.append(Utilities.toString(rot,7,3)).append(" ").append(DO_ADORNEX);
      
      // undo translation that put origin at bottom-left corner of adornment rectangle.
      if(doTrans) sb.append(" grestore");
      
      appendLine(sb.toString());
	}
	
   
   /**
    * Same as {@link #renderAdornmentEx(Marker, double, double, double, double, double, String, BkgFill)}, but 
    * optionally disables stroking of the adornment.
    * 
    * @param m The adornment type.
    * @param x X-coordinate of adornment's center point in user space, in thousandth-inches.
    * @param y Y-coordinate of adornment's center point in user space, in thousandth-inches.
    * @param w Width of adornment in user space, in thousandth-inches.
    * @param h Height of adornment in user space, in thousandth-inches.
    * @param rot Rotation angle in degrees CCW.
    * @param text A text string to be painted at adornment's center point. Ignored if null or empty.
    * @param bf Background fill with which interior of a closed shape is painted. If null, shape will not be filled. 
    * @param stroke Set this false to disable stroking of the adornment shape. It will only be filled (if closed).
    */
   public void renderAdornmentEx(
	      Marker m, double x, double y, double w, double h, double rot, String text, BkgFill bf, boolean stroke)
	{
	   if((!stroke) && (!currentGraphics.isStrokingDisabled()))
	      appendLine("0 " + ENABLESTROKE + " 0 setlinewidth ");
	   
	   renderAdornmentEx(m, x, y, w, h, rot, text, bf);
	   
	   // re-enable stroking if we temporarily disabled it.
      if((!stroke) && !currentGraphics.isStrokingDisabled()) 
         appendLine("1 " + ENABLESTROKE + " " + Utilities.toString(currentGraphics.lineWidth,7,3) + " setlinewidth ");
	}
	/** 
	 * Optionally fill the region bounded by a polyline, then optionally stroke the polyline itself. In the fill phase, 
    * a closed path for filling is created by connecting all well-defined points in the specified polyline array, while 
    * skipping over ill-defined ones. In the stroke phase, a possibly disconnected path is created -- each ill-defined 
    * point in the array will introduce a gap in the polyline path.
    * 
    * <p><em>Note</em>: This method was specifically created to render data in the "errorband" display mode.</p>
	 * 
	 * @param polyline The set of points defining the polyline, in plotting order. If this array is null or contains less
    * than 3 points, the method makes no changes to this PS document.
	 * @param isStroked If true, the bounding polyline is stroked. However, if the current pen stroke is empty (zero 
	 * width or transparent), then it will not be stroked.
	 * @param isFilled If true, the region bounded by polyline is filled with the current text/fill color, but NOT if
	 * that fill color is transparent.
	 * @throws UnsupportedOperationException if graphics state stack overflows or if there's no current page context.
	 */
	public void renderPolyFill(Point2D[] polyline, boolean isStroked, boolean isFilled) 
		throws UnsupportedOperationException
	{
		// polylines must have at least 3 points, or we render nothing
		if(polyline == null || polyline.length < 3) return;

		// if the polyline path is neither stroked nor filled, then we render nothing! Check for empty pen stroke and
		// transparent fill color!
		if(isStroked) isStroked = currentGraphics.isOpaqueStroke && currentGraphics.lineWidth > 0;
		if(isFilled) isFilled = currentGraphics.isOpaqueTextFill;
		if( !(isStroked || isFilled) ) return;

		// all rendering occurs in the context of a printed page
		if( !pageStarted ) throw new UnsupportedOperationException( NOPAGE_EXCP );

		// make sure we have enough room on the graphics state stack. We need one space for the "save" op issued prior 
		// to loading the polyline points, and another if the bounded region is filled.
		int nStackSaves = isFilled ? 2 : 1;
		if(graphicsStack.size() + nStackSaves > MAX_GSTATE_DEPTH)
			throw new UnsupportedOperationException( GSOVFL_EXCP );

		// mark start of code fragment with a comment
		addComment( "renderPolyFill" );

		// load the defining points for the polyline into the prolog's DATA0 array. To recover the VM consumed by this 
      // array, we encompass everything in a "save"-"restore" pair. Any ill-defined points are set to "null".
		saveVMState();
		loadArray(DATA0, polyline);

      // invoke the appropriate prolog procedure: "stroked? filled? n polyFill"
      includeFunctionInProlog(POLYFILL);
      String cmd = 
         (isStroked ? "1 " : "0 ") + (isFilled ? "1 " : "0 ") + polyline.length + " " + POLYFILL;
      appendLine(cmd);
      
		// clear the DATA0 array and "restore" to recover VM allocated to it
		loadArray(DATA0, (Point2D[])null);
		restoreVMState();

		// mark end of code fragment with a comment 
		addComment( "END renderPolyFill" );
	}

	/**
	 * Render a set of polylines with varying fill and stroke colors.
	 * 
	 * @param polylines Each element is a list of points defining one polyline, in plotting order. Any element that is
	 * null or contains less than 3 points is skipped.
	 * @param closed Each element is a flag indicating whether or no the corresponding polyline should be closed. If this
	 * element is null or empty, all polylines are closed. If it has fewer elements than <i>polylines</i>, then the last
	 * element is reused. If it has more elements, the extras are ignored.
	 * @param fillRGB Each element is an integer determining how the corresponding polyline is filled: a non-negative
	 * value is treated as a packed RGB integer 0x00RRGGBB specifying the desired fill color; -1 = NO FILL; otherwise,
	 * the current fill color is applied. If this element is null or empty, NO polylines are filled. If it has fewer 
	 * elements than <i>polylines</i>, then the last element is reused. If it has more elements, the extras are ignored.
	 * @param strokeRGB Each element is an integer determining how the corresponding polyline is stroked: a non-negative
    * value is treated as a packed RGB integer 0x00RRGGBB specifying the desired stroked color; -1 = NO STROKE; else,
    * the current stroke color is applied. If this element is null or empty, NO polylines are stroked. If it has fewer 
    * elements than <i>polylines</i>, then the last element is reused. If it has more elements, the extras are ignored.
	 */
	public void renderPolyFills(List<List<Point2D>> polylines, List<Boolean> closed, List<Integer> fillRGB,
	      List<Integer> strokeRGB)
   {
	   // there's nothing to do if no polylines were specified
	   if(polylines == null || polylines.isEmpty()) return;
	   
	   // there's also nothing to do if the fill and stroke color lists are unspecified
	   if((fillRGB == null || fillRGB.isEmpty()) && (strokeRGB == null || strokeRGB.isEmpty())) return;
	   
      // all rendering occurs in the context of a printed page
      if( !pageStarted ) throw new UnsupportedOperationException( NOPAGE_EXCP );

      // make sure we have enough room on the graphics state stack. We need one space for the "save" op issued prior 
      // to loading the polyline points, and another to render the polyline path.
      if(graphicsStack.size() + 2 > MAX_GSTATE_DEPTH)
         throw new UnsupportedOperationException( GSOVFL_EXCP );

      // if list of closed flags is null or empty, then all polylines are closed
      if(closed == null || closed.isEmpty())
      {
         closed = new ArrayList<>();
         closed.add(Boolean.TRUE);
      }
      
      // if list of fill colors is null or empty, then NO polylines are filled. Similarly for the list of stroke colors.
      if(fillRGB == null || fillRGB.isEmpty())
      {
         fillRGB = new ArrayList<>();
         fillRGB.add(-1);
      }
      if(strokeRGB == null || strokeRGB.isEmpty())
      {
         strokeRGB = new ArrayList<>();
         strokeRGB.add(-1);
      }
      
      // mark start of code fragment with a comment
      addComment( "renderPolyFills" );
      
      // we rely on the POLYFILLEX procedure to render each polyline
      includeFunctionInProlog(POLYFILLEX);
      
      // render each polyline separately
      for(int i=0; i<polylines.size(); i++)
      {
         List<Point2D> polyline = polylines.get(i);
         if(polyline != null && polyline.size() > 2)
         {
            saveVMState();
            loadArray(DATA0, polyline.toArray(new Point2D[0]));
            
            int n = polyline.size();
            boolean close = closed.get(i < closed.size() ? i : closed.size() - 1);
            Integer fillC = fillRGB.get(i<fillRGB.size() ? i : fillRGB.size()-1);
            if(fillC == null) fillC = -1;
            Integer strkC = strokeRGB.get(i<strokeRGB.size() ? i : strokeRGB.size()-1);
            if(strkC == null) strkC = -1;
            String cmd = strkC + " " + fillC + " " + (close ? "1 " : "0 ") + n + " " + POLYFILLEX;
             appendLine(cmd);

            loadArray(DATA0, (Point2D[])null);
            restoreVMState();
         }
      }
      
      // mark end of code fragment with a comment 
      addComment( "END renderPolyFills" );
   }
	
	/**
	 * Render an indexed-color image.
	 * 
	 * @param w The image width (number of samples per image row).
	 * @param h The image height (number of image rows).
	 * @param botLeft Location of image's bottom left corner in current user space.
	 * @param topRight Location of image's top right corner in current user space.
	 * @param colorLUT The color lookup table to use when translating image data samples to RGB color. 
	 * @param rgbNaN Packed RGB color assigned to lookup table index 0, to which every ill-defined image datum (infinite
	 * or NaN) is mapped.
	 * @param interpolate True to enable smooth image interpolation when the source image is scaled to a significantly 
	 * different size. The interpolation algorithm is implementation-independent and may, in fact, not be available on 
	 * some older Postscript printers. If disabled, the default nearest-neighor interpolation algorithm is used, leading
	 * to a blocky image when scaled up in size.
	 * @param provider This must iterate over <code>w*h</code> image samples. It is assumed that the image is "scanned"
	 * from left to right and bottom to top. Each sample should be an index into the 8-bit LUT, so sample values are 
	 * restricted to [0..255]. All ill-defined data (infinite or NaN) must map to LUT index 0, while all well-defined
	 * data map to LUT indices [1..255].
	 */
	public void renderIndexedImage(int w, int h, Point2D botLeft, Point2D topRight, ColorLUT colorLUT, int rgbNaN, 
	         boolean interpolate, Iterator<Integer> provider)
	{
      // check arguments
      if(w <= 0 || h <= 0 || provider == null) return;
      if(!Utilities.isWellDefined(botLeft) || !Utilities.isWellDefined(topRight)) return;
      
      // all rendering occurs in the context of a printed page
      if(!pageStarted) throw new UnsupportedOperationException(NOPAGE_EXCP);

      // make sure we have enough room on the graphics state stack
      if(graphicsStack.size() + 1 > MAX_GSTATE_DEPTH)
         throw new UnsupportedOperationException(GSOVFL_EXCP);

      // mark start of code fragment with a comment
      addComment("renderIndexedImage");

      // translate and scale so that the Postscript-convention "unit square" maps to the desired rectangular region to 
      // be covered. Since the image samples are provided L-to-R and B-to-T, the ImageMatrix entry is simple...
      String cmd = "gsave ";
      cmd += Utilities.toString(botLeft,7,3) + " translate";
      cmd += " " + Utilities.toString(topRight.getX()-botLeft.getX(),7,3);
      cmd += " " + Utilities.toString(topRight.getY()-botLeft.getY(),7,3) + " scale";
      appendLine(cmd);
      
      // set up the indexed colorspace using the CMAPLUT procedure: {rgb0 keyFrames keyColors cmapLUT}
      includeFunctionInProlog(CMAPLUT);
      StringBuilder sb = new StringBuilder();
      sb.append("{[").append(Utilities.toString(((rgbNaN >> 16) & 0x00FF)/255.0,4,4)).append(" ");
      sb.append(Utilities.toString(((rgbNaN >> 8) & 0x00FF)/255.0,4,4)).append(" ");
      sb.append(Utilities.toString((rgbNaN & 0x00FF)/255.0,4,4)).append("] ");
      
      float[] keyFrames = colorLUT.getKeyFrames();
      Color[] keyColors = colorLUT.getKeyColors();
      sb.append("[");
      for(int i=0; i<keyFrames.length; i++)
      {
         sb.append(Utilities.toString(keyFrames[i], 4, 4));
         if(i < keyFrames.length-1) sb.append(" ");
      }
      sb.append("] [");
      float[] rgb = new float[] {0f, 0f, 0f};
      for(int i=0; i<keyColors.length; i++)
      {
         keyColors[i].getRGBColorComponents(rgb);
         sb.append("[").append(Utilities.toString(rgb, 4, 4)).append("]");
         if(i < keyColors.length-1) sb.append(" ");
      }
      sb.append("] ").append(CMAPLUT).append("}");
      
      cmd = "[/Indexed /DeviceRGB 255 " + sb + "] setcolorspace";
      appendLine(cmd);
      
      // send image command so that it uses image data included in the file itself
      appendLine("<<");
      cmd = "   /ImageType 1 /Width " + w + " /Height " + h + " /BitsPerComponent 8";
      cmd += " /Decode [0 255] /Interpolate " + (interpolate ? "true" : "false");
      cmd += " /ImageMatrix [" + w + " 0 0 " + h + " 0 0]";
      appendLine(cmd);
      appendLine("   /DataSource currentfile /ASCII85Decode filter");
      appendLine(">> image");
      
      // append the image data directly into the output buffer, encoded in ASCII85
      ASCII85Encoder encoder = new ASCII85Encoder(mainBuf, MAX_LINELENGTH);
      int nSamples = 0;
      while(provider.hasNext())
      {
         int sample = provider.next();
         encoder.put((byte) (sample & 0x00ff));
         ++nSamples;
      }
      while(nSamples < w*h)   // just in case provider does not provide the entire image!
		{
			encoder.put((byte) 0);
			++nSamples;
		}
      encoder.terminate();
      
      // append the required ASCII85 end-of-data marker on the next line. Even though the documentation says that all
      // whitespace is ignored, I found that the PS document fails if there is a blank line between the last line of
      // ASCII85 character sequence and the EOD marker!
      char lastChar = mainBuf.charAt(mainBuf.length()-1);
      if(lastChar == '\r' || lastChar == '\n') mainBuf.append("~>\r\n");
      else mainBuf.append("\r\n~>\r\n");
      
      appendLine("grestore");
      
      // mark end of code fragment with a comment 
      addComment("END renderIndexedImage");
	}
	
   /**
    * Fill a rectangle in user space with a linear color gradient representative of the <i>FypML</i> color lookup table
    * specified (color map + direction). The rectangle is not stroked.
    * 
    * @param botLeft Location of target rectangle's bottom left corner in current user space.
    * @param topRight Location of target rectangle's top right corner in current user space.
    * @param colorLUT Color lookup table. If null, defaults to a grayscale LUT from black to white.
    */
	public void renderColormapGradient(Point2D botLeft, Point2D topRight, ColorLUT colorLUT)
	{
      // check arguments
      if(!Utilities.isWellDefined(botLeft) || !Utilities.isWellDefined(topRight)) return;
      if(colorLUT == null) colorLUT = new ColorLUT();
      
      // all rendering occurs in the context of a printed page
      if(!pageStarted) throw new UnsupportedOperationException(NOPAGE_EXCP);

      // make sure we have enough room on the graphics state stack
      if(graphicsStack.size() + 1 > MAX_GSTATE_DEPTH)
         throw new UnsupportedOperationException(GSOVFL_EXCP);

      // we need gsave-grestore pair b/c we're temporarily changing the current color to a gradient pattern
      addComment("renderColormapGradient");
      appendLine("gsave");
      
      // set the current path to the specified rectangle in current user space coords
      includeFunctionInProlog(DO_RECT);
      double h = topRight.getY() - botLeft.getY();
      double w = topRight.getX() - botLeft.getX();
      appendLine(Utilities.toString(h,7,3) + " " + Utilities.toString(w,7,3) + " " + 
                  Utilities.toString(botLeft,7,3) + " " + DO_RECT);
      
      // fill rectangle with a linear gradient representation of the specified color lookup table. Since we temporarily 
      // change the current color to a gradient pattern, we bracket this in a gsave-grestore pair, then reset the path 
      // after the grestore...
      includeFunctionInProlog(CMAPFILL);
      
      double x0 = botLeft.getX(), y = botLeft.getY(), x1 = topRight.getX();
      float[] keyFrames = colorLUT.getKeyFrames();
      Color[] keyColors = colorLUT.getKeyColors();
      StringBuilder sb = new StringBuilder();
      sb.append("[").append(Utilities.toString(x0,7,3)).append(" ").append(Utilities.toString(y,7,3)).append(" ");
      sb.append(Utilities.toString(x1,7,3)).append(" ").append(Utilities.toString(y,7,3)).append("] [");
      for(int i=0; i<keyFrames.length; i++)
      {
         sb.append(Utilities.toString(keyFrames[i], 4, 4));
         if(i < keyFrames.length-1) sb.append(" ");
      }
      sb.append("] [");
      float[] rgb = new float[] {0f, 0f, 0f};
      for(int i=0; i<keyColors.length; i++)
      {
         keyColors[i].getRGBColorComponents(rgb);
         sb.append("[").append(Utilities.toString(rgb, 4, 4)).append("]");
         if(i < keyColors.length-1) sb.append(" ");
      }
      sb.append("] ").append(CMAPFILL);
      appendLine(sb.toString());
      
      appendLine("grestore");
      addComment("END renderColormapGradient");
	}
	
   /**
    * Render an opaque RGB image, or a cropped portion of that image. The image or subimage is scaled as needed (with 
    * smooth interpolation enabled) to fit within a bounding rectangle in the current user space.
    * 
    * <p><i>Support for image with transparent background</i>. As of V4.5.2, a Language Level 3 feature is used to 
    * prevent painting of any fully transparent pixels (alpha component == 0) in the source image. A type 4 image
    * dictionary is used with an arbitrary mask color of R=1, G=2, B=3. When image pixels are written to the PS
    * document, any transparent pixel is set to the mask color. All such pixels will not be painted when the image is
    * rendered on the PS device. Of course, if the original source image has lots of opaque pixels in the mask color,
    * this solution breaks down.</p>
    * 
    * @param bi The image.
    * @param cropRect Rectangle defining the cropped portion of the source image to be rendered, in image space pixels. 
    * A valid crop rectangle (X,Y,W,H) must satisfy: X &ge; 0, Y &ge; 0, W &gt; 0, H &gt; 0, X+W &le; image width, 
    * Y+W &le; image height. If crop rectangle is null or invalid, the entire image is drawn. 
    * @param botLeft Location of image's bottom left corner in current user space.
    * @param topRight Location of image's top right corner in current user space.
    */
   public void renderRGBImage(BufferedImage bi, Rectangle cropRect, Point2D botLeft, Point2D topRight)
   {
      // check arguments
      if(bi == null || !Utilities.isWellDefined(botLeft) || !Utilities.isWellDefined(topRight)) return;
      
      // check crop rectangle if specified. If it is not valid, entire image will be drawn
      if(cropRect != null)
      {
         int w = bi.getWidth();
         int h = bi.getHeight();
         boolean valid = cropRect.x >= 0 && cropRect.y >= 0 && cropRect.width > 0 && cropRect.height > 0;
         valid = valid && (cropRect.x + cropRect.width <= w) && (cropRect.y + cropRect.height <= h);
         if(!valid) cropRect = null;
      }
      
      // all rendering occurs in the context of a printed page
      if(!pageStarted) throw new UnsupportedOperationException(NOPAGE_EXCP);

      // make sure we have enough room on the graphics state stack
      if(graphicsStack.size() + 1 > MAX_GSTATE_DEPTH)
         throw new UnsupportedOperationException(GSOVFL_EXCP);

      // mark start of code fragment with a comment
      addComment("renderRGBImage");

      // translate and scale so that the Postscript-convention "unit square" maps to the desired rectangular region to 
      // be covered. Since the pixels will be provided L-to-R and B-to-T, the ImageMatrix entry below is simple...
      String cmd = "gsave ";
      cmd += Utilities.toString(botLeft,7,3) + " translate";
      cmd += " " + Utilities.toString(topRight.getX()-botLeft.getX(),7,3);
      cmd += " " + Utilities.toString(topRight.getY()-botLeft.getY(),7,3) + " scale";
      appendLine(cmd);
      
      // set the colorspace
      appendLine("/DeviceRGB setcolorspace");
      
      // send image command so that it uses image data included in the file itself
      int w = (cropRect == null) ? bi.getWidth() : cropRect.width;
      int h = (cropRect == null) ? bi.getHeight() : cropRect.height;
      appendLine("<<");
      cmd = "   /ImageType 4 /Width " + w + " /Height " + h + " /BitsPerComponent 8";
      cmd += " /Decode [0 1 0 1 0 1] /Interpolate true";
      cmd += " /ImageMatrix [" + w + " 0 0 " + h + " 0 0]";
      appendLine(cmd);
      appendLine("   /MaskColor [1 2 3] /DataSource currentfile /ASCII85Decode filter");
      appendLine(">> image");
      
      // append the image data directly into the output buffer, encoded in ASCII85. We use the image's color model to
      // translate the raw pixel data to R/G/B components. NOTE that we deliver the pixel data from B-to-T and L-to-R,
      // which matches the orientation of the current user space coordinates. If the image is cropped, we only deliver
      // the cropped portion of the image.
      ASCII85Encoder encoder = new ASCII85Encoder(mainBuf, MAX_LINELENGTH);
      Raster raster = bi.getRaster();
      ColorModel cm = bi.getColorModel();
      int xStart = (cropRect == null) ? 0 : cropRect.x;
      int xEnd = xStart + w;
      int yStart = (cropRect == null) ? 0 : cropRect.y;
      int yEnd = yStart + h;
      
      Object pixel = raster.getDataElements(0, 0, null);
      for(int y=yEnd-1; y>=yStart; y--)
         for(int x=xStart; x<xEnd; x++)
         {
            pixel = raster.getDataElements(x, y, pixel);
            if((cm.getAlpha(pixel) & 0x00ff) == 0)
            {
               // transparent pixel: Set it to the mask color R=1, G=2, B=3.
               encoder.put((byte) 1);
               encoder.put((byte) 2);
               encoder.put((byte) 3);
            }
            else
            {
               encoder.put((byte) (cm.getRed(pixel) & 0x00ff));
               encoder.put((byte) (cm.getGreen(pixel) & 0x00ff));
               encoder.put((byte) (cm.getBlue(pixel) & 0x00ff));
            }
         }
      encoder.terminate();
      
      // append the required ASCII85 end-of-data marker on the next line. Even though the documentation says that all
      // whitespace is ignored, I found that the PS document fails if there is a blank line between the last line of
      // ASCII85 character sequence and the EOD marker!
      char lastChar = mainBuf.charAt(mainBuf.length()-1);
      if(lastChar == '\r' || lastChar == '\n') mainBuf.append("~>\r\n");
      else mainBuf.append("\r\n~>\r\n");
      
      appendLine("grestore");

      // mark end of code fragment with a comment 
      addComment("END renderRGBImage");
   }
   
	/**
	 * Transform the current user space, establishing a new rectangular viewport with the specified origin, size, and 
	 * rotation with respect to the current "viewport". 
	 * 
	 * <p>In <em>DataNav</em>, each element that accepts child elements must define a "viewport" with respect to which 
	 * its children are positioned and sized. This method handles the two distinct kinds of viewports created in a 
	 * <em>DataNav</em> document:
	 * <ul>
	 * 	<li>Figure elements create a standard rectangular viewport that clips any child elements rendered within it.
    *    A graph element may also establish a clipping viewport for its data window.</li>
	 * 	<li>Most other elements create a NON-CLIPPING rectangular viewport. In this case, all we have to do is 
    *    translate to the bottom-left corner and rotate.</li>
	 * </ul>
	 * </p>
	 * 
	 * <p>Note that this method does not scale user space. By convention, <code>PSDoc</code> converts user space units to 
	 * thousandth-inches at the beginning of each page description -- so that user space conforms to the conventions 
    * assumed by <em>DataNav</em> element viewports. No other scaling is allowed. Thus, it is assumed that coordinates 
    * and sizes are always expressed in thousandth-inches, and that a positive y-coord locates a point above the 
    * current origin.</p>
	 * 
	 * @param topLeft Bottom-left corner of the new viewport with respect to the current viewport. Any rotation will
    * occur about this point.
	 * @param w The width of the clipping rectangle in thousandth-inches. Ignored for non-clipping viewports.
	 * @param h The height of the clipping rectangle in thousandth-inches. Ignored for non-clipping viewports.
	 * @param rotDeg Orientation of the new viewport WRT the current viewport, in degrees. The rotation is performed 
	 * AFTER the translation to the specified bottom-left corner. Since user space is configured such that the y-axis 
    * increases upward, a positive angle yields a counter-clockwise rotation.
	 * @param doClip If <code>true</code>, a standard rectangular clipping viewport is established IAW the parameters 
	 * provided. If <code>false</code>, the non-clipping viewport is established instead. 
	 * @throws UnsupportedOperationException if the bottom-left corner is not well-defined or either dimension is less 
	 * than zero.
	 */
	public void setViewport( Point2D topLeft, double w, double h, double rotDeg, boolean doClip )
		throws UnsupportedOperationException
	{
		if( !Utilities.isWellDefined(topLeft) || w < 0 || h < 0 )
			throw new UnsupportedOperationException( "Ill-defined viewport" );
	
		includeFunctionInProlog( SETVIEWPORT );
		appendLine( Utilities.toString(h,7,3) + " " + Utilities.toString(w,7,3) + (doClip ? " true " : " false ") + 
			Utilities.toString(rotDeg,7,3) + " " + Utilities.toString(topLeft,7,3) + " " + SETVIEWPORT );
	}

   /**
    * To support clipping of data in polar graphs, this rather specialized method intersects the current clip region 
    * (which will always be a rectangle in <i>FypML</i> PS -- except when rendering data in a polar plot!) with the 
    * specified arc segment, which may lie anywhere along the full circle. When the segment is not a full circle, the
    * arc is connected to the origin to form a pie-shaped closed path. The clip region is permanently changed by this 
    * method. The current path is empty afterwards.
    * 
    * @param origin The polar origin, coordinates in thousandth-in WRT current viewport. If not well-defined, the 
    * method has no effect!
    * @param r Desired radius of arc, in milli-in. If <b>r &lt;= 0</b>, the method has no effect!
    * @param start Starting angle for arc, in degrees measured CCW from positive X-axis. Ignored for full-circle clip.
    * @param extent The arc extent in degrees. Strictly positive; 360 or greater for a full-circle clip.
    * @param isCW True to draw arc in CW direction from start angle; else CCW. Ignored for full-circle clip.
    */
   public void polarClip(Point2D origin, double r, double start, double extent, boolean isCW)
   {
      if((r <= 0) || (extent <= 0) || !Utilities.isWellDefined(origin)) return;

      String cmd = "newpath ";
      if(extent >= 360)
      {
         cmd += Utilities.toString(origin.getX()+r,7,3) + " " + Utilities.toString(origin.getY(),7,3) + " moveto ";
         cmd += Utilities.toString(origin,7,3) + " " + Utilities.toString(r,7,3) + " 0 360 arc closepath";
      }
      else
      {
         double s = isCW ? (start-extent) : start;
         double e = isCW ? start : (start+extent);
         cmd += Utilities.toString(origin,7,3) + " moveto ";
         cmd += Utilities.toString(origin,7,3) + " " + Utilities.toString(r,7,3) + " " +
            Utilities.toString(s,7,3) + " " + Utilities.toString(e,7,3) + " arc closepath";
      }
      cmd += " clip newpath";
      appendLine(cmd);
   }

   /** 
    * Transform the current user space by a translation followed by a rotation.
    * 
    * @param x Translation offset in X, in milli-inches.
    * @param y Translation offset in Y, in milli-inches.
    * @param rotDeg Desired rotation about the new origin, in degrees. Since user space is always configured such 
    * that the y-axis increases upward, a positive angle yields a counter-clockwise rotation.
    */
   public void translateAndRotate(double x, double y, double rotDeg)
   {
      StringBuilder sb = new StringBuilder();
      if(x != 0 || y != 0) 
         sb.append(Utilities.toString(x,7,3)).append(" ").append(Utilities.toString(y,7,3)).append(" translate ");
      if(rotDeg != 0) sb.append(Utilities.toString(rotDeg,7,3)).append(" rotate");
      if(sb.length() > 0 ) appendLine(sb.toString());
   }

   /** 
	 * Transform the current user space by a translation followed by a rotation.
	 * 
	 * @param move Location of new origin with respect to current user space; coords in thousandth-inches. If this 
	 * location is not well-defined, the transform is not performed.
	 * @param rotDeg Desired rotation about the new origin, in degrees. Since user space is always configured such 
	 * that the y-axis increases upward, a positive angle yields a counter-clockwise rotation.
	 */
	public void translateAndRotate(Point2D move, double rotDeg)
	{
		if(!Utilities.isWellDefined(move)) return;
		translateAndRotate(move.getX(), move.getY(), rotDeg);
	}

	/**
	 * This method allocates a Postscript array object referenced by the specified name and loads it with the specified 
	 * array of user space points {(x,y)}. Each element of the points array will be a 2-element array AR such that 
	 * x=AR[0] and y=AR[1]. 
	 * 
	 * <p>There is no limit placed on the size of the array. If repeated array loads occur, the virtual memory 
	 * available to the Postscript interpreter could be exhausted. Thus, it is a good idea to take a "save" snapshot 
	 * prior to allocating the array, then once done with its contents, call this method with the same name but a 
	 * <code>null</code> array and issue a "restore" to recover the virtual memory that the array object (which is no 
	 * longer accessible) had occupied.</p>
	 * 
	 * <p>If any point is not well defined, then it is still included in the points array, but the array element is set 
	 * to a <code>null</code> instead of a 2-element array. All procedures which will process the points array must be
	 * designed to deal with such ill-defined points appropriately.</p>
	 * 
	 * <p>The method uses two different strategies for loading the points. When the number of points is less than 200,
	 * it uses the simple definition "/ar [....] def". For larger array sizes, the array is allocated first, then it is 
	 * populated 20 points at a time using the "putInterval" command.</p>
	 * 
	 * @param name The name assigned to the Postscript array object allocated and loaded here.
	 * @param pts The (x,y) points to be loaded into array. If <code>null</code> or empty, the specified name is 
	 * defined as a Postscript "null" object.  
	 */
	private void loadArray(String name, Point2D[] pts)
	{
		final int BIGARRAY = 200;
		final int PTS_PER_PUT = 20;			// when using putInterval cmd to fill a big array

		// if points array is null or empty, just set name to the null object  
		if( pts == null || pts.length == 0 ) 
		{
			appendLine( "/" + name + " null def" );
			return;
		}

		// we prepare a sequence of commands in a string buffer, then dump the buffer when we're done
		StringBuilder loadBuf = new StringBuilder( 200 );
		
		if( pts.length < BIGARRAY )
		{
			// for short arrays, allocate and populate the points array object all at once:  "/ar [...] def.
			loadBuf.append("/").append(name).append(" [ ");
         for(Point2D pt : pts)
         {
            if(!Utilities.isWellDefined(pt))
               loadBuf.append("null ");
            else
               loadBuf.append("[").append(Utilities.toString(pt, 7, 3)).append("] ");
         }
			loadBuf.append( "] def" );

			appendLine( loadBuf.toString() );
		}
		else
		{
			// for longer arrays, allocate the points array before populating it: "/ar n array def"
			appendLine( "/" + name + " " + pts.length + " array def" );

			// now populate using a series of "ar index [...] putinterval" commands
			for( int i=0; i<pts.length; i+=PTS_PER_PUT )
			{
				loadBuf.delete(0,loadBuf.length());
				loadBuf.append(name).append(" ").append(i).append(" [ ");
				int j=0;
				while( i+j < pts.length && j < PTS_PER_PUT )
				{
					if(!Utilities.isWellDefined(pts[i+j]))
						loadBuf.append( "null " );
					else 
						loadBuf.append("[").append(Utilities.toString(pts[i + j], 7, 3)).append("] ");
					++j;
				}
				loadBuf.append( "] putinterval" );
				appendLine( loadBuf.toString() );
			}
		}
	}

   /**
    * This method allocates a Postscript array object referenced by the specified name and loads it with the specified 
    * array of double values {d}. If any value is not well-defined, it is represented in the Postscript array by the
    * "null" object.
    * 
    * <p>There is no limit placed on the size of the array. If repeated array loads occur, the virtual memory 
    * available to the Postscript interpreter could be exhausted. Thus, it is a good idea to take a "save" snapshot 
    * prior to allocating the array, then once done with its contents, call this method with the same name but a 
    * <code>null</code> array and issue a "restore" to recover the virtual memory that the array object (which is no 
    * longer accessible) had occupied.</p>
    * 
    * <p>The method uses two different strategies for loading the values. When the number of values is less than 200,
    * it uses the simple definition "/ar [....] def". For larger array sizes, the array is allocated first, then it is 
    * populated 40 values at a time using the "putInterval" command.</p>
    * 
    * @param name The name assigned to the Postscript array object allocated and loaded here.
    * @param vals The values to be loaded into array. If <code>null</code> or empty, the specified name is defined as 
    * a Postscript "null" object.  
    */
   private void loadArray( String name, double[] vals )
   {
      final int BIGARRAY = 200;
      final int VALS_PER_PUT = 40;        // when using putInterval to fill a big array

      // if values array is null or empty, just set name to the null object  
      if( vals == null || vals.length == 0 ) 
      {
         appendLine( "/" + name + " null def" );
         return;
      }

      // we prepare a sequence of commands in a string buffer, then dump the buffer when we're done
      StringBuilder loadBuf = new StringBuilder( 200 );

      if( vals.length < BIGARRAY )
      {
         // for short arrays, allocate and populate the double-valued array all at once:  "/ar [...] def
         loadBuf.append("/").append(name).append(" [ ");
         for(double val : vals)
            loadBuf.append(Utilities.isWellDefined(val) ? (Utilities.toString(val, 7, 3) + " ") : "null ");
         loadBuf.append( "] def" );

         appendLine( loadBuf.toString() );
      }
      else
      {
         // for longer arrays, allocate the double-valued array before populating it: "/ar n array def"
         appendLine( "/" + name + " " + vals.length + " array def" );

         // now populate using "ar index [...] putinterval"
         for( int i=0; i<vals.length; i+=VALS_PER_PUT )
         {
            loadBuf.delete(0,loadBuf.length());
            loadBuf.append(name).append(" ").append(i).append(" [ ");
            int j=0;
            while( i+j < vals.length && j < VALS_PER_PUT )
            {
               loadBuf.append(Utilities.isWellDefined(vals[i+j]) ? (Utilities.toString(vals[i+j],7,3) + " ") : "null ");
               ++j;
            }
            loadBuf.append( "] putinterval" );
            appendLine( loadBuf.toString() );
         }
      }
   }

   /**
    * This method allocates a Postscript array object referenced by the specified name and loads it with the specified 
    * array of integer values.
    * 
    * <p>There is no limit placed on the size of the array. If repeated array loads occur, the virtual memory 
    * available to the Postscript interpreter could be exhausted. Thus, it is a good idea to take a "save" snapshot 
    * prior to allocating the array, then once done with its contents, call this method with the same name but a null
    * array and issue a "restore" to recover the virtual memory that the array object (which is no longer accessible) 
    * had occupied.</p>
    * 
    * <p>The method uses two different strategies for loading the values. When the number of values is less than 200,
    * it uses the simple definition "/ar [....] def". For larger array sizes, the array is allocated first, then it is 
    * populated 40 values at a time using the "putInterval" command.</p>
    * 
    * @param name The name assigned to the Postscript array object allocated and loaded here.
    * @param vals The values to be loaded into array. If null or empty, the specified name is defined as a Postscript 
    * "null" object (for recovering virtual memory previously allocated to the named array).  
    */
   private void loadArray( String name, int[] vals )
   {
      final int BIGARRAY = 200;
      final int VALS_PER_PUT = 40;        // when using putInterval to fill a big array

      // if values array is null or empty, just set name to the null object  
      if( vals == null || vals.length == 0 ) 
      {
         appendLine( "/" + name + " null def" );
         return;
      }

      // we prepare a sequence of commands in a string buffer, then dump the buffer when we're done
      StringBuilder loadBuf = new StringBuilder( 200 );

      if( vals.length < BIGARRAY )
      {
         // for short arrays, allocate and populate the double-valued array all at once:  "/ar [...] def
         loadBuf.append("/").append(name).append(" [ ");
         for(int val : vals) loadBuf.append(val).append(" ");
         loadBuf.append( "] def" );

         appendLine( loadBuf.toString() );
      }
      else
      {
         // for longer arrays, allocate the double-valued array before populating it: "/ar n array def"
         appendLine( "/" + name + " " + vals.length + " array def" );

         // now populate using "ar index [...] putinterval"
         for( int i=0; i<vals.length; i+=VALS_PER_PUT )
         {
            loadBuf.delete(0,loadBuf.length());
            loadBuf.append(name).append(" ").append(i).append(" [ ");
            int j=0;
            while( i+j < vals.length && j < VALS_PER_PUT )
            {
               loadBuf.append(vals[i + j]).append(" ");
               ++j;
            }
            loadBuf.append( "] putinterval" );
            appendLine( loadBuf.toString() );
         }
      }
   }

	/**
    * This method allocates a Postscript array object referenced by the specified name and loads it with the specified 
    * list of strings.
    * 
    * <p>There is no limit placed on the size of the array. If repeated array loads occur, the virtual memory available 
    * to the Postscript interpreter could be exhausted. Thus, it is a good idea to take a "save" snapshot prior to 
    * allocating the array, then once done with its contents, call this method with the same name but a null list and 
    * issue a "restore" to recover the virtual memory that the array object (which is no longer accessible) had 
    * occupied.</p>
    * 
    * @param name The name assigned to the Postscript array object allocated and loaded here.
    * @param tokens The string tokens to be loaded into array. If null or empty, the specified name is defined as a 
    * Postscript "null" object.
    * @param asStringLiterals If true, each string token is wrapped in parentheses so that they are treated as string 
    * literals by the Postscript interpreter.
	 */
	private void loadArray(String name, List<String> tokens, boolean asStringLiterals)
	{
	   // if tokens array is null or empty, just set name to the null object  
      if(tokens == null || tokens.isEmpty()) 
      {
         appendLine( "/" + name + " null def" );
         return;
      }

      // allocate the string array before populating it: "/ar n array def"
      appendLine( "/" + name + " " + tokens.size() + " array def" );

      // now populate using "ar index [...] putinterval"
      String pre = asStringLiterals ? "(" : "";
      String post = asStringLiterals ? ") " : " ";
      StringBuilder buf = new StringBuilder();
      for(int i=0; i<tokens.size(); i+=20)
      {
         buf.setLength(0);
         buf.append(name).append(" ").append(i).append(" [ ");
         int j=0;
         while(i+j < tokens.size() && j < 20)
         {
            buf.append(pre).append(tokens.get(i + j)).append(post);
            ++j;
         }
         buf.append( "] putinterval" );
         appendLine(buf.toString());
      }
	}
	
   /**
    * This method allocates a Postscript array object referenced by the specified name and loads it with an array
    * containing arrays of string tokens. The string tokens are NOT wrapped in parentheses, so they are NOT treated
    * as string literals (unless the string token itself has the form "(...)") by the Postscript interpreter. The outer
    * array may contain null tokens, which are represented by the Postscript null object.
    * 
    * <p>There is no limit placed on the size of the array. If repeated array loads occur, the virtual memory available 
    * to the Postscript interpreter could be exhausted. Thus, it is a good idea to take a "save" snapshot prior to 
    * allocating the array, then once done with its contents, call this method with the same name but a null list and 
    * issue a "restore" to recover the virtual memory that the array object (which is no longer accessible) had 
    * occupied.</p>
    * 
    * @param name The name assigned to the Postscript array object allocated and loaded here.
    * @param arrayTokens List of string token lists to be loaded into array. If null or empty, the specified name is 
    * defined as a Postscript "null" object.
    */
	private void loadArray(String name, List<List<String>> arrayTokens)
	{
      // if tokens array is null or empty, just set name to the null object  
      if(arrayTokens == null || arrayTokens.isEmpty()) 
      {
         appendLine( "/" + name + " null def" );
         return;
      }

      // allocate the string array before populating it: "/ar n array def"
      appendLine( "/" + name + " " + arrayTokens.size() + " array def" );

      // now populate using "ar index [...] putinterval"
      StringBuilder buf = new StringBuilder();
      buf.append(name).append(" ").append(0).append(" [ ");
      int i = 0;
      while(true)
      {
         List<String> arrToken = arrayTokens.get(i);
         if(arrToken == null)
             buf.append("null ");
         else
         {
            buf.append("[");
            for(String s:arrToken)
               buf.append(s).append(" ");
            buf.append("] ");           
         }

         ++i;
         if((i == arrayTokens.size()) || (buf.length() > 120))
         {
            buf.append("] putinterval");
            appendLine(buf.toString());
            if(i == arrayTokens.size())
               break;
            buf.setLength(0);
            buf.append(name).append(" ").append(i).append(" [ ");
         }
      }
	}
	
   /**
    * This method allocates a Postscript array object referenced by the specified name and loads it with the specified 
    * list of opaque RGB colors. Each element of the colors array will be a 3-element array AR such that AR[0] = R,
    * AR[1] = G, and AR[2] = B. The color components R, G, B all lie in [0..1]. 
    * 
    * <p>There is no limit placed on the size of the array. If repeated array loads occur, the virtual memory 
    * available to the Postscript interpreter could be exhausted. Thus, it is a good idea to take a "save" snapshot 
    * prior to allocating the array, then once done with its contents, call this method with the same name but a null
    * list and issue a "restore" to recover the virtual memory that the array object (which is no longer accessible) had
    * occupied.</p>
    * 
    * <p>Any null color value in the list is treated as black, and alpha components are ignored.</p>
    * 
    * <p>The method uses two different strategies for loading the RGB triplets. When the number of triplets is less than
    * 150, it uses the simple definition "/ar [....] def". For larger array sizes, the array is allocated first, then it
    * is populated 20 elements at a time using the "putInterval" command.</p>
    * 
    * @param name The name assigned to the Postscript array object allocated and loaded here.
    * @param rgb The list of RGB colors to be loaded into the array. If null or empty, the specified name is defined as 
    * a Postscript "null" object. <i><b>NOTE:</b> The alpha component of each {@link Color} object is ignored -- each
    * is assumed to be an opaque color. Postscript does not support translucent color.</i>
    */
   private void loadColorArray(String name, List<Color> rgb)
   {
      final int BIGARRAY = 150;
      final int PTS_PER_PUT = 20;         // when using putInterval cmd to fill a big array

      // if color list is null or empty, just set name to the null object  
      if(rgb == null || rgb.isEmpty())
      {
         appendLine( "/" + name + " null def" );
         return;
      }

      // we prepare a sequence of commands in a string buffer, then dump the buffer when we're done
      StringBuilder loadBuf = new StringBuilder( 200 );
      
      if(rgb.size() < BIGARRAY)
      {
         // for short arrays, allocate and populate the points array object all at once:  "/ar [...] def.
         loadBuf.append("/").append(name).append(" [ ");
         for(Color c : rgb)
         {
            if(c == null) loadBuf.append("[0 0 0] ");
            else
            {
               loadBuf.append("[").append(Utilities.toString(((double) c.getRed()) / 255.0, 7, 3));
               loadBuf.append(" ").append(Utilities.toString(((double) c.getGreen()) / 255.0, 7, 3));
               loadBuf.append(" ").append(Utilities.toString(((double) c.getBlue()) / 255.0, 7, 3)).append("] ");
            }
         }
         loadBuf.append( "] def" );

         appendLine(loadBuf.toString());
      }
      else
      {
         // for longer arrays, allocate the colors array before populating it: "/ar n array def"
         appendLine( "/" + name + " " + rgb.size() + " array def" );

         // now populate using a series of "ar index [...] putinterval" commands
         for(int i=0; i<rgb.size(); i+=PTS_PER_PUT)
         {
            loadBuf.delete(0,loadBuf.length());
            loadBuf.append(name).append(" ").append(i).append(" [ ");
            int j=0;
            while(i+j < rgb.size() && j < PTS_PER_PUT)
            {
               Color c = rgb.get(i+j);
               if(c == null) loadBuf.append("[0 0 0] ");
               else
               {
                  loadBuf.append("[").append(Utilities.toString(((double) c.getRed()) / 255.0, 7, 3));
                  loadBuf.append(" ").append(Utilities.toString(((double) c.getGreen()) / 255.0, 7, 3));
                  loadBuf.append(" ").append(Utilities.toString(((double) c.getBlue()) / 255.0, 7, 3)).append("] ");
               }
               ++j;
            }
            loadBuf.append( "] putinterval" );
            appendLine(loadBuf.toString());
         }
      }
   }

	/**
	 * The maximum length of any line in the Postscript output. This must be less than or equal to 255, IAW Adobe's 
	 * Document Structuring Conventions.
	 */
	private final static int MAX_LINELENGTH = 250;
	
	/**
	 * The maximum number of indent levels that are visibly reflected by the whitespace string used to indent a line in 
	 * the Postscript output.  Since line length is restricted, the whitespace indent is restricted so that any given 
	 * line is not consumed by it.  The actual indent level is NOT restricted.
	 */
	private final static int MAX_VIS_INDENTS = 10;

	/** The largest whitespace indent string, containing <code>2*MAX_VIS_INDENTS</code space characters. */
	private final static String INDENTSPACE = "                    ";

	/**
	 * Append the specified string as a new line in the main program body.
	 * 
	 * <p>The string is prepended with whitespace IAW the current indent level, with two spaces per indent level. 
	 * However, if the indent level exceeds <code>PSDoc.MAX_VIS_INDENTS</code>, no further indenting is performed. If 
    * the indented line exceeds <code>PSDoc.MAX_LINELENGTH</code>, it is broken up into two or more lines -- to satisfy 
    * the line-length restriction of Adobe's Document Structuring Conventions. Lines are always broken at a whitespace 
    * character in an attempt to ensure that the result is readable by the Postscript interpreter.</p>
	 * 
	 * @param contents The string to be appended to the program buffer.
	 */
	private void appendLine( String contents )
	{
		String indentStr = INDENTSPACE.substring( 0, 2*Math.min(currentIndent,MAX_VIS_INDENTS) );
		String line = indentStr + contents;
		
		boolean isComment = contents.startsWith("% ");
		
		while( line.length() > MAX_LINELENGTH )
		{
			int last = line.length();
			while( last > MAX_LINELENGTH ) last = line.lastIndexOf( ' ', last-1 );

			// this is VERY UNLIKELY to happen!
			if( last <= indentStr.length() - 1 )
				throw new UnsupportedOperationException( "Unable to break line to satisfy line length restriction" );

			String piece = line.substring(0,last);
			mainBuf.append(piece).append(NEWLINE);

			// if the string to be appended is a comment, then we have to pre-pend "% " before each extra line!
			line = indentStr + (isComment ? "% " : "") + line.substring(last + 1);
		}
		if(!line.isEmpty())
			mainBuf.append(line).append(NEWLINE);
	}

	/**
	 * Update the current graphics state to reflect the parameters of the specified Postscript-transformable object.
	 * 
	 * @param psObj A Postscript-transformable object. The method queries the object for graphics state information.
	 */
	private void updateCurrentGraphicsState(PSTransformable psObj)
	{
		String cmd = "";
		String s = currentGraphics.changeFont(psObj.getPSFontFace(), psObj.getPSFontSize());
		if(!s.isEmpty()) cmd += s + " ";
		s = currentGraphics.changeStrokeProperties(psObj.getPSStrokeWidth(), psObj.getPSStrokeEndcap(), 
		      psObj.getPSStrokeJoin(), psObj.getPSStrokeDashPattern(), psObj.getPSStrokeDashOffset());
		if(!s.isEmpty()) cmd += s + " ";
		s = currentGraphics.changeColors(psObj.getPSStrokeColor(), !psObj.isPSNoStroke(), 
		      psObj.getPSTextAndFillColor(), !psObj.isPSNoFill());
		if(!s.isEmpty()) cmd += s;
		if(!cmd.isEmpty()) appendLine( cmd );
	}

	/**
	 * Does the specified RGB color represent a shade of gray (ie, R==G==B)?
	 * 
	 * @param rgb The color as a packed RGB integer (0x00RRGGBB).
	 * @return <code>True</code> iff the color is a shade of gray.
	 */
	private static boolean isGray( int rgb )
	{
		int r = (rgb & 0x00FF0000) >> 16;
		int g = (rgb & 0x0000FF00) >> 8;
		int b = (rgb & 0x000000FF);
		return( (r==g) && (g==b) );
	}

	/** A shortcut for {@link #getRGBColorString(int, boolean)} with second argument set to <i>false</i>. */
	private static String getRGBColorString(int rgb) { return(getRGBColorString(rgb, false)); }

   /**
    * Convert the packed RGB color to its unpacked string form "r g b", where each color component is specified as a 
    * number in [0..1]. If the color is a grayscale value, then a string containing the grayscale value in [0..1] is 
    * returned.
    *  
    * @param rgb The color as a packed RGB integer (0x00RRGGBB).
    * @param force If true, the "r g b" string representation is returned always, even if the color is grayscale.
    * @return Unpacked string representation, "r g b" or "grey", where each component is a number in [0..1]. This is 
    * the format expected for operands to the Postscript "setgray" and "setrgbcolor" commands.
    */
	private static String getRGBColorString(int rgb, boolean force)
	{
	   String r = Utilities.toString(((double) ((rgb & 0x00FF0000) >> 16)) / 255.0, 7, 3);
	   if((!force) && isGray(rgb)) 
	      return(r);
	   else
      {
         String g = Utilities.toString( ((double) ((rgb & 0x0000FF00) >> 8)) / 255.0, 7, 3 );
         String b = Utilities.toString( ((double) (rgb & 0x000000FF)) / 255.0, 7, 3 );
         return(r + " " + g + " " + b);
      }
	}
	
	//
	// Postscript font and character set support
	//

	/** Subset of 16-bit Unicode characters that we map into the Postscript <em>StandardEncoding</em> vector. */
	private static final UnicodeSubset STANDARDENCODING = new UnicodeSubset("STD", 
		"\u0009\u0009\n\n\r\r\u0020\u007E\u0152\u0153\u0192\u0192\u2013\u2014\u2018\u201A" +
		"\u201C\u201E\u2020\u2022\u2026\u2026\u2030\u2030\u2039\u203A\u2044\u2044");

	/** Subset of 16-bit Unicode characters that we map into the Postscript <em>ISOLatin1Encoding</em> vector. */
	private static final UnicodeSubset ISOLATIN1ENCODING = new UnicodeSubset("ISO", "\u00A1\u00FF");

	/** Subset of 16-bit Unicode characters that we map to the Postscript <em>Symbol</em> font.
	 */
	private static final UnicodeSubset SYMBOLENCODING = new UnicodeSubset("SYM", 
		"\u0391\u03A1\u03A3\u03A9\u03B1\u03C9\u03D1\u03D1\u03D5\u03D6\u2032\u2033\u20AC\u20AC\u2111\u2111\u2118\u2118" +
		"\u211C\u211C\u2122\u2122\u2135\u2135\u2190\u2194\u21B5\u21B5\u21D0\u21D4\u2200\u2200\u2202\u2203\u2205\u2205" +
		"\u2207\u2209\u220B\u220B\u220F\u220F\u2211\u2211\u221A\u221A\u221D\u221E\u2220\u2220\u2227\u222B\u2245\u2245" +
		"\u2248\u2248\u2260\u2261\u2264\u2265\u2282\u2284\u2286\u2287\u2295\u2295\u2297\u2297\u22A5\u22A5\u2320\u2321" +
		"\u25CA\u25CA\u2660\u2660\u2663\u2663\u2665\u2666");

	private static final String STD_NONASCII_UNICODE = 
		"\u0152\u0153\u0192\u2013\u2014\u2018\u2019\u201A\u201C\u201D\u201E\u2020\u2021\u2022\u2026" +
		"\u2030\u2039\u203A\u2044";
	private static final String STD_NONASCII_PS =
		"\u00EA\u00FA\u00A6\u00B1\u00D0\u0060\u0027\u00B8\u00AA\u00BA\u00B9\u00B2\u00B3\u00B7\u00BC" +
		"\u00BD\u00AC\u00AD\u00A4";
	private static final String SYMBOL_UNICODE =
		"\u0391\u0392\u0393\u0394\u0395\u0396\u0397\u0398\u0399\u039A\u039B\u039C\u039D\u039E\u039F\u03A0\u03A1\u03A3" +
		"\u03A4\u03A5\u03A6\u03A7\u03A8\u03A9\u03B1\u03B2\u03B3\u03B4\u03B5\u03B6\u03B7\u03B8\u03B9\u03BA\u03BB\u03BC" +
		"\u03BD\u03BE\u03BF\u03C0\u03C1\u03C2\u03C3\u03C4\u03C5\u03C6\u03C7\u03C8\u03C9\u03D1\u03D5\u03D6\u2032\u2033" +
		"\u20AC\u2111\u2118\u211C\u2122\u2135\u2190\u2191\u2192\u2193\u2194\u21B5\u21D0\u21D1\u21D2\u21D3\u21D4\u2200" +
		"\u2202\u2203\u2205\u2207\u2208\u2209\u220B\u220F\u2211\u221A\u221D\u221E\u2220\u2227\u2228\u2229\u222A\u222B" +
		"\u2245\u2248\u2260\u2261\u2264\u2265\u2282\u2283\u2284\u2286\u2287\u2295\u2297\u22A5\u2320\u2321\u25CA\u2660" +
		"\u2663\u2665\u2666";
	private static final String SYMBOL_PS =
		"\u0041\u0042\u0047\u0044\u0045\u005A\u0048\u0051\u0049\u004B\u004C\u004D\u004E\u0058\u004F\u0050\u0052\u0053" +
		"\u0054\u0055\u0046\u0043\u0059\u0057\u0061\u0062\u0067\u0064\u0065\u007A\u0068\u0071\u0069\u006B\u006C\u006D" +
		"\u006E\u0078\u006F\u0070\u0072\u0056\u0073\u0074\u0075\u0066\u0063\u0079\u0077\u004A\u006A\u0076\u00A2\u00B2" +
		"\u00A0\u00C1\u00C3\u00C2\u00D4\u00C0\u00AC\u00AD\u00AE\u00AF\u00AB\u00BF\u00DC\u00DD\u00DE\u00DF\u00DB" + "\"" +
		"\u00B6\u0024\u00C6\u00D1\u00CE\u00CF\u0027\u00D5\u00E5\u00D6\u00B5\u00A5\u00D0\u00D9\u00DA\u00C7\u00C8\u00F2" +
		"\u0040\u00BB\u00B9\u00BA\u00A3\u00B3\u00CC\u00C9\u00CB\u00CD\u00CA\u00C5\u00C4\u005E\u00F3\u00F5\u00E0\u00AA" +
		"\u00A7\u00A9\u00A8";

	/**
	 * Helper method which takes a 16-bit Unicode character and maps it to the pair <em>(encoding, psChar)</em>, where 
    * <em>encoding</em> is 0 for the Postscript <em>StandardEncoding</em> vector, 1 for the <em>ISOLatin1Encoding</em> 
    * vector, and 2 for a character in the Postscript Symbol character set (custom encoding). If the Unicode character 
    * is not supported by any of these common Postscript encodings, then the encoding is set to -1 (character will be 
    * skipped). Else, the Unicode character is mapped to the specific Postscript character code, <em>psChar</em>, 
    * within that encoding.
	 * 
	 * @param c Unicode character to be mapped to a Postscript character in one of 3 supported encoding vectors.
	 * @param psCode This integer array stores the mapped encoding ID (-1, 0, 1, or 2) at index 0 and the Postscript 
	 * character code (which is restricted to [0x00..0xFF]) at index 1.
	 * @param replaceLF If true, the linefeed character (0x000A) is replaced by a space character (0x0020); if false,
	 * it is unchanged. Tab (0x0009) and carriage return (0x000D) characters are always replaced by a space.
	 */
	public static void mapUnicodeCharToPS(char c, int[] psCode, boolean replaceLF)
	{
		psCode[0] = -1;
		psCode[1] = 0;
		if(STANDARDENCODING.contains(c)) 
		{
			psCode[0] = 0;
			if( c <= 0x007E )
			{
				// 7-bit ASCII maps directly, except that tab, linefeed and carriage return are replaced by space char, 
				// and the grave characters do not map directly. The linefeed is left unchanged, if requested.
				psCode[1] = c;
				if( c == 0x0060 ) psCode[1] = 0x00C1;
				else if( c == 0x0009 || (replaceLF && (c == 0x000A)) || c == 0x000D ) psCode[1] = 0x0020;
			}
			else
			{
				int i = STD_NONASCII_UNICODE.indexOf(c);
				if( i >= 0 ) psCode[1] = STD_NONASCII_PS.charAt(i);
			}
		} 
		else if(ISOLATIN1ENCODING.contains(c)) 
		{
			// ISOLatin1Encoding is used for the contiguous Unicode range 0x00A1-0x007F, and the char codes map directly
			psCode[0] = 1;
			psCode[1] = c;
		} 
		else if(SYMBOLENCODING.contains(c)) 
		{
			psCode[0] = 2;
			int i = SYMBOL_UNICODE.indexOf(c);
			if( i >= 0 ) psCode[1] = SYMBOL_PS.charAt(i);
		} 
	}

	/**
	 * <code>PSDoc</code> uses a composite font to render text which may contain characters from the built-in 
    * <em>StandardEncoding</em> or <em>ISOLatin1Encoding</em> vectors of a selected Latin text font, plus characters 
    * from the standard Postscript <em>Symbol</em> font (which uses a different character encoding). The composite font 
    * is a collection of three actual font dictionaries: a selected Latin font using <em>StandardEncoding</em>, that 
    * same font using <em>ISOLatin1Encoding</em>, and the <em>Symbol</em> font.  The composite font's <em>FMapType</em> 
    * is 3, which means that the Postscript character sequence (in octal format) "\esc\nnn" is inserted into a string 
    * to set which subfont should be used to render subsequent characters in the string. By convention, we use the octal
    * code \177 as the escape character \esc -- since this does not map to a usable character in any of the supported 
    * encodings. Also, the font number \nnn will be \000 for the Latin font using the <em>StandardEncoding</em> vector, 
    * \001 for that same font using the <em>ISOLatin1Encoding</em> vector, and \002 for the <em>Symbol</em> font using 
    * its own custom encoding vector.
	 * 
	 * <p>Furthermore, while Unicode characters are 16-bit, Postscript characters are 8-bit. Each supported Unicode 
	 * character must be mapped to the pair <em>(subfont, psChar)</em>, where <em>subfont</em> indicates which of the 
    * three base fonts/encodings in the composite font should be used to render the character, and <em>psChar</em> is 
    * the Postscript character code (8-bit) within the selected encoding that represents the Unicode character.</p>
	 * 
	 * <p>This helper method handles the task of translating any string of 16-bit Unicode characters to a Postscript 
	 * string with escape sequences inserted whenever it is necessary to change which encoding is used to render 
	 * subsequent character(s) in the string. The string returned by this method is in the proper form for direct 
	 * inclusion (as a literal string between parentheses) into the output stream generated by <code>PSDoc</code>.</p>
	 * 
	 * <p>Any left or right parenthesis in the text string is replaced by its escaped forms -- \050 and \051. This is
	 * because parentheses are used to delimit the string token!</p>
	 * 
	 * @param text The 16-bit Unicode string to be translated.
	 * @return The same string converted so that it can be rendered directly by the Postscript <code>show</code> 
	 * method using the composite font described. Any linefeed, tab, or carriage return character in the original string
	 * is replaced by a space character.
	 */
	private static String unicodeToPostscriptText(String text)
	{
	   return unicodeToPostscriptText(text, true);
	}
	
	/**
	 * See {@link #unicodeToPostscriptText(String)}. This version controls whether or not each linefeed character in
	 * the original text is replaced by a space character.
	 * 
	 * @param text The 16-bit Unicode string to be translated.
	 * @param replaceLF True to replace linefeeds with spaces, false to leave them as is.
	 */
	private static String unicodeToPostscriptText(String text, boolean replaceLF)
	{
		if( text == null || text.isEmpty()) return( "" );

		int currSubFont = 0;
		int[] psCode = new int[2];											// index0 = subfont, index1 = PS char code
		StringBuilder buf = new StringBuilder( text.length() );
		for( int i=0; i<text.length(); i++ )
		{
			// get next character in input string, map it to one of the three subfonts/encodings, and get the PS 
			// char code in that encoding 
			mapUnicodeCharToPS( text.charAt(i), psCode, replaceLF);

			// if the character is not supported, we skip over it
			if( psCode[0] == -1 ) continue;

			// if the subfont has changed, append the necessary escape sequence IAW rules for FMapType=3 composite font
			if( psCode[0] != currSubFont )
			{
				buf.append("\\177\\00").append(psCode[0]);
				currSubFont = psCode[0];
			}

			// append the PS character.  if the character code > 0x7F (7-bit ASCII), then we must escape it as "\nnn", 
			// where nnn is the character code's octal value. The same goes for the left/right parenthese, which are used
			// to delimit string tokens in PS, and the backslash '\', which starts an escape sequence!
			if(psCode[1] <= 0x007F && psCode[1] != 0x0028 && psCode[1] != 0x0029 && psCode[1] != 0x005C)
			{
				buf.append( (char) psCode[1] );
				// required by jdk1.5.0
				// try {buf.append( (char) psCode[1] );} catch( IOException ioe ) {}
			}
			else
			{
				String octal = Integer.toOctalString( psCode[1] );
				buf.append("\\000", 0, 4 - octal.length()).append(octal);
			}
		}

		return( buf.toString() );
	}
	/**
	 * A map of all Latin font faces in the standard set of 35 fonts typically supported in PS 2 products.  The map is 
	 * keyed by the font families enumerated by <code>PSFont</code>. Associated with each key is a 4-member string array 
    * containing the exact Postscript font names for the plain, italic, bold, and bolditalic (in that order!) typefaces 
    * in the font family identified by the key.
	 */
	private static final Map<PSFont, String[]> stdFonts;
	
	private static final Map<PSFont, String> stdFontToInstalledFontFamily;
	static 
	{
		stdFonts = new HashMap<>();
		stdFonts.put(PSFont.AVANTGARDE, 
			new String[] {"AvantGarde-Book", "AvantGarde-BookOblique", "AvantGarde-Demi", "AvantGarde-DemiOblique"});
		stdFonts.put(PSFont.BOOKMAN, 
			new String[] {"Bookman-Light", "Bookman-LightItalic", "Bookman-Demi", "Bookman-DemiItalic"});
		stdFonts.put(PSFont.COURIER, 
			new String[] {"Courier", "Courier-Oblique", "Courier-Bold", "Courier-BoldOblique"});
		stdFonts.put(PSFont.HELVETICA, 
			new String[] {"Helvetica", "Helvetica-Oblique", "Helvetica-Bold", "Helvetica-BoldOblique"});
		stdFonts.put(PSFont.HELVNARROW, new String[] {"Helvetica-Narrow", "Helvetica-Narrow-Oblique", 
			"Helvetica-Narrow-Bold", "Helvetica-Narrow-BoldOblique"});
		stdFonts.put(PSFont.NCSCHOOLBOOK, new String[] {"NewCenturySchlbk-Roman", "NewCenturySchlbk-Italic", 
			"NewCenturySchlbk-Bold", "NewCenturySchlbk-BoldItalic"} );
		stdFonts.put(PSFont.PALATINO, 
			new String[] {"Palatino-Roman", "Palatino-Italic", "Palatino-Bold", "Palatino-BoldItalic"});
		stdFonts.put(PSFont.TIMES, 
			new String[] {"Times-Roman", "Times-Italic", "Times-Bold", "Times-BoldItalic"});
		
		stdFontToInstalledFontFamily = new HashMap<>();
		String[] alts = new String[] {"Avant Garde", "Avant Garde Gothic", "Century Gothic"};
		String fam = null;
		for(String alt : alts) if(LocalFontEnvironment.isFontInstalled(alt)) {fam = alt; break;}
		stdFontToInstalledFontFamily.put(PSFont.AVANTGARDE, fam==null ? LocalFontEnvironment.getSansSerifFont() : fam);

      alts = new String[] {"Bookman", "ITC Bookman", "Bookman Old Style"};
      fam = null;
      for(String alt : alts) if(LocalFontEnvironment.isFontInstalled(alt)) {fam = alt; break;}
      stdFontToInstalledFontFamily.put(PSFont.BOOKMAN, fam==null ? LocalFontEnvironment.getSerifFont() : fam);

      alts = new String[] {"Courier", "Courier New"};
      fam = null;
      for(String alt : alts) if(LocalFontEnvironment.isFontInstalled(alt)) {fam = alt; break;}
      stdFontToInstalledFontFamily.put(PSFont.COURIER, fam==null ? LocalFontEnvironment.getMonospaceFont() : fam);

      alts = new String[] {"Helvetica", "Helvetica Neue", "Arial"};
      fam = null;
      for(String alt : alts) if(LocalFontEnvironment.isFontInstalled(alt)) {fam = alt; break;}
      stdFontToInstalledFontFamily.put(PSFont.HELVETICA, fam==null ? LocalFontEnvironment.getSansSerifFont() : fam);

      alts = new String[] {"Helvetica Narrow", "Helvetica Condensed", "Arial Narrow"};
      fam = null;
      for(String alt : alts) if(LocalFontEnvironment.isFontInstalled(alt)) {fam = alt; break;}
      stdFontToInstalledFontFamily.put(PSFont.HELVNARROW, fam==null ? LocalFontEnvironment.getSansSerifFont() : fam);

      alts = new String[] {"New Century Schoolbook", "Century Schoolbook"};
      fam = null;
      for(String alt : alts) if(LocalFontEnvironment.isFontInstalled(alt)) {fam = alt; break;}
      stdFontToInstalledFontFamily.put(PSFont.NCSCHOOLBOOK, fam==null ? LocalFontEnvironment.getSerifFont() : fam);
      
      alts = new String[] {"Palatino", "Optima"};
      fam = null;
      for(String alt : alts) if(LocalFontEnvironment.isFontInstalled(alt)) {fam = alt; break;}
      stdFontToInstalledFontFamily.put(PSFont.PALATINO, fam==null ? LocalFontEnvironment.getSerifFont() : fam);
      
      alts = new String[] {"Times", "Times New Roman", "STIX"};
      fam = null;
      for(String alt : alts) if(LocalFontEnvironment.isFontInstalled(alt)) {fam = alt; break;}
      stdFontToInstalledFontFamily.put(PSFont.TIMES, fam==null ? LocalFontEnvironment.getSerifFont() : fam);
	}


	/**
	 * Return the Postscript font name (as it appears in a PS language program) corresponding to the specified font 
	 * family and style.
	 * 
	 * @param family The font family. If <code>null</code>, the <code>PSFont.TIMES</code> is assumed.
	 * @param isBold <code>True</code> to request bold styling.
	 * @param isItalic <code>True</code> to request italic styling. Can be combined with bold styling.
	 * @return Postscript font face name as it appears in a PS language program.
	 */
	public static String getStandardFontFace(PSFont family, boolean isBold, boolean isItalic)
	{
		Object value = stdFonts.get((family == null) ? PSFont.TIMES : family);
		String[] variants = (String[]) value;
		return( variants[(isItalic ? 1 : 0) + (isBold ? 2 : 0)] );
	}

	/**
	 * Get installed font family similar to the specified Postscript standard font.
	 * @param psFont A Postscript font. If null, {@link PSFont#TIMES} is assumed.
	 * @return An installed font family similar to the PS font specified. At the very least, the returned font should
	 * match the generic type - serif, sans-serif, or monospaced.
	 */
	public static String getInstalledFontSimilarTo(PSFont psFont)
	{
	   return stdFontToInstalledFontFamily.get(psFont==null ? PSFont.TIMES : psFont);
	}
	
	/**
	 * Is the specified Postscript font face recognized by this class? Only the 32 Latin font faces that are part of 
	 * the Postscript "Standard 35" font set (PS Level 2) are supported by <code>PSDoc</code>. This method is not 
    * particularly optimized for speed, so use sparingly.
	 * 
	 * @param faceName The Postscript font face name to be checked.
	 * @return <code>True</code> if argument is one of the 32 Latin font faces recognized by <code>PSDoc</code>.
	 */
	public static boolean isRecognizedFontFace(String faceName)
	{
      for(String[] faces : stdFonts.values())
      {
         for(String face : faces) if(faceName.equals(face)) return (true);
      }
		return(false);
	}

	/**
	 * Is the specified Postscript font face a variant of the three most widely supported Postscript font families, ie,
	 * a member of the Postscript "Standard 13" Level 1 font set?.
	 * 
	 * @param faceName The Postscript font face name to be checked.
	 * @return <code>True</code> if the typeface is member of the <em>Times</em>, <em>Helvetica</em>, or <em>Courier</em>
    * font family. 
	 */
	private static boolean isBasicFont(String faceName)
	{
		return(faceName.contains(PSFont.TIMES.toString()) || faceName.contains(PSFont.COURIER.toString()) ||
			(faceName.contains(PSFont.HELVETICA.toString()) && !faceName.contains(PSFont.HELVNARROW.toString())));
	}

	/**
	 * Get the generic PSFont corresponding to the standard Postscript font face.
	 * 
	 * @param faceName The Postscript font face name.
	 * @return The corresponding Postscript standard font, or null if not a recognized face name.
	 */
	private static PSFont getBasePSFont(String faceName)
	{
      for(PSFont psFont : stdFonts.keySet())
      {
         if(Arrays.asList(stdFonts.get(psFont)).contains(faceName))
            return psFont;
      }
	   return null;
	}

	/**
	 * Does the specified Postscript font face represent a bold font style?
	 * @param psFont The Postscript standard font to which font face belongs.
	 * @param faceName The font face name.
	 * @return True if font face is bold or bolditalic style.
	 */
	private static boolean isBold(PSFont psFont, String faceName)
	{
	   String[] faces = stdFonts.get(psFont);
	   return(faces != null && (faces[2].equals(faceName) || faces[3].equals(faceName)));
	}
	
   /**
    * Does the specified Postscript font face represent an italic font style?
    * @param psFont The Postscript standard font to which font face belongs.
    * @param faceName The font face name.
    * @return True if font face is italic or bolditalic style.
    */
   private static boolean isItalic(PSFont psFont, String faceName)
   {
      String[] faces = stdFonts.get(psFont);
      return(faces != null && (faces[1].equals(faceName) || faces[3].equals(faceName)));
   }
   
	/**
	 * Print the completed <code>PSDoc</code> to the specified file. 
	 * 
	 * <p>The document prolog is dumped to the file first, followed by the main body of the program. The output is 
	 * streamed to the file as characters using the standard "US-ASCII" character encoding. The internal state of 
	 * the <code>PSDoc</code> is unchanged, so this method can be called any number of times.</p>
	 * 
	 * @param f The file to be written. If the file already exists, its contents will be overwritten.
    * @param title Optional title (default = "Untitled") appears in the DSC "%%Title" comment in the "header" section 
    * of the document's prolog.
    * @param author Optional author string (default = "DataNav PS") appears in the DSC "%%Creator" comment in the 
    * "header" section of the document's prolog.
	 * @throws IOException if any file I/O operation fails
	 * @throws UnsupportedOperationException if invoked on an incomplete document.
	 */
	public void printToFile(File f, String title, String author) throws IOException, UnsupportedOperationException
	{
		printToFile(new FileOutputStream(f), title, author);
	}

	/**
	 * Print the completed PSDoc to a file output stream. The method closes the stream (unless the thread in which it 
	 * executed is interrupted??).
	 * 
	 * @param fos The file output stream.
    * @param title Optional title (default = "Untitled") appears in the DSC "%%Title" comment in the "header" section 
    * of the document's prolog.
    * @param author Optional author string (default = "DataNav PS") appears in the DSC "%%Creator" comment in the 
    * "header" section of the document's prolog.
	 * @throws IOException if any file I/O operation fails.
	 * @throws UnsupportedOperationException if invoked on an incomplete document.
	 */
	public void printToFile(FileOutputStream fos, String title, String author) 
         throws IOException, UnsupportedOperationException
	{
		if( !done ) 
		{
			fos.close();
			throw new UnsupportedOperationException( "PS document incomplete; cannot print!" );
		}

      try(Writer w = new BufferedWriter(new OutputStreamWriter(fos, StandardCharsets.US_ASCII)))
      {
         // first, the prolog header, prolog, and document setup sections
         w.write(getProlog(title, author));

         // then dump the main buffer -- this may be problematic b/c it could be a VERY BIG STRING
         w.write(mainBuf.toString());

         // in the document trailer, we merely pop the dictionary that was pushed onto the dict stack in document setup
         w.write(NEWLINE + "%%Trailer" + NEWLINE + "end" + NEWLINE + "%%EOF");

         w.flush();
      }
	}

	/**
	 * Return a byte stream representation of the completed <code>PSDoc</code>. This method delivers exactly the same PS 
	 * language program that's prepared by <code>PSDoc.printToFile(FileOutputStream,String)</code>, but packaged as an 
    * <code>InputStream</code> suitable for sending directly to a printer via Java's Print Service API. 
	 * 
	 * <p>DEV NOTE: The stream is backed by a byte array resident in memory -- which could be a serious problem for 
	 * large PS documents. It might be necessary to redesign this in the future.</p>
	 * 
	 * @return The completed Postscript language program for this <code>PSDoc</code> encapsulated as an input stream of 
    * bytes encoded in the standard "us-ascii" character set.
	 * @throws IOException if the character encoding is not supported or other IO error occurs.
	 * @throws UnsupportedOperationException if invoked on an incomplete document.
	 */
	public InputStream asInputStream() throws IOException, UnsupportedOperationException
	{
		if( !done ) throw new UnsupportedOperationException( "PS document incomplete; cannot print!" );

      @SuppressWarnings("StringBufferReplaceableByString") StringBuilder buf = new StringBuilder(10000);
		buf.append( getProlog(null, null) );
		buf.append( mainBuf );
		buf.append( NEWLINE + "%%Trailer" + NEWLINE + "end" + NEWLINE + "%%EOF" );

		return( new ByteArrayInputStream( buf.toString().getBytes(StandardCharsets.US_ASCII) ) );
	}

   /**
    * Prepares the prolog for this <code>PSDoc</code>.
    * 
    * @param title If a non-empty string, this is included in the "%%Title:" header comment.
    * @param author If a non-empty string, this is included in the "%%Creator:" header comment.
    * @return The prolog as a <code>String</code>.
    */
	@SuppressWarnings("rawtypes")
	private String getProlog(String title, String author) throws IOException
	{
	   // the title cannot contain any linefeeds, carriage returns or tabs
	   if(title != null) title = title.replaceAll("[\\n\\r\\t]", " ");
	   
		StringBuilder buf = new StringBuilder(1000);

		// first, the prolog header comments
		String bndBox = Math.round(boundBox.getX()) + " " +
            Math.round(boundBox.getY()) + " " +
            Math.round(boundBox.getX() + boundBox.getWidth()) + " " +
            Math.round(boundBox.getY() + boundBox.getHeight());
		Date now = new Date();
		String user = null;
		try{ user = System.getProperty( "user.name" ); } catch( Exception ignored) {}
		if( user == null ) user = "Unknown";

		buf.append("%!PS-Adobe-3.0").append(isEPS ? " EPSF-3.0" : "").append(NEWLINE)
				.append("%%BoundingBox: ").append(bndBox).append(NEWLINE)
				.append("%%Creator: ").append((author == null || author.isEmpty()) ? "DataNav PS" : author).append(NEWLINE)
				.append("%%CreationDate: ").append(now).append(NEWLINE)
				.append("%%For: ").append(user).append(NEWLINE)
				.append("%%LanguageLevel: 3").append(NEWLINE)
				.append("%%ProofMode: Substitute").append(NEWLINE)
				.append("%%Pages: ").append(nPages).append(NEWLINE)
				.append("%%PageOrder: Ascend").append(NEWLINE)
				.append("%%Title: ").append((title == null || title.isEmpty()) ? "Untitled" : title).append(NEWLINE);

		// document all fonts used in the prolog header
		if(!fontsUsed.isEmpty())
		{
			// if any fonts are used, we always include the Symbol font since it is always an entry in the composite fonts 
			// used by PSDoc to render the supported character set
			StringBuilder neededFonts = new StringBuilder("%%DocumentNeededResources: font Symbol ");
			Iterator fontIter = fontsUsed.keySet().iterator();
			int i = 1;
			while( fontIter.hasNext() )
			{
				if( i%5 == 0 ) 
				{
					neededFonts.append(NEWLINE + "%%+ font ");
				}
				neededFonts.append(fontIter.next()).append(" ");
				++i;
			}
			buf.append(neededFonts).append(NEWLINE);
		}

		// document all procedure sets used in the prolog header.  The procset title property keys are formed by 
		// appending ".title" to the key for the corresponding procset defn property.
		Properties procSetProps = getProcedureSetProperties();
		boolean firstLine = true;
      for(String setName : PROCSET_PRECEDENCE)
      {
         if(procSetsUsed.containsKey(setName))
         {
            if(firstLine)
            {
               buf.append("%%DocumentSuppliedResources: procset ").append(procSetProps.getProperty(setName + ".title"))
							.append(NEWLINE);
               firstLine = false;
            } else
               buf.append("%%+ procset ").append(procSetProps.getProperty(setName + ".title")).append(NEWLINE);
         }
      }

		buf.append( "%%EndComments" + NEWLINE + NEWLINE );

		// next, dump the prolog itself -- consisting of the defns of all procedure sets used in the script to follow, in 
		// order of precedence.  Also note that the procset definitions do NOT end in newline, but they begin with one.
		buf.append( "%%BeginProlog" );
      for(String s : PROCSET_PRECEDENCE)
         if(procSetsUsed.containsKey(s))
         {
            buf.append(procSetProps.getProperty(s));
         }
		buf.append( NEWLINE + "%%EndProlog" + NEWLINE + NEWLINE );

		// in the document setup section, we append "IncludeResource" comments for any font used in the document that is 
		// among the Level 1 "Standard 13" fonts.  We also make the dictionary used by the procedure sets the current 
		// dictionary.  This step is essential for EPS documents, which must be isolated from any document in which they 
		// are included.
		buf.append("%%BeginSetup" + NEWLINE).append(procSetProps.getProperty(PROCSET_DICT)).append(" begin")
				.append(NEWLINE);
		if(!fontsUsed.isEmpty())
		{
			// if any fonts are used, we always include the Symbol font since it is always an entry in the composite fonts 
			// used by PSDoc to render the supported character set
			buf.append( "%%IncludeResource: font Symbol" + NEWLINE );
         for(String fontName : fontsUsed.keySet())
         {
            if(isBasicFont(fontName))
               buf.append("%%IncludeResource: font ").append(fontName).append(NEWLINE);
         }
		}
		
		// our strategy for printing in landscape mode is to print a rotated image on portrait paper. This is the most
		// reliable way to get it to print correctly, although some PS readers will display the paper in portrait mode --
		// so you have to rotate the monitor 90 deg to look at it!
		// 
		// In startPage(), the coord system is rotated 90 deg CCW and then translated down by the portrait page width 
		// (which is the landscape page height) to put the origin back on the BL corner of the re-oriented page. The
		// setpagedevice() call here ensures PS readers handle this correctly.
		if(pageLayout.getOrientation() != PageFormat.PORTRAIT)
		{
		   buf.append("<< /PageSize ");
		   buf.append(String.format("[%d %d] ", (int) pageLayout.getHeight(), (int) pageLayout.getWidth()));
		   buf.append("/Orientation 0 >> setpagedevice" + NEWLINE);
		}
		buf.append( "%%EndSetup" + NEWLINE + NEWLINE );

		return( buf.toString() );
	}


	//
	// Adornments
	//

	/**
	 * Retrieve the unique name of the <code>PSDoc</code> prolog procedure which renders the specified <em>DataNav</em> 
    * adornment. 
	 * 
	 * <p>The relevant prolog procedure name is the marker name -- as returned by <code>Marker.toString()</code> -- 
    * prepended with the characters "A.". Each adornment procedure constructs a subpath that renders the adornment and 
    * appends it to the current path. <em>DataNav</em> adornments are designed WRT an s-by-s box centered at the point 
    * (xCtr,yCtr). All of the adornment procedures take the following form: "s xCtr yCtr A.adornName --". Arguments are
    * in current user space units.</p>
	 * 
	 * @param cap The marker symbol/adornment type.
	 * @return The adornment procedure name, or <code>null</code> if argument is <code>null</code>.
	 */
	private String getAdornmentPrologProc(Marker cap)
	{
		return((cap != null) ? ("A." + cap) : null);
	}
	

	//
	// Procedure sets for a DataNav PS document
	//

	/**
	 * Pathname of the resource file containing the Postscript language definitions of the procedure sets ("procset") 
    * that may be used by <code>PSDoc</code> to construct Postscript language program rendering a <em>DataNav</em> 
    * figure. The procset definitions are formatted for direct inclusion in the prolog section of the PS file. The 
    * resource file is accessed like a properties file, with a unique key for each procset definition. 
    * 
    * <p>IMPORTANT: Once the app is packaged in a JAR, a relative path like "../resources/prolog.txt" FAILS -- the
    * class loader routines won't find the resource. This string therefore contains an absolute path to the particular
    * resource within the <i>DataNav</i> resources package. If that package path should change, this string must 
    * likewise be updated!</p>

	 */
	private final static String PROLOG_RES = "/com/srscicomp/fc/resources/prolog.txt";
	
	/**
	 * Property key for accessing the Common procset definition string in the prolog procset resource/property file. 
	 * This procset is ALWAYS included in any Postscript file generated by PSDoc.
	 */
	private final static String PROCSET_COMMON = "ps.prolog.common";
	
	/**
	 * Property key for accessing the Adornments #1 procset definition string in the prolog procset resource/property 
	 * file. This procset includes the Postscript language definitions of these <em>DataNav</em> adornments:
	 * <code>Marker.CIRCLE, Marker.OVAL12, Marker.OVAL21, Marker.TEE, Marker.XHAIR, Marker.STAR</code>.
	 */
	private final static String PROCSET_ADORN1 = "ps.prolog.adorn1";
		
	/**
	 * Property key for accessing the Adornments #2 procset definition string in the prolog procset resource/property 
	 * file. This procset includes the Postscript language definitions of these <em>DataNav</em> adornments: 
    * <code>Marker.BOX, Marker.RECT12, Marker.RECT21</code>.
	 */
	private final static String PROCSET_ADORN2 = "ps.prolog.adorn2";

	/**
	 * Property key for accessing the Adornments #3 procset definition string in the prolog procset resource/property 
	 * file. This procset includes the Postscript language definitions of these <em>DataNav</em> adornments:
	 * <code>Marker.DIAMOND, Marker.DIAMOND12, Marker.DIAMOND21</code>.
	 */
	private final static String PROCSET_ADORN3 = "ps.prolog.adorn3";
	
	/**
	 * Property key for accessing the Adornments #4 procset definition string in the prolog procset resource/property 
	 * file. This procset includes the Postscript language definitions of these <em>DataNav</em> adornments:
	 * <code>Marker.UPTRIANGLE, Marker.DOWNTRIANGLE, Marker.LEFTTRIANGLE, Marker.RIGHTTRIANGLE</code>.
	 */
	private final static String PROCSET_ADORN4 = "ps.prolog.adorn4";

	/**
	 * Property key for accessing the Adornments #5 procset definition string in the prolog procset resource/property 
	 * file. This procset includes the Postscript language definitions of these <em>DataNav</em> adornments:
	 * <code>Marker.UPISOTRIANGLE, Marker.DOWNISOTRIANGLE, Marker.LEFTISOTRIANGLE, Marker.RIGHTISOTRIANGLE</code>.
	 */
	private final static String PROCSET_ADORN5 = "ps.prolog.adorn5";

	/**
	 * Property key for accessing the Adornments #6 procset definition string in the prolog procset resource/property 
	 * file. This procset includes the Postscript language definitions of these <em>DataNav</em> adornments:
	 * <code>Marker.UPDART, Marker.DOWNDART, Marker.LEFTDART, Marker.RIGHTDART</code>.
	 */
	private final static String PROCSET_ADORN6 = "ps.prolog.adorn6";

	/**
	 * Property key for accessing the Adornments #7 procset definition string in the prolog procset resource/property 
	 * file. This procset includes the Postscript language definitions of these <em>DataNav</em> adornments:
	 * <code>Marker.UPARROW, Marker.DOWNARROW, Marker.LEFTARROW, Marker.RIGHTARROW</code>.
	 */
	private final static String PROCSET_ADORN7 = "ps.prolog.adorn7";

	/**
	 * Property key for accessing the Adornments #8 procset definition string in the prolog procset resource/property 
	 * file. This procset includes the Postscript language definitions of these <em>DataNav</em> adornments:
	 * {@link Marker#LINETHRU}, {@link Marker#HLINETHRU}, {@link Marker#LINEUP}, {@link Marker#LINEDOWN}, 
	 * {@link Marker#BRACKET}.
	 */
	private final static String PROCSET_ADORN8 = "ps.prolog.adorn8";

	/**
	 * Property key for accessing the Adornments #9 procset definition string in the prolog procset resource/property 
	 * file. This procset includes the Postscript language definitions of these <em>DataNav</em> adornments:
	 * <code>Marker.ARROW, Marker.FILLARROW, Marker.REVERSEARROW, Marker.REVERSEFILLARROW</code>.
	 */
	private final static String PROCSET_ADORN9 = "ps.prolog.adorn9";

	/**
	 * Property key for accessing the Adornments #10 procset definition string in the prolog procset resource/property 
	 * file. This procset includes the Postscript language definitions of these <em>DataNav</em> adornments:
	 * <code>Marker.THINARROW, Marker.FILLTHINARROW, Marker.REVERSETHINARROW, Marker.REVERSEFILLTHINARROW</code>.
	 */
	private final static String PROCSET_ADORN10 = "ps.prolog.adorn10";
	
   /**
    * Property key for accessing the Adornments #11 procset definition string in the prolog procset resource/property 
    * file. This procset includes the Postscript language definitions of these <em>DataNav</em> adornments:
    * <code>Marker.WIDEARROW, Marker.FILLWIDEARROW, Marker.REVERSEWIDEARROW, Marker.REVERSEFILLWIDEARROW</code>.
    */
   private final static String PROCSET_ADORN11 = "ps.prolog.adorn11";

   /**
    * Property key for accessing the Adornments #12 procset definition string in the prolog procset resource/property 
    * file. This procset includes the Postscript language definitions of these <em>DataNav</em> adornments:
    * <code>Marker.DART, Marker.REVERSEDART, Marker.KITE, Marker.REVERSEKITE</code>.
    */
   private final static String PROCSET_ADORN12 = "ps.prolog.adorn12";

   /**
    * Property key for accessing the Adornments #13 procset definition string in the prolog procset resource/property 
    * file. This procset includes the Postscript language definitions of these <i>FypML</i> adornments:
    * {@link Marker#PARALLELOGRAM}, {@link Marker#PENTAGRAM}, {@link Marker#HEXAGRAM}, {@link Marker#PENTAGON}, 
    * {@link Marker#HEXAGON}, {@link Marker#OCTAGON}.
    */
   private final static String PROCSET_ADORN13 = "ps.prolog.adorn13";


	/**
	 * Property key for accessing the Adorned Paths procset definition string in the prolog procset resource/property 
	 * file.  This procset includes the Postscript language definitions for utilities that render individual symbols or 
	 * multiple symbols along a path.  Typically, any <em>DataNav</em> Postscript file that requires this procset will 
	 * also require at least one of the adornment procsets.
	 */
	private final static String PROCSET_ADORNPATHS = "ps.prolog.adornpaths";
	
	/**
	 * Property key for accessing the PolyPaths #1 procset definition string in the prolog procset resource/property 
	 * file.  This procset includes the Postscript language definitions for utilities that render an unadorned polyline
	 * or an unadorned set of arcs.
	 */
	private final static String PROCSET_POLYPATHS1 = "ps.prolog.polypaths1";
	
	/**
	 * Property key for accessing the PolyPaths #2 procset definition string in the prolog procset resource/property 
	 * file.  This procset includes the Postscript language definitions for several methods that are specific to the 
	 * rendering of a <em>DataNav</em> trace.
	 */
	private final static String PROCSET_POLYPATHS2 = "ps.prolog.polypaths2";
	
	/** Property key for prolog procset defining procedures related to color map gradient fill and lookup table. */
	private final static String PROCSET_COLORMAP = "ps.prolog.colormap";
	
	/**
	 * Property key for accessing the name of the dictionary used by all procedure set definitions included in the 
	 * prolog of a <em>DataNav</em> Postscript file.  It is made the current dictionary in the document setup section.
	 */
	private final static String PROCSET_DICT = "ps.prolog.dict";

	/** List of all prolog procedure set names in order of precedence. */
	private final static String[] PROCSET_PRECEDENCE = {
		PROCSET_COMMON, PROCSET_ADORN1, PROCSET_ADORN2, PROCSET_ADORN3, PROCSET_ADORN4, PROCSET_ADORN5, 
		PROCSET_ADORN6, PROCSET_ADORN7, PROCSET_ADORN8, PROCSET_ADORN9, PROCSET_ADORN10, PROCSET_ADORN11, 
		PROCSET_ADORN12, PROCSET_ADORN13, PROCSET_ADORNPATHS, PROCSET_POLYPATHS1, PROCSET_POLYPATHS2, PROCSET_COLORMAP
	};

	/**
	 * Maps the name of each <em>DataNav</em> PS prolog procedure to the name of the procedure set in which the 
	 * procedure is defined.  By breaking up the prolog procedures -- particularly the adornment procedures -- into a 
	 * lot of different sets, we reduce the size of the prolog required for a typical <em>DataNav</em> PS document.
	 * 
	 * <p>Note that the names of procedures in the <code>PROCSET_COMMON</code> are not included in this map because this
	 * procedure set is ALWAYS included in the prolog of any <code>PSDoc</code>.</p>
	 */
	private static final HashMap<String, String> mapPrologProcToSet;
	static
	{
		mapPrologProcToSet = new HashMap<>();

		mapPrologProcToSet.put( "A." + Marker.CIRCLE, PROCSET_ADORN1 );
		mapPrologProcToSet.put( "A." + Marker.OVAL12, PROCSET_ADORN1 );
		mapPrologProcToSet.put( "A." + Marker.OVAL21, PROCSET_ADORN1 );
		mapPrologProcToSet.put( "A." + Marker.TEE, PROCSET_ADORN1 );
		mapPrologProcToSet.put( "A." + Marker.XHAIR, PROCSET_ADORN1 );
		mapPrologProcToSet.put( "A." + Marker.STAR, PROCSET_ADORN1 );
		mapPrologProcToSet.put( "A." + Marker.BOX, PROCSET_ADORN2 );
		mapPrologProcToSet.put( "A." + Marker.RECT12, PROCSET_ADORN2 );
		mapPrologProcToSet.put( "A." + Marker.RECT21, PROCSET_ADORN2 );
		mapPrologProcToSet.put( "A." + Marker.DIAMOND, PROCSET_ADORN3 );
		mapPrologProcToSet.put( "A." + Marker.DIAMOND12, PROCSET_ADORN3 );
		mapPrologProcToSet.put( "A." + Marker.DIAMOND21, PROCSET_ADORN3 );
		mapPrologProcToSet.put( "A." + Marker.UPTRIANGLE, PROCSET_ADORN4 );
		mapPrologProcToSet.put( "A." + Marker.DOWNTRIANGLE, PROCSET_ADORN4 );
		mapPrologProcToSet.put( "A." + Marker.LEFTTRIANGLE, PROCSET_ADORN4 );
		mapPrologProcToSet.put( "A." + Marker.RIGHTTRIANGLE, PROCSET_ADORN4 );
		mapPrologProcToSet.put( "A." + Marker.UPISOTRIANGLE, PROCSET_ADORN5 );
		mapPrologProcToSet.put( "A." + Marker.DOWNISOTRIANGLE, PROCSET_ADORN5 );
		mapPrologProcToSet.put( "A." + Marker.LEFTISOTRIANGLE, PROCSET_ADORN5 );
		mapPrologProcToSet.put( "A." + Marker.RIGHTISOTRIANGLE, PROCSET_ADORN5 );
		mapPrologProcToSet.put( "A." + Marker.UPDART, PROCSET_ADORN6 );
		mapPrologProcToSet.put( "A." + Marker.DOWNDART, PROCSET_ADORN6 );
		mapPrologProcToSet.put( "A." + Marker.LEFTDART, PROCSET_ADORN6 );
		mapPrologProcToSet.put( "A." + Marker.RIGHTDART, PROCSET_ADORN6 );
		mapPrologProcToSet.put( "A." + Marker.UPARROW, PROCSET_ADORN7 );
		mapPrologProcToSet.put( "A." + Marker.DOWNARROW, PROCSET_ADORN7 );
		mapPrologProcToSet.put( "A." + Marker.LEFTARROW, PROCSET_ADORN7 );
		mapPrologProcToSet.put( "A." + Marker.RIGHTARROW, PROCSET_ADORN7 );
		mapPrologProcToSet.put( "A." + Marker.LINETHRU, PROCSET_ADORN8 );
		mapPrologProcToSet.put( "A." + Marker.HLINETHRU, PROCSET_ADORN8 );
		mapPrologProcToSet.put( "A." + Marker.LINEUP, PROCSET_ADORN8 );
		mapPrologProcToSet.put( "A." + Marker.LINEDOWN, PROCSET_ADORN8 );
		mapPrologProcToSet.put( "A." + Marker.BRACKET, PROCSET_ADORN8 );
		mapPrologProcToSet.put( "A." + Marker.ARROW, PROCSET_ADORN9 );
		mapPrologProcToSet.put( "A." + Marker.FILLARROW, PROCSET_ADORN9 );
		mapPrologProcToSet.put( "A." + Marker.REVERSEARROW, PROCSET_ADORN9 );
		mapPrologProcToSet.put( "A." + Marker.REVERSEFILLARROW, PROCSET_ADORN9 );
		mapPrologProcToSet.put( "A." + Marker.THINARROW, PROCSET_ADORN10 );
		mapPrologProcToSet.put( "A." + Marker.FILLTHINARROW, PROCSET_ADORN10 );
		mapPrologProcToSet.put( "A." + Marker.REVERSETHINARROW, PROCSET_ADORN10 );
		mapPrologProcToSet.put( "A." + Marker.REVERSEFILLTHINARROW, PROCSET_ADORN10 );
		mapPrologProcToSet.put( "A." + Marker.WIDEARROW, PROCSET_ADORN11 );
		mapPrologProcToSet.put( "A." + Marker.FILLWIDEARROW, PROCSET_ADORN11 );
		mapPrologProcToSet.put( "A." + Marker.REVERSEWIDEARROW, PROCSET_ADORN11 );
      mapPrologProcToSet.put( "A." + Marker.REVERSEFILLWIDEARROW, PROCSET_ADORN11 );
      mapPrologProcToSet.put( "A." + Marker.DART, PROCSET_ADORN12 );
      mapPrologProcToSet.put( "A." + Marker.REVERSEDART, PROCSET_ADORN12 );
      mapPrologProcToSet.put( "A." + Marker.KITE, PROCSET_ADORN12 );
      mapPrologProcToSet.put( "A." + Marker.REVERSEKITE, PROCSET_ADORN12 );
      mapPrologProcToSet.put( "A." + Marker.PARALLELOGRAM, PROCSET_ADORN13 );
      mapPrologProcToSet.put( "A." + Marker.PENTAGRAM, PROCSET_ADORN13 );
      mapPrologProcToSet.put( "A." + Marker.HEXAGRAM, PROCSET_ADORN13 );
      mapPrologProcToSet.put( "A." + Marker.PENTAGON, PROCSET_ADORN13 );
      mapPrologProcToSet.put( "A." + Marker.HEXAGON, PROCSET_ADORN13 );
      mapPrologProcToSet.put( "A." + Marker.OCTAGON, PROCSET_ADORN13 );

		mapPrologProcToSet.put( DO_ADORN, PROCSET_ADORNPATHS );
		mapPrologProcToSet.put( DO_ADORNEX, PROCSET_ADORNPATHS );
      mapPrologProcToSet.put( POLYADORN, PROCSET_ADORNPATHS );
      mapPrologProcToSet.put( POLYSTEMADORN, PROCSET_ADORNPATHS );
      mapPrologProcToSet.put( POLYROTADORN, PROCSET_ADORNPATHS );
      mapPrologProcToSet.put( POLYSIZEADORN, PROCSET_ADORNPATHS );
      mapPrologProcToSet.put( POLYFILLADORN, PROCSET_ADORNPATHS );
      mapPrologProcToSet.put( POLYSIZEFILLADORN, PROCSET_ADORNPATHS );
		mapPrologProcToSet.put( POLYLINE, PROCSET_POLYPATHS1 );
      mapPrologProcToSet.put( POLYFILL, PROCSET_POLYPATHS1 );
      mapPrologProcToSet.put( POLYFILLEX, PROCSET_POLYPATHS1 );
		mapPrologProcToSet.put( POLYARCS, PROCSET_POLYPATHS1 );
		mapPrologProcToSet.put( POLYCIRCLES, PROCSET_POLYPATHS1 );
		mapPrologProcToSet.put( POLYGONS, PROCSET_POLYPATHS2 );
		mapPrologProcToSet.put( POLYWEDGES, PROCSET_POLYPATHS2 );
		mapPrologProcToSet.put( MESH, PROCSET_POLYPATHS2 );
		
		mapPrologProcToSet.put(CMAPFILL, PROCSET_COLORMAP);
		mapPrologProcToSet.put(CMAPLUT,  PROCSET_COLORMAP);
	}

	/**
	 * Hashmap containing the names of which prolog procedure sets need to be included in the prolog of this PSDoc.
	 * The procedure set names are the map keys.  The map values are ignored; presence of a key in the map indicates 
	 * that the like-named procedure set should be included in the prolog.
	 * 
	 * @see PSDoc#includeFunctionInProlog(String)
	 */
	private final Map<String, String> procSetsUsed;

	/**
	 * Include the specified prolog procedure in this PSDoc's prolog, if it is not already present.  Since individual 
	 * prolog procedures are organized into procedure sets, this amounts to including the relevant procedure set.
	 * 
	 * <p>If the specified prolog procedure is dependent upon another prolog procedure for its definition, then that 
	 * other procedure is included as well.  The following dependencies exist among prolog procedures supported by 
	 * PSDoc.  Most are handled automatically because the procedures are in the same procset.  Dependencies across 
	 * procedure set definitions are noted below.
	 * <ul>
	 * 	<li>A.star depends upon A.tee AND A.xhair</li>
	 *    <li>A.oval1:2 and A.oval2:1 depend upon A.circle</li>
	 * 	<li>A.fillArrow depends upon A.arrow</li>
	 * 	<li>A.fillThinArrow depends upon A.thinArrow</li>
	 * 	<li>A.fillWideArrow depends upon A.wideArrow</li>
	 * 	<li>A.reverseFillArrow depends upon A.reverseArrow</li>
	 * 	<li>A.reverseFillThinArrow depends upon A.reverseThinArrow</li>
	 * 	<li>A.reverseFillWideArrow depends upon A.reverseWideArrow</li>
	 * 	<li>setViewport depends upon doRect</li>
	 * 	<li>polyAdorn, polyRotAdorn, and polySizeAdorn depend upon adorn</li>
	 * 	<li>polyCircles depends upon A.circle.  These are in different procedure sets.  The method insures that both  
	 * 	the <code>PROCSET_POLYPATHS</code> and <code>PROCSET_ADORN1</code> procsets are both included in prolog.</li>
	 * 	<li>Many procedures depend upon useFillColor.  For that reason, this procedure is part of the 
	 *    <code>PROCSET_COMMON</code> procset, which is ALWAYS included in prolog.</li>
	 *    <li>{@link #MESH} depends on {@link #CMAPFILL}, which is in a different procedure set.</li>
	 * </ul>
	 * </p>
	 * 
	 * <p>This method is dependent on the content of the prolog properties file.  If changes are made to that file, then 
	 * this method may have to be updated.</p>
	 * 
	 * @param 	procName The procedure's unique name
	 */
	private void includeFunctionInProlog( String procName )
	{
		String setName = mapPrologProcToSet.get(procName);
		if(setName != null)
			procSetsUsed.put(setName, null);

		// the POLYCIRCLES procedure depends on A.circle, which is in a different proc set
		if( procName.equals(POLYCIRCLES) ) 
			procSetsUsed.put(PROCSET_ADORN1, null);
		// similarly for MESH and CMAPFILL
		if(procName.equals(MESH))
		   procSetsUsed.put(PROCSET_COLORMAP, null);
	}

	/**
	 * Loads the titles and definitions of the procedure sets used by <code>PSDoc</code>, which are stored in a resource 
    * file.
	 * 
	 * @return A <code>Properties</code> object containing the title and definition of each procedure set that may be 
    * used by <code>PSDoc</code>.
	 * @throws IOException if unable to load the procedure set info from an internal properties file
	 */
	private static Properties getProcedureSetProperties() throws IOException
	{
		Properties procSetProps = new Properties();
		InputStream is = PSDoc.class.getResourceAsStream( PROLOG_RES );
		if( is == null ) throw new IOException( "Unable to open prolog resource file" );
		else procSetProps.load( is );

		return( procSetProps );
	}



	/**
	 * For test/debug only: Get the path for a directory containing figure files (.fyp). Create a subdirectory "ps" 
	 * within that directory, then export each figure file to Postscript, storing the PS files in the "ps" folder. 
	 * 
	 * 
	 * 
	 * @param 	args	the command-line arguments (NOT USED)
	 */
	public static void main(String[] args)
	{
	   System.out.println("FypML->Postscript utility. Exports all .fyp/.fig files in a chosen directory to Postscript\n"
	         + "and stores them in a subfolder 'ps' within that directory.\n\n");
      
      BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
      
      // get full path to a directory containing FypML figure files
      String input = null;
      System.out.print("\nEnter full path for foldering containing .fyp or .fig files > ");
      boolean ok = true;
      try
      {
         input = in.readLine().trim();
      }
      catch(IOException ioe)
      {
         System.out.println(" ---> Unexpected IO error while reading user input. QUITTING!");
         ok = false;
      }
      if(!ok) System.exit(0);
      
      File dir = new File(input);
      if(!dir.isDirectory())
      {
         System.out.printf("---> '%s' is not a valid existing directory. QUITTING!%n", dir);
         System.exit(0);
      }
      
      File psFolder = new File(dir, "ps");
      ok = (!psFolder.exists()) && psFolder.mkdir();
      if(!ok)
      {
         System.out.printf("---> Unable to create 'ps' subfolder in %s. QUITTING!%n", dir);
         System.exit(0);
      }
      
      StringBuffer msgBuf = new StringBuffer();
      System.out.println();
      File[] files = dir.listFiles();
		if(files == null)
		{
			System.out.println("No files found or file system error!");
			System.exit(1);
		}

      for(File f : files)
      {
         msgBuf.setLength(0);
         FGraphicModel fgm = null;
         boolean isFyp = FGModelSchema.isFigureModelXMLFile(f);
         if(isFyp || MatlabFigureImporter.isMatlabFigFile(f))
         {
            System.out.printf("Exporting %s...%n", f.getName());
            fgm = isFyp ? FGModelSchemaConverter.fromXML(f, msgBuf) :
                     MatlabFigureImporter.importMatlabFigureFromFile(f, msgBuf);
            if(fgm == null)
               System.out.println("---> Failed to open figure: " + msgBuf);
         }
         if(fgm == null) continue;

         int dot = f.getName().lastIndexOf('.');
         String fname = f.getName().substring(0, dot) + ".ps";
         File dst = new File(psFolder, fname);
         try
         {
            FigureNode fig = (FigureNode) fgm.getRoot();
            PageFormat psPageFmt = PrinterSupport.getInstance().getCurrentPageFormat();
            PSDoc psDoc = PSDoc.createPostscriptDoc(fig, psPageFmt, true);

            // set PS bounding box to figure bounds on printed page
            final double MILLI_IN2PT = 72.0 / 1000.0;
            Point2D figBotLeft = fig.getPrintLocationMI();
            Rectangle2D bb = new Rectangle2D.Double(
                  psPageFmt.getImageableX() + figBotLeft.getX() * MILLI_IN2PT,
                  psPageFmt.getHeight() - psPageFmt.getImageableY() - psPageFmt.getImageableHeight() +
                     figBotLeft.getY()*MILLI_IN2PT,
                  fig.getWidthMI() * MILLI_IN2PT, fig.getHeightMI() * MILLI_IN2PT);
            psDoc.setBoundingBox(bb);

            String title = "Figure Composer figure ";
            if(!fig.getTitle().isEmpty()) title += " (" + fig.getTitle() + ")";
            String author = FCWorkspace.getApplicationTitle() + " " + FCWorkspace.getApplicationVersion();
            psDoc.printToFile(dst, title, author);
         }
         catch(IOException|UnsupportedOperationException e)
         {
            System.out.println("---> Export failed: " + e.getMessage());
         }
      }
      
      System.out.println("\n\nBYE!");
	}

}
